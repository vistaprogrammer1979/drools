package Accountant

import java.util.ArrayList
import java.util.Set
import com.accumed.pricing.model.request.Workflow
import com.accumed.pricing.model.request.ClaimType
import com.accumed.pricing.model.Facility
import com.accumed.pricing.model.request.ObservationOutcome
import com.accumed.pricing.model.SPCCodeFactor
import com.accumed.pricing.model.request.Activity
import com.accumed.pricing.model.ObseleteEncounter
import com.accumed.pricing.model.request.Diagnosis
import com.accumed.pricing.model.request.ClaimOutcome
import com.accumed.pricing.DAO
import com.accumed.webservices.converters.XmlDateAdapter
import com.accumed.pricing.model.DRGExcludedCpts
import com.accumed.pricing.model.request.ActivityOutcome
import com.accumed.pricing.model.request.WorkflowOutcome
import com.accumed.webservices.converters.XmlCodeTypeAdapter
import com.accumed.pricing.model.request.CoPayment
import com.accumed.pricing.model.DHA_DRG
import com.accumed.pricing.model.request.Contract
import com.accumed.webservices.converters.XmlDateTimeAdapter
import com.accumed.pricing.model.CusPricList
import com.accumed.pricing.model.request.DiagnosisOutcome
import com.accumed.pricing.model.request.AppliedDeductible
import com.accumed.pricing.model.SPCGroupFactor
import com.accumed.pricing.model.request.EncounterOutcome
import com.accumed.pricing.model.GroupCodesRange
import com.accumed.pricing.model.CusContract
import com.accumed.pricing.model.SPCContract
import com.accumed.pricing.model.request.AppliedCopayment
import com.accumed.pricing.model.ObseleteClaim
import com.accumed.pricing.model.request.Request
import com.accumed.pricing.model.request.Authorisation
import com.accumed.pricing.model.request.PatientInsurance
import com.accumed.pricing.model.request.ExtendedValidationType
import com.accumed.pricing.model.Severity
import com.accumed.pricing.model.request.Encounter
import com.accumed.pricing.model.ObseleteActivity
import com.accumed.pricing.model.request.PatientOutcome
import com.accumed.pricing.model.ControlFact
import com.accumed.pricing.model.request.Observation
import com.accumed.pricing.model.DrugPrice
import com.accumed.pricing.model.request.Deductible
import com.accumed.pricing.model.request.ContractOutcome
import com.accumed.pricing.model.request.CodeType
import com.accumed.pricing.model.request.ActivityGroup
import com.accumed.pricing.model.CusPriceListItem
import com.accumed.pricing.model.ObseleteClaimInfo
import com.accumed.pricing.model.request.AuthorisationOutcome
import com.accumed.webservices.converters.XmlGenderAdapter
import com.accumed.pricing.model.request.Header
import com.accumed.pricing.model.MasterPriceListItem
import com.accumed.pricing.model.MasterPriceList
import com.accumed.pricing.model.request.RequestOutcome
import com.accumed.pricing.model.request.PatientInsuranceOutcome
import com.accumed.pricing.model.Clinician
import com.accumed.pricing.model.DRG
import com.accumed.pricing.model.request.ResubmissionOutcome
import com.accumed.pricing.model.DHA_DRG_COST_PER_ACTIVITY
import com.accumed.pricing.model.DHA_DRG_HighCost
import com.accumed.pricing.model.request.Patient
import com.accumed.pricing.model.request.Resubmission
import com.accumed.pricing.model.request.Claim
import com.accumed.pricing.model.Regulator
import com.accumed.webservices.converters.XmlStringLength
import com.accumed.pricing.model.ObseleteDiagnosis
import com.accumed.pricing.model.request.HeaderOutcome
import com.accumed.pricing.model.CodeGroup
import com.accumed.pricing.model.FacilityType
import com.accumed.pricing.model.request.ExtendedValidationTypeOutcome
import com.accumed.pricing.model.request.Workflow
import com.accumed.pricing.model.PackageItemCode
import com.accumed.pricing.model.CustomCode
import com.accumed.pricing.model.PackageCode
import com.accumed.pricing.model.Status
import com.accumed.pricing.model.RCMFacilityCodeMapping















//The function hasDoubleValue checks if a Double value is not null, greater than 0, and not NaN.
function boolean hasDoubleValue(Double d) {
    return d != null && d > 0 && !d.isNaN();
}

function boolean isDentalConsultationCode(String sCode) {
    // Check if the code falls within the range "01101" to "01103" (inclusive)
    if ((sCode.compareToIgnoreCase("01101") >= 0 && sCode.compareToIgnoreCase("01103") <= 0)
            // OR check if the code falls within the range "01202" to "01205" (inclusive)
            || (sCode.compareToIgnoreCase("01202") >= 0 && sCode.compareToIgnoreCase("01205") <= 0)
            // OR check if the code matches any of the specific dental consultation codes
            || sCode.compareToIgnoreCase("D0120") == 0
            || sCode.compareToIgnoreCase("D0140") == 0
            || sCode.compareToIgnoreCase("D0145") == 0
            || sCode.compareToIgnoreCase("D0150") == 0
            || sCode.compareToIgnoreCase("D0160") == 0
            || sCode.compareToIgnoreCase("D0170") == 0
            || sCode.compareToIgnoreCase("D0180") == 0) {
        // If any of the above conditions are true, return true
        return true;
    }
    // Otherwise, return false
    return false;
}

function boolean isOrderStatusCompleted(String requestOrderStatus) {
    // Check if the requestOrderStatus is not null AND
    // matches either "cm" (case-insensitive) or "completed" (case-insensitive) by converting the string to lowercase
    if (requestOrderStatus != null && 
        (requestOrderStatus.toLowerCase() == "cm" || requestOrderStatus.toLowerCase() == "completed")) {
        // If the condition is true, return true
        return true;
    }
    // Otherwise, return false
    return false;
}

//this function prints the triggered rule along with info message
function void logInfo(String ruleName, String info) {
	System.out.println(ruleName + info);
}

function boolean notManualCustomPrice(java.lang.String custom_Price_Types) {
    // Check if the input is null or empty
    if (custom_Price_Types == null || custom_Price_Types.length() == 0) {
        return true; // Return true if the input is null or empty
    }

    // Check if the input does not contain "3" or "5"
    boolean doesNotContainSpecialValues = (custom_Price_Types.indexOf("3") == -1 && custom_Price_Types.indexOf("5") == -1);

    // Return the result of the check
    return doesNotContainSpecialValues;
}

function double processWithCeiling(double ceiling, double claimTotal, double value) {
    // Calculate the future deductible total by adding the current claimTotal and the new value
    double futureDeductibleTotal = claimTotal + value;

    // Initialize the applied deductible to 0.0
    double appliedDeductible = 0.0d;

    // Check if the future deductible total exceeds the ceiling
    if (futureDeductibleTotal > ceiling) {
        // If it exceeds, calculate the applied deductible as the difference between the ceiling and claimTotal
        appliedDeductible = ceiling - claimTotal;

        // Ensure the applied deductible is non-negative (absolute value)
        appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
    } else {
        // If it does not exceed the ceiling, the applied deductible is simply the input value
        appliedDeductible = value;
    }

    // Round the applied deductible and return it
    return appliedDeductible = roundDouble(appliedDeductible);
}

function double processWithoutCeiling(double ceiling, double claimTotal, double value, double gross) {
    // Initialize the applied deductible to 0.0
    double appliedDeductible = 0.0d;

    // Round the input value to two decimal places and assign it to appliedDeductible
    appliedDeductible = roundDouble(value);

    // Ensure the applied deductible does not exceed the gross amount
    if (appliedDeductible > gross) {
        appliedDeductible = gross;
    }

    // Add the applied deductible to the claim total
    claimTotal = claimTotal + appliedDeductible;

    // If the claim total exceeds the input value, reset the applied deductible to 0.0
    if (claimTotal > value) {
        appliedDeductible = 0.0d;
    }

    // Return the calculated applied deductible
    return appliedDeductible;
}

function Double roundDouble(java.lang.Double d) {
  double value = Math.round(d * 100); 
    return value / 100; 
}

function Double roundQuad(Object d) {
    if (d == null) {
        return null;
    }

    Double value;
    
    if (d instanceof String) {
        try {
            value = Double.parseDouble((String) d);
        } catch (NumberFormatException e) {
            return null; // Return null if parsing fails
        }
    } else if (d instanceof Double) {
        value = (Double) d;
    } else {
        return null; // Return null for unsupported types
    }

    double roundedValue = Math.round(value * 10000) / 10000.0;
    return roundedValue;
}

function java.util.Date toDate(String sDate) {
    // Create a SimpleDateFormat object with the pattern "dd/MM/yyyy"
    java.text.SimpleDateFormat fmt = new java.text.SimpleDateFormat("dd/MM/yyyy");

    // Parse the input string (sDate) into a java.util.Date object
    return fmt.parse(sDate);
}


function java.util.Date  truncateDate(java.util.Date dateObject) {
    // Create a clone of the input date object to avoid modifying the original
    java.util.Date ret = (java.util.Date) dateObject.clone();

    // Set the hours, minutes, and seconds of the cloned date to 0
    ret.setHours(0);    // Set hours to 0 (midnight)
    ret.setMinutes(0);  // Set minutes to 0
    ret.setSeconds(0);  // Set seconds to 0

    // Return the truncated date (time part set to 00:00:00)
    return ret;
}













rule 'ALERT_NO_LIST_PRICE'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -501

// Prevent rule from looping (no re-evaluation if the rule modifies working memory)
no-loop

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object where 'gross' is null
    $c: Claim(gross == null)

    // Find an Activity object associated with the Claim where:
    // - 'gross' is null
    // - 'list' is null or NaN
    // - Capture the 'outcome' field of the Activity in variable $outcome
    $act: Activity(gross == null, 
                  list == null || list.isNaN(), 
                  $outcome: outcome) from $c.activity

    // Ensure there is no ActivityOutcome with ruleName "ALERT_NO_LIST_PRICE" in the outcome
    not(ActivityOutcome(ruleName == "ALERT_NO_LIST_PRICE") from $act.outcome)
then
    // Rule actions (RHS - Right Hand Side)

    // Log information if logging is enabled for the Claim
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), 
                "List price not found for Activity ID=" + $act.getIdCaller() + 
                " code=" + $act.getCode());
    }

    // Add a new outcome to the Activity with INFO severity
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
                    "List price not found.", "");
end

rule 'COPAY_CPT_LABORATORY'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -2850

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object (no specific conditions)
    $c: Claim()

    // Find a CoPayment object where:
    // - type is "Laboratory" or "Labarotary" (typo included)
    // - value is greater than 0
    // - Capture ceiling and claimTotal values
    $coPayment: CoPayment(
        type in ("Laboratory", "Labarotary"), value > 0,$value:value,
        $ceiling: ceiling, $claimTotal: claimTotal
    )

    // Find an Activity object where:
    // - type is CPT
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - OrderStatus is "cm" or "completed"
    // - Capture activityGroup
    $act: Activity(
        type == CodeType.CPT,
        gross != null, gross > 0, !gross.isNaN(),$gross:gross,
        copayment == null,
        $groups: activityGroup,
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Ensure the ActivityGroup is of type CPT and name is "Pathology & Laboratory"
    ActivityGroup(
        type == CodeType.CPT.getValue(),
        name == "Pathology & Laboratory"
    ) from $groups

//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 

then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }
end

rule 'COPAY_CPT_MRI'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -2750

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object (no specific conditions)
    $c: Claim()

    // Find a CoPayment object where:
    // - type is "MRI"
    // - value is greater than 0
    // - Capture ceiling and claimTotal values
    $coPayment: CoPayment(
        type == "MRI", value > 0,$value:value,
        $ceiling: ceiling, $claimTotal: claimTotal
    )

    // Find an Activity object where:
    // - type is CPT
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - OrderStatus is "cm" or "completed"
    // - Capture activityGroup
    $act: Activity(
        type == CodeType.CPT,
        gross != null, gross > 0, !gross.isNaN(),$gross:gross,
        copayment == null,
        $groups: activityGroup,
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Ensure the ActivityGroup is of type CPT and name is "Radiology"
    ActivityGroup(
        type == CodeType.CPT.getValue(),
        name == "Radiology"
    ) from $groups

	//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }
end

rule 'COPAY_CPT_CONSULTATION'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -2900

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object (no specific conditions)
    $c: Claim()

    // Find a CoPayment object where:
    // - type is "Consultation" or "Consultant"
    // - value is greater than 0
    // - Capture ceiling and claimTotal values
    $coPayment: CoPayment(
        type in ("Consultation", "Consultant"), value > 0,$value:value,
        $ceiling: ceiling, $claimTotal: claimTotal
    )

    // Find an Activity object where:
    // - type is CPT
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - clinician does not match specific patterns (e.g., "GN.*", "GP.*", "T.*", "GT.*")
    // - OrderStatus is "cm" or "completed"
    // - Capture activityGroup
    $act: Activity(
        type == CodeType.CPT,
        gross != null, gross > 0, !gross.isNaN(),$gross:gross,
        copayment == null,
        $groups: activityGroup,
        clinician not matches "GN.*",
        clinician not matches "GP.*",
        clinician not matches "T.*",
        clinician not matches "GT.*",
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Ensure the ActivityGroup is of type CPT and name is "Evaluation And Management"
    ActivityGroup(
        type == CodeType.CPT.getValue(),
        name == "Evaluation And Management"
    ) from $groups

//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }
end

rule 'CALC_GROSS'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -400

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object where gross is null
    $c: Claim(gross == null)

    // Find an Activity object where:
    // - gross is null
    // - list is not null and not NaN
    // - Capture list, discount, and quantity values
    $act: Activity(
        gross == null,
        list != null, !list.isNaN(),
        $list: list,
        $discount: discount,
        $quantity: quantity
    )
then
    // Rule actions (RHS - Right Hand Side)

    // Log information if logging is enabled for the Claim
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            "Based on list price = " + $list + " to Activity ID=" + $act.getIdCaller() +
            " code=" + $act.getCode());
    }

    // Calculate NewGross based on list price, quantity, and discount
    Double NewGross = roundDouble(
        ($list * ($quantity == null || $quantity.isNaN() || $quantity < 0 ? 1 : $quantity)) -
        ($discount == null || $discount.isNaN() ? 0 : $discount)
    );

    // Set the calculated gross value on the Activity
    $act.setGross(NewGross);

    // Add an outcome to the Activity with INFO severity
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Based on list price " + roundDouble($list) + "", "");

    // Update the Activity object in working memory
    update($act);
end

rule 'COPAY_CPT_GENERAL_PRACTITIONER'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -2950

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object and capture providerID
    $c: Claim($providerID: providerID)

    // Find a CoPayment object where:
    // - type is "General Practitioner" or "GP"
    // - value is greater than 0
    // - Capture ceiling and claimTotal values
    $coPayment: CoPayment(
        type in ("General Practitioner", "GP"), value > 0,$value:value,
        $ceiling: ceiling, $claimTotal: claimTotal
    )

    // Find an Activity object where:
    // - type is CPT
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - OrderStatus is "cm" or "completed"
    // - Capture activityGroup and clinician
    $act: Activity(
        type == CodeType.CPT,
        gross != null, gross > 0, !gross.isNaN(),$gross:gross,
        copayment == null,
        $groups: activityGroup,
        $clinician: clinician,
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Ensure the ActivityGroup is of type CPT and name is "Evaluation And Management"
    ActivityGroup(
        type == CodeType.CPT.getValue(),
        name == "Evaluation And Management"
    ) from $groups

    // Find a Clinician object where:
    // - facility_license matches the providerID from the Claim
    // - license matches the clinician from the Activity
    // - category matches "medical practitioner" or "general practitioner" and does not match "gp"
    Clinician(
        facility_license == $providerID,
        license == $clinician,
        (category.toLowerCase() matches '.*medical practitioner.*' ||
         category.toLowerCase() matches '.*general practitioner.*') &&
        category.replace('.', '').toLowerCase() not matches ".*gp.*"
    )
	//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }
end

rule 'COPAY_CPT_DIAGNOSTIC'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -3050

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object (no specific conditions)
    $c: Claim()

    // Ensure the Encounter type is less than 3 or greater than 6
    Encounter(type < 3 || type > 6) from $c.encounter

    // Find a CoPayment object where:
    // - type is "Diagnostic"
    // - value is greater than 0
    // - Capture ceiling and claimTotal values
    $coPayment: CoPayment(
        type == "Diagnostic", value > 0,$value:value,
        $ceiling: ceiling, $claimTotal: claimTotal
    )

    // Find an Activity object where:
    // - type is CPT
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - OrderStatus is "cm" or "completed"
    // - Capture activityGroup
    $act: Activity(
        type == CodeType.CPT,
        gross != null, gross > 0, !gross.isNaN(),$gross:gross,
        copayment == null,
        $groups: activityGroup,
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Ensure the ActivityGroup is of type CPT and name is "DGTest_CPT_9_Series"
    ActivityGroup(
        type == CodeType.CPT.getValue(),
        name == "DGTest_CPT_9_Series"
    ) from $groups

	//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }
end

rule 'CALC_CLAIM_TOTALS'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -10000

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object where patientShare, net, and gross are null
    $c: Claim(patientShare == null, net == null, gross == null)

    // Calculate the total gross amount from all associated Activities
    $totalGross: Number(doubleValue > 0.0d) from accumulate(
        Activity(gross != null, gross > 0.0d, !gross.isNaN(), $gross: gross),
        sum($gross)
    )

    // Calculate the total deductible amount from all associated Activities
    $totalDed: Number() from accumulate(
        Activity(deductible != null, deductible > 0.0d, !deductible.isNaN(), $deductible: deductible),
        sum($deductible)
    )

    // Calculate the total copayment amount from all associated Activities
    $totalCoPay: Number() from accumulate(
        Activity(copayment != null, copayment > 0.0d, !copayment.isNaN(), $copayment: copayment),
        sum($copayment)
    )

    // Calculate the total EX_PBP amount from all associated Activities
    $totalExPBP: Number() from accumulate(
        Activity(EX_PBP != null, !EX_PBP.isNaN(), $EX_PBP: EX_PBP),
        sum($EX_PBP)
    )
then
    // Rule actions (RHS - Right Hand Side)

    // Calculate patientShare as the sum of totalDed, totalCoPay, and totalExPBP
    double patientShare = roundDouble($totalDed + $totalCoPay + $totalExPBP);

    // Calculate net as the difference between totalGross and patientShare
    double net = roundDouble($totalGross - patientShare);

    // Log detailed information if logging is enabled for the Claim
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            "totalDeductible=" + $totalDed +
            ", totalCoPayment=" + $totalCoPay +
            ", Extra PBP=" + $totalExPBP +
            ", totalGross=" + $totalGross +
            ", patientShare=" + patientShare +
            ", Net=" + net);
    }

    // Add an outcome to the Claim with the calculated values
    $c.addOutcome(Severity.INFO, drools.getRule().getName(),
        "totalDeductible=" + $totalDed +
        ", totalCoPayment=" + $totalCoPay +
        ", Extra PBP=" + $totalExPBP +
        ", totalGross=" + $totalGross +
        ", patientShare=" + patientShare +
        ", Net=" + net, "");

    // Update the Claim with the calculated values
    $c.setGross($totalGross);
    $c.setPatientShare(patientShare);
    $c.setNet(net);

    // Update the Claim object in working memory
    update($c);

end

rule 'CALC_ACTIVITY_NET_REPORTING'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -4500

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object where logInfo is true
    $c: Claim(logInfo == true)

    // Find any Activity object (no specific conditions)
    $act: Activity()
then
    // Rule actions (RHS - Right Hand Side)

    // Log detailed information about the Activity's fields
    logInfo(drools.getRule().getName(), 
        "gross=" + ($act.getGross() == null ? "null" : $act.getGross()) +
        ", list=" + ($act.getList() == null ? "null" : $act.getList()) +
        ", patientShare=" + ($act.getPatientShare() == null ? "null" : $act.getPatientShare()) +
        ", deductible=" + ($act.getDeductible() == null ? "null" : $act.getDeductible()) +
        ", copayment=" + ($act.getCopayment() == null ? "null" : $act.getCopayment())
    );
end

rule 'CALC_ACTIVITY_NET'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -5000

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object (no specific conditions)
    $c: Claim()

    // Find an Activity object associated with the Claim where:
    // - 'gross' is not null, greater than 0.0, and not NaN
    // - 'net' is null or NaN
    // - 'patientShare' is null or NaN
    // - Capture 'gross', 'copayment', 'deductible', and 'EX_PBP' values
    $act: Activity(
        gross != null, gross > 0.0d, !gross.isNaN(),
        net == null || net.isNaN(),
        patientShare == null || patientShare.isNaN(),
        $gross: gross,
        $copayment: copayment,
        $deductible: deductible,
        $EX_PBP: EX_PBP
    )
then
    // Initialize a message variable for logging and outcomes
    String message = "";

    // Calculate patientShare by summing deductible, copayment, and EX_PBP (if they exist)
    double patientShare = roundDouble(
        (($deductible == null || $deductible.isNaN()) ? 0 : $deductible) +
        (($copayment == null || $copayment.isNaN()) ? 0 : $copayment) +
        (($EX_PBP == null || $EX_PBP.isNaN()) ? 0 : $EX_PBP)
    );

    // Calculate specialDiscount based on specialDiscountPercentage or specialDiscountAmount
    Double specialDiscount = ($act.getSpecialDiscountPercentage() == null ? 0.0d :
        ($act.getSpecialDiscountPercentage().isNaN() ? 0.0d :
            roundDouble(($gross / 100) * $act.getSpecialDiscountPercentage())
    ));

    // If specialDiscount is 0 and specialDiscountAmount exists, use specialDiscountAmount
    if ((specialDiscount == null || specialDiscount == 0.0d) &&
        ($act.specialDiscountAmount != null && $act.specialDiscountAmount > 0.0d)) {
        specialDiscount = $act.getSpecialDiscountAmount();
    }

    // If specialDiscount is valid, adjust patientShare and prepare a message
    if (specialDiscount != null && specialDiscount > 0.0d) {
        double tobeDeductedFromPS = roundDouble(specialDiscount / $gross * patientShare);
        patientShare = roundDouble(patientShare - tobeDeductedFromPS);
        $act.setSpecialDiscountAmount(specialDiscount);
        message = "Apply special discount [" + tobeDeductedFromPS + "] to (patient share). ";
    }

    // Ensure patientShare is not negative
    if (patientShare < 0) {
        patientShare = 0;
    }

    // Calculate net by subtracting specialDiscount and patientShare from gross
    double net = roundDouble($gross - specialDiscount - patientShare);

    // Ensure net is not negative
    if (net < 0) {
        net = 0;
    }

    // Prepare the final message
    message = "patientShare=[" + roundDouble(patientShare) + "] net=[" + roundDouble(net) + "]. " + message;

    // Handle the Activity based on its OrderStatus
    if ($act.getOrderStatus() != null && 
        ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")) {
        // If OrderStatus is "Completed" or "CM":
        if ($c.logInfo) {
            logInfo(drools.getRule().getName(),
                "Set patientShare=" + patientShare + " net=" + net +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode() + " Order Status: Completed");
        }
        message = "Order Status: Completed, " + message;
        $act.addOutcome(Severity.INFO, drools.getRule().getName(), message, "");
        $act.setPatientShare(patientShare);
        $act.setNet(net);
    } else {
        // If OrderStatus is not "Completed" or "CM":
        if ($c.logInfo) {
            logInfo(drools.getRule().getName(),
                "Set patientShare=0.0 net=" + $gross +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode() + " Order Status: Not Completed");
        }
        message = "Order Status: Not Completed, " + message;
        $act.addOutcome(Severity.INFO, drools.getRule().getName(), message, "");
        $act.setCopayment(0.0d);
        $act.setDeductible(0.0d);
        $act.setPatientShare(0.0d);
        $act.setNet($gross);
    }

    // Update the Activity object in working memory
    update($act);

end

rule 'COPAY_CPT_X_RAY'
// Set the dialect to MVEL for this rule
dialect 'mvel'

// Set the salience (priority) of this rule to -2700
salience -2700

when
    // Match any Claim object and assign it to $c
    $c: Claim()
    
    // Match a CoPayment object with the following conditions:
    // - Type is "X-RAY" (case-insensitive, so we convert type to uppercase)
    // - Value is greater than 0
    // - Extract ceiling and claimTotal fields for further calculations
    $coPayment: CoPayment(
        type.toUpperCase() == "X-RAY",
        value > 0,$value:value,
        $ceiling: ceiling,
        $claimTotal: claimTotal
    )
    
    // Match an Activity object with the following conditions:
    // - Type is CPT (using CodeType.CPT)
    // - Gross is not null, greater than 0, and not NaN (ensuring it's a valid number)
    // - Copayment has not yet been assigned (copayment == null)
    // - Capture the activity groups into $groups for later matching
    // - The order status is either "cm" or "completed" (case-insensitive)
    $act: Activity(
        type == CodeType.CPT,
        gross != null,
        gross > 0,$gross:gross,
        !gross.isNaN(),
        copayment == null,
        $groups: activityGroup,
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" ||
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
    
    // Match an ActivityGroup object within the previously captured groups ($groups)
    // Conditions:
    // - The type is CPT (using the getValue() method from CodeType.CPT)
    // - The name is exactly "X-RAY"
    ActivityGroup(
        type == CodeType.CPT.getValue(),
        name == "X-RAY"
    ) from $groups
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Get the name of the current rule for logging purposes
    String sRuleName = drools.getRule().getName();

    // Check if the ceiling value is valid (i.e., not null, not NaN, and greater than 0)
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the potential copayment based on the activity's gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        
        // Calculate what the total copayment would be if this new value is applied
        double futureCopayTotal = $claimTotal + value;
        
        // Initialize the applied copayment amount
        double appliedCopay = 0.0d;

        // Check if adding the new copayment would exceed the ceiling
        if (futureCopayTotal > $ceiling) {
            // Cap the copayment at the remaining ceiling amount
            appliedCopay = $ceiling - $claimTotal;
            // Ensure the applied copayment is a positive number
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If within the ceiling, use the full calculated copayment value
            appliedCopay = value;
        }

        // Round the applied copayment value to the required precision
        appliedCopay = roundDouble(appliedCopay);

        // Set the computed copayment on the activity object
        $act.setCopayment(appliedCopay);

        // Add an outcome message to the activity for auditing/tracking purposes
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // If logging is enabled on the claim, log the details of the copayment change
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the CoPayment's claimTotal by adding the new copayment amount
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the activity and copayment objects in the working memory to reflect the changes
        update($act);
        update($coPayment);
    } else {
        // If the ceiling is not valid, calculate the copayment without considering a ceiling cap
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the computed copayment on the activity
        $act.setCopayment(appliedCopay);

        // Add an outcome message to record this change on the activity
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the copayment update if logging is enabled on the claim
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity object in the working memory
        update($act);
    }
end

rule 'COPAY_DENTAL'
// Use MVEL dialect for this rule
dialect "mvel"

// Set the rule's salience (priority) to -2100 (lower priority)
salience -2100

when
    // Match any Claim object; no conditions are applied to Claim itself.
    $c: Claim()
    
    // Extract the ClaimType from the claim and ensure it is Dental.
    ClaimType(type == ClaimType.Dental) from $c.claimType
    
    // Match a CoPayment object for Dental that has a positive value.
    // Capture the ceiling and the current claimTotal from the CoPayment.
    $coPayment: CoPayment(
        type == "Dental", 
        value > 0, 
$value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )
    
    // Match an Activity that:
    // - has a non-null, positive, and numeric gross value,
    // - does not yet have a copayment assigned,
    // - and its order status is either "cm" or "completed" (case-insensitive).
    $act: Activity(
        gross != null, 
        gross > 0,$gross:gross, 
        !gross.isNaN(), 
        copayment == null, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
  //$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Retrieve the current rule's name for logging and outcome tracking.
    String sRuleName = drools.getRule().getName();
    
    // Check if a valid ceiling is set (not null, not NaN, and greater than zero).
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on the activity's gross and deductible.
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        
        // Determine what the claim total would be after applying the copayment.
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // If the new claim total would exceed the ceiling, cap the copayment.
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            // Ensure appliedCopay is a positive value.
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // Otherwise, use the computed copayment value.
            appliedCopay = value;
        }
        
        // Round the final applied copayment to the desired precision.
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the computed copayment value on the Activity.
        $act.setCopayment(appliedCopay);
        
        // Log an outcome on the Activity to record the applied copayment.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Optionally log detailed information if logging is enabled on the claim.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the CoPayment's claimTotal with the new copayment amount.
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify the rule engine of the changes to Activity and CoPayment.
        update($act);
        update($coPayment);
    } else {
        // If no valid ceiling is provided, calculate the copayment without ceiling constraints.
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));
        
        // Set the computed copayment on the Activity.
        $act.setCopayment(appliedCopay);
        
        // Log an outcome on the Activity for tracking.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Optionally log detailed information if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Notify the rule engine that the Activity has been updated.
        update($act);
    }
end

rule 'COPAY_HCPCS_ENAYA'
// Specify the MVEL dialect for this rule
dialect "mvel"

// Set the salience (priority) of this rule to -3100
salience -3100

when
    // Match any Claim object and assign it to $c
    $c: Claim()
    
    // Match a Contract object from the Claim's contract field
    // Ensure that packageName is not null and, when converted to lowercase,
    // it contains the substring "enaya"
    Contract(packageName != null, packageName.toLowerCase() matches ".*enaya.*") from $c.contract
    
    // Match an Activity object with the following conditions:
    // - Type is HCPCS (using CodeType.HCPCS)
    // - Gross is provided, greater than 0, and a valid number (not NaN)
    // - Copayment is not yet set (copayment == null)
    // - Order status exists and is either "cm" or "completed" (case-insensitive)
    $act: Activity(
        type == CodeType.HCPCS,
        gross != null,
        gross > 0,$gross:gross,
        !gross.isNaN(),
        copayment == null,
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" ||
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
 
then
    // Retrieve the current rule's name for logging and outcome messages
    String sRuleName = drools.getRule().getName();
    
    // If logging is enabled on the claim, log an empty message or placeholder.
    if ($c.logInfo) {
        logInfo(sRuleName, "");
    }
    
    // Set the copayment on the activity to a fixed value of 20.0
    $act.setCopayment(20.0d);
    
    // Add an outcome to the activity to document that the copayment was set
    $act.addOutcome(Severity.INFO, sRuleName, " Set copaymentto 20.", "");
    
    // Notify the engine that the activity has been modified
    update($act);
end

rule 'COPAY_IN_PATIENT'
// The rule uses the MVEL dialect
dialect "mvel"

// Set rule priority to -2450
salience -2450

when
    // Match a Claim object
    $c: Claim()
    
    // Extract an Encounter from the claim where the type is between 3 and 6
    Encounter($encType: type, type >= 3 && type <= 6) from $c.encounter
    
    // Match a CoPayment object where:
    // - Type is "In Patient"
    // - The value is greater than 0
    // - Capture ceiling and claimTotal values for calculations
    $coPayment: CoPayment(
        type == "In Patient", 
        value > 0, $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )
    
    // Match an Activity object where:
    // - It has a non-null, positive gross value
    // - It does not already have a copayment applied
    // - Order status is either "cm" or "completed"
    $act: Activity(
        gross != null, 
        gross > 0, 
        !gross.isNaN(), 
        copayment == null, 
        $gross: gross, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
	

then
    // Retrieve the rule name for logging
    String sRuleName = drools.getRule().getName();

    // Check if a valid copayment ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        
        // Calculate the future total copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // Ensure copayment does not exceed ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }
        
        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the calculated copayment in the activity
        $act.setCopayment(appliedCopay);
        
        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify rule engine that objects have changed
        update($act);
        update($coPayment);
    } else {
        // No ceiling, apply copayment directly
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));
        
        // Set the copayment
        $act.setCopayment(appliedCopay);
        
        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Notify rule engine that the activity object has changed
        update($act);
    }
end

rule 'COPAY_CPT_OUT_PATIENT_PHYSIOTHERAPY'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -2550

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object (no specific conditions)
    $c: Claim()

    // Ensure the Encounter type is less than 3 or greater than 6
    Encounter(type < 3 || type > 6) from $c.encounter

    // Find a CoPayment object where:
    // - type is "Physiotherapy"
    // - value is greater than 0
    // - Capture ceiling and claimTotal values
    $coPayment: CoPayment(
        type == "Physiotherapy", value > 0,$value:value,
        $ceiling: ceiling, $claimTotal: claimTotal
    )

    // Find an Activity object where:
    // - type is CPT
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - OrderStatus is "cm" or "completed"
    // - Capture activityGroup
    $act: Activity(
        type == CodeType.CPT,
        gross != null, gross > 0, !gross.isNaN(),$gross:gross,
        copayment == null,
        $groups: activityGroup,
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Ensure the ActivityGroup is of type CPT and name is "Physical Medicine & Rehabilitation"
    ActivityGroup(
        type == CodeType.CPT.getValue(),
        name == "Physical Medicine & Rehabilitation"
    ) from $groups

	//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 

then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }
end

rule 'COPAY_CPT_SPECIALIST'
// Use MVEL dialect for this rule.
dialect "mvel"

// Set the rule's salience (priority) to -3000 (lower priority).
salience -3000

when
    // Match a Claim object and capture the providerID.
    $c: Claim($providerID: providerID)
    
    // Match a CoPayment object for "Specialist" with a positive value.
    // Capture the ceiling and current claimTotal.
    $coPayment: CoPayment(
        type == "Specialist", 
        value > 0, 
        $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )
    
    // Match an Activity object with the following conditions:
    // - Activity type is CPT.
    // - Gross must be non-null, greater than 0, and a valid number (not NaN).
    // - No copayment has been set yet.
    // - Capture the activity group in $groups and the clinician.
    // - The clinician field must NOT match the patterns "GN.*", "GP.*", "T.*", or "GT.*".
    // - The order status is not null and is either "cm" or "completed" (case insensitive).
    $act: Activity(
        type == CodeType.CPT, 
        gross != null, 
        gross > 0, 
$gross:gross,
        !gross.isNaN(), 
        copayment == null, 
        $groups: activityGroup, 
        $clinician: clinician,
        clinician not matches "GN.*",
        clinician not matches "GP.*",
        clinician not matches "T.*",
        clinician not matches "GT.*",
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
    
    // Ensure that one of the ActivityGroup objects within the captured groups has:
    // - a type equal to CodeType.CPT.getValue() and
    // - a name equal to "Evaluation And Management".
    ActivityGroup(
        type == CodeType.CPT.getValue(), 
        name == "Evaluation And Management"
    ) from $groups;
    
    // Match a Clinician object associated with the claim:
    // - facility_license must equal the providerID from the claim.
    // - license must match the clinician from the activity.
    // - The clinician's category (converted to lowercase) must not match:
    //     * ".*medical practitioner.*"
    //     * ".*general practitioner.*"
    //     * After removing dots and converting to lowercase, must not match ".*gp.*"
    Clinician(
        facility_license == $providerID, 
        license == $clinician, 
        category.toLowerCase() not matches ".*medical practitioner.*", 
        category.toLowerCase() not matches ".*general practitioner.*", 
        category.replace('.', '').toLowerCase() not matches ".*gp.*"
    )
  //$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Retrieve the current rule's name for logging and outcome tracking.
    String sRuleName = drools.getRule().getName();
    
    // Check if a valid ceiling exists (not null, not NaN, and greater than 0).
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the provisional copayment value based on the activity's gross and deductible.
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        
        // Calculate what the future claim total would be after adding the computed copayment.
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // If the new claim total exceeds the ceiling, cap the copayment.
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            // Ensure the applied copayment is positive.
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // Otherwise, use the computed value as the applied copayment.
            appliedCopay = value;
        }
        
        // Round the final applied copayment to the desired precision.
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the calculated copayment on the activity.
        $act.setCopayment(appliedCopay);
        
        // Record an outcome on the activity, noting the applied copayment.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log the event if logging is enabled on the claim.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the CoPayment's claimTotal by adding the applied copayment.
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify the rule engine that the activity and copayment objects have been modified.
        update($act);
        update($coPayment);
    } else {
        // If no valid ceiling is provided, calculate the copayment without ceiling constraints.
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));
        
        // Set the computed copayment on the activity.
        $act.setCopayment(appliedCopay);
        
        // Record the outcome on the activity.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log the event if logging is enabled on the claim.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Notify the rule engine that the activity has been updated.
        update($act);
    }
end

rule 'COPAY_CPT_RADIOLOGY'
// Specify the MVEL dialect for this rule
dialect "mvel"

// Set the rule's salience (priority) to -2800 (low priority)
salience -2800

when
    // Match a Claim object.
    $c: Claim()
    
    // Match a CoPayment object for Radiology with a positive value.
    // Also capture the ceiling and current claimTotal from the CoPayment.
    $coPayment: CoPayment(
        type == "Radiology", 
        value > 0, $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )
    
    // Match an Activity object that meets all the following conditions:
    // - The activity type must be CPT.
    // - Gross must be provided, greater than 0, and not NaN.
    // - No copayment has been set yet (copayment == null).
    // - Capture the activityGroup for later use.
    // - The order status is not null and is either "cm" or "completed" (case insensitive).
    $act: Activity(
        type == CodeType.CPT, 
        gross != null, 
        gross > 0, $gross:gross,
        !gross.isNaN(), 
        copayment == null, 
        $groups: activityGroup, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
    
    // Ensure that one of the ActivityGroup objects from the captured groups
    // matches the following:
    // - type equals the CPT code type value.
    // - name equals "Radiology".
    ActivityGroup(
        type == CodeType.CPT.getValue(), 
        name == "Radiology"
    ) from $groups;
  //$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 

then
    // Retrieve the name of this rule for logging and outcome tracking.
    String sRuleName = drools.getRule().getName();
    
    // If a valid ceiling exists (not null, not NaN, and greater than 0),
    // then calculate the copayment accordingly.
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on the activity's gross and deductible.
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        
        // Calculate the future claim total after adding the computed copayment.
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // If the future total exceeds the ceiling, cap the copayment to the remaining amount.
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            // Ensure that appliedCopay is positive.
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // Otherwise, use the computed value directly.
            appliedCopay = value;
        }
        
        // Round the applied copayment to the desired precision.
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the computed copayment on the activity.
        $act.setCopayment(appliedCopay);
        
        // Record an outcome on the activity for traceability.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // If logging is enabled on the claim, log the information.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the claim's total copayment by adding the applied copayment.
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify the rule engine that the activity and copayment objects have been updated.
        update($act);
        update($coPayment);
    } else {
        // If no valid ceiling is provided, compute the copayment without ceiling constraints.
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));
        
        // Set the computed copayment on the activity.
        $act.setCopayment(appliedCopay);
        
        // Record an outcome for the activity.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log the action if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity as its state has changed.
        update($act);
    }
end

rule 'COPAY_CPT_OUT_PATIENT_NOT_EM_JBILL1282'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -2400

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object (no specific conditions)
    $c: Claim()

    // Ensure the Encounter type is less than 3 or greater than 6
    Encounter($encType: type, type < 3 || type > 6) from $c.encounter

    // Find a CoPayment object where:
    // - type is "Outpatient excluding Consultation"
    // - value is greater than 0
    // - Capture ceiling and claimTotal values
    $coPayment: CoPayment(
        type == "Outpatient excluding Consultation", value > 0,$value:value,
        $ceiling: ceiling, $claimTotal: claimTotal
    )

    // Find an Activity object where:
    // - code is not null and has a length greater than 0
    // - code does not fall within specific consultation code ranges
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - OrderStatus is "cm" or "completed"
    $act: Activity(
        code != null,
        code.trim().length() > 0,
        eval(!(
            (code.compareToIgnoreCase("99201") >= 0 && code.compareToIgnoreCase("99205") <= 0) ||
            (code.compareToIgnoreCase("99212") >= 0 && code.compareToIgnoreCase("99215") <= 0) ||
            (code.compareToIgnoreCase("99281") >= 0 && code.compareToIgnoreCase("99285") <= 0) ||
            (code.compareToIgnoreCase("92002") >= 0 && code.compareToIgnoreCase("92014") <= 0)
        )),
        gross != null, gross > 0, !gross.isNaN(),
        copayment == null, $gross: gross,
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Ensure the ActivityGroup is not of type SERVICE with name "Consultations"
    not(ActivityGroup(
        type.intValue() == CodeType.SERVICE.getValue(),
        name == "Consultations"
    ) from $act.activityGroup)

//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }

end

rule 'COPAY_CPT_OUT_PATIENT_EXCLUDING_DME_JBILL1292'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -3150

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object (no specific conditions)
    $c: Claim()

    // Ensure the Encounter type is 1 or 2
    Encounter(type in (1, 2)) from $c.encounter

    // Find a CoPayment object where:
    // - type is "Outpatient excluding DME"
    // - value is greater than 0
    // - Capture ceiling and claimTotal values
    $coPayment: CoPayment(
        type == "Outpatient excluding DME", value > 0,$value:value,
        $ceiling: ceiling, $claimTotal: claimTotal
    )

    // Find an Activity object where:
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - OrderStatus is "cm" or "completed"
    $act: Activity(
        gross != null, gross > 0, !gross.isNaN(),$gross:gross,
        copayment == null,
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }
end

rule 'COPAY_CPT_OUTPATIENT_EXCLUDING_PHARMACY_JBILL1292'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -3200

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object (no specific conditions)
    $c: Claim()

    // Ensure the Encounter type is 1 or 2
    Encounter(type in (1, 2)) from $c.encounter

    // Find a CoPayment object where:
    // - type is "Outpatient excluding Pharmacy"
    // - value is greater than 0
    // - Capture ceiling and claimTotal values
    $coPayment: CoPayment(
        type == "Outpatient excluding Pharmacy", value > 0,$value:value,
        $ceiling: ceiling, $claimTotal: claimTotal
    )

    // Find an Activity object where:
    // - type is not TRADE_DRUG
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - OrderStatus is "cm" or "completed"
    // - Capture activityGroup
    $act: Activity(
        type != CodeType.TRADE_DRUG,
        gross != null, gross > 0, !gross.isNaN(),$gross:gross,
        copayment == null,
        $groups: activityGroup,
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 

then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }

end

rule 'COPAY_SERVICES_Consultation'
// Define the dialect to use MVEL for rule execution
dialect "mvel"

// Rule priority: -2350
salience -2350

when
    // Match any Claim object
    $c: Claim()

    // Match a CoPayment object with the specified conditions (type is "Consultation")
    $coPayment: CoPayment(
        type == "Consultation", 
        value > 0, 
        $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )

    // Match an Activity of type "SERVICE" with specified conditions
    $act: Activity(
        type == CodeType.SERVICE, 
        gross != null, gross > 0, !gross.isNaN(), copayment == null, 
        $gross: gross,
        $act.getOrderStatus() != null && 
        ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Match an ActivityGroup of type "SERVICE" and name "Consultations"
    ActivityGroup(
        type.intValue() == CodeType.SERVICE.getValue(), 
        name == "Consultations"
    ) from $act.activityGroup

     //$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Rule name for logging
    String sRuleName = drools.getRule().getName();

    // If a ceiling is defined and valid, apply ceiling logic to the co-payment calculation
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the co-payment value based on gross amount and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Apply the ceiling if the future co-payment exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        appliedCopay = roundDouble(appliedCopay);

        // Set the co-payment for the activity and log outcome
        $act.setCopayment(appliedCopay);
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied co-payment for auditing
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the co-payment claim total and activity
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        update($act);
        update($coPayment);
    } else {
        // If no ceiling, simply apply the co-payment value
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the co-payment for the activity and log outcome
        $act.setCopayment(appliedCopay);
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied co-payment for auditing
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity
        update($act);
    }

end

rule 'COPAY_SERVICES_Specialist'
// Use MVEL as the dialect for this rule
dialect "mvel"

// Set rule priority to -2250 (lower priority than other rules)
salience -2250

when
    // Match a Claim object (no specific conditions on the claim, just that it exists)
    $c: Claim()

    // Match a CoPayment object where:
    // - Type is "Specialist"
    // - The value is greater than 0
    // - Capture ceiling and claimTotal for future calculations
    $coPayment: CoPayment(
        type == "Specialist", 
        value > 0, $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )

    // Match an Activity object where:
    // - Type is `SERVICE` and code is "10"
    // - Gross value is greater than 0, is not null, and is not NaN
    // - No copayment is already set
    // - Order status is either "cm" or "completed"
    $act: Activity(
        type == CodeType.SERVICE, 
        code == "10", 
        gross != null, 
        gross > 0,
        !gross.isNaN(), 
        copayment == null, 
        $gross: gross, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )

//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
	
then
    // Retrieve the rule name for logging purposes
    String sRuleName = drools.getRule().getName();

    // Check if a valid ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        
        // Calculate the total future copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Ensure copayment does not exceed ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);

        // Set the calculated copayment on the activity
        $act.setCopayment(appliedCopay);

        // Add outcome for logging
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Notify Drools that objects have changed
        update($act);
        update($coPayment);
    } else {
        // If no ceiling exists, apply the full copayment value
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment
        $act.setCopayment(appliedCopay);

        // Add outcome for logging
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Notify Drools that the activity has changed
        update($act);
    }
end

rule 'COPAY_SERVICES_GENERAL_PRACTITIONER'
// Define the dialect to use MVEL for rule execution
dialect "mvel"

// Rule priority: -2200
salience -2200

when
    // Match any Claim object
    $c: Claim()

    // Match a CoPayment object with the specified conditions (type is "General Practitioner" or "Medical Practitioner")
    $coPayment: CoPayment(
        type in ("General Practitioner", "Medical Practitioner"), 
        value > 0, $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )

    // Match an Activity of type "SERVICE" with the specified conditions
    $act: Activity(
        type == CodeType.SERVICE, 
        code == "9", 
        gross != null, 
        gross > 0, 
        !gross.isNaN(), 
        copayment == null, 
        $gross: gross,
        $act.getOrderStatus() != null && 
        ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
	
then
    // Rule name for logging
    String sRuleName = drools.getRule().getName();

    // If a ceiling is defined and valid, apply ceiling logic to the co-payment calculation
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the co-payment value based on gross amount and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Apply the ceiling if the future co-payment exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        appliedCopay = roundDouble(appliedCopay);

        // Set the co-payment for the activity and log outcome
        $act.setCopayment(appliedCopay);
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied co-payment for auditing
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the co-payment claim total and activity
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        update($act);
        update($coPayment);
    } else {
        // If no ceiling, simply apply the co-payment value
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the co-payment for the activity and log outcome
        $act.setCopayment(appliedCopay);
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied co-payment for auditing
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
          }
        

        // Update the activity
        update($act);
    }
end

rule 'COPAY_OUT_PATIENT'
// Define the dialect to use MVEL for rule execution
dialect "mvel"

// Rule priority: -2500 (lower priority than other rules)
salience -2500

when
    // Match a Claim object (no specific conditions on the claim)
    $c: Claim()

    // Match an Encounter object where the type is either below 3 or above 6
    Encounter($encType: type, type < 3 || type > 6) from $c.encounter

    // Match a CoPayment object where:
    // - Type is "Out Patient"
    // - Value is greater than 0
    // - Capture ceiling and claimTotal for future calculations
    $coPayment: CoPayment(
        type == "Out Patient", 
        value > 0, $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )

    // Match an Activity object where:
    // - Gross value is greater than 0, not null, and not NaN
    // - No copayment is already set
    // - Order status is either "cm" or "completed"
    $act: Activity(
        gross != null, 
        gross > 0, 
        !gross.isNaN(), 
        copayment == null, 
        $gross: gross, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
     //   $maxGross: Double() from accumulate(
	//   $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
     //   Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
     //   $countOfActs:count($code))
	// eval($countOfActs < 1 && $maxGross == $gross) 
	
then
    // Get the rule name for logging purposes
    String sRuleName = drools.getRule().getName();

    // Check if a valid ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        
        // Calculate the total future copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Ensure the copayment does not exceed the ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment for the activity
        $act.setCopayment(appliedCopay);

        // Add outcome for logging purposes
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment details
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Notify Drools that objects have changed
        update($act);
        update($coPayment);
    } else {
        // If no ceiling exists, apply the full copayment value
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment for the activity
        $act.setCopayment(appliedCopay);

        // Add outcome for logging purposes
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment details
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Notify Drools that the activity has changed
        update($act);
    }
end

rule 'COPAY_PHARMACY'
// Use MVEL as the dialect for this rule
dialect "mvel"

// Set rule priority to -2150 (lower priority than other rules)
salience -2150

when
    // Match a Claim object (no specific conditions on the claim, just that it exists)
    $c: Claim()

    // Match a CoPayment object where:
    // - Type is "Pharmacy"
    // - The value is greater than 0
    // - Capture ceiling and claimTotal for future calculations
    $coPayment: CoPayment(
        type == "Pharmacy", 
        value > 0, $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )

    // Match an Activity object where:
    // - Type is `TRADE_DRUG`
    // - Gross value is greater than 0, is not null, and is not NaN
    // - No copayment is already set
    // - Order status is either "cm" or "completed"
    $act: Activity(
        type == CodeType.TRADE_DRUG, 
        gross != null, 
        gross > 0,
        !gross.isNaN(), 
        copayment == null, 
        $gross: gross, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
	
then
    // Retrieve the rule name for logging purposes
    String sRuleName = drools.getRule().getName();

    // Check if a valid ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        
        // Calculate the total future copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Ensure copayment does not exceed ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);

        // Set the calculated copayment on the activity
        $act.setCopayment(appliedCopay);

        // Add outcome for logging
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Notify Drools that objects have changed
        update($act);
        update($coPayment);
    } else {
        // If no ceiling exists, apply the full copayment value
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment
        $act.setCopayment(appliedCopay);

        // Add outcome for logging
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Notify Drools that the activity has changed
        update($act);
    }

end

rule 'COPAY_SERVICES_Consultant'
// Define the dialect to use MVEL for rule execution
dialect "mvel"

// Rule priority: -2300
salience -2300

when
    // Match any Claim object
    $c: Claim()

    // Match a CoPayment object with type "Consultant" and value greater than 0
    $coPayment: CoPayment(
        type == "Consultant", 
        $value:value,
        value > 0, 
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )

    // Match an Activity of type "SERVICE" with specified conditions
    $act: Activity(
        type == CodeType.SERVICE, 
        code == "11", 
        gross != null, 
        gross > 0, 
        !gross.isNaN(), 
        copayment == null, 
        $gross: gross,
        $act.getOrderStatus() != null && 
        ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

     //$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
	
then
    // Rule name for logging
    String sRuleName = drools.getRule().getName();

    // If a ceiling is defined and valid, apply ceiling logic to the co-payment calculation
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the co-payment value based on gross amount and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Apply the ceiling if the future co-payment exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        appliedCopay = roundDouble(appliedCopay);

        // Set the co-payment for the activity and log outcome
        $act.setCopayment(appliedCopay);
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied co-payment for auditing
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the co-payment claim total and activity
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        update($act);
        update($coPayment);
    } else {
        // If no ceiling, simply apply the co-payment value
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the co-payment for the activity and log outcome
        $act.setCopayment(appliedCopay);
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied co-payment for auditing
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity
        update($act);
    }
end

rule 'COPAY_OPTICAL'
// Use MVEL as the dialect for this rule
dialect "mvel"

// Set rule priority to -2650
salience -2650

when
    // Match a Claim object
    $c: Claim()
    
    // Ensure the claim type is "Optical"
    ClaimType(type == ClaimType.Optical) from $c.claimType

    // Match a CoPayment object where:
    // - Type is "Optical"
    // - The value is greater than 0
    // - Capture ceiling and claimTotal values for calculations
    $coPayment: CoPayment(
        type == "Optical", 
        value > 0, $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )

    // Match an Activity object where:
    // - Type is CPT or HCPCS
    // - It has a non-null, positive gross value
    // - It does not already have a copayment assigned
    // - Order status is either "cm" or "completed"
    $act: Activity(
        (type == CodeType.CPT || type == CodeType.HCPCS), 
        gross != null, 
        gross > 0, $gross:gross,
        !gross.isNaN(), 
        copayment == null, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Retrieve the rule name for logging
    String sRuleName = drools.getRule().getName();

    // Check if a valid copayment ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        
        // Calculate the future total copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // Ensure copayment does not exceed ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }
        
        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the calculated copayment in the activity
        $act.setCopayment(appliedCopay);
        
        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify rule engine that objects have changed
        update($act);
        update($coPayment);
    } else {
        // No ceiling, apply copayment directly
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment
        $act.setCopayment(appliedCopay);

        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Notify rule engine that the activity object has changed
        update($act);
    }
end

rule 'COPAY_MATERNITY'
// Use MVEL as the dialect for this rule
dialect "mvel"

// Set rule priority to -2600
salience -2600

when
    // Match a Claim object
    $c: Claim()
    
    // Ensure the claim type is "Maternity"
    ClaimType(type == ClaimType.Maternity) from $c.claimType

    // Match a CoPayment object where:
    // - Type is "Maternity"
    // - The value is greater than 0
    // - Capture ceiling and claimTotal values for calculations
    $coPayment: CoPayment(
        type == "Maternity", 
        value > 0, $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )

    // Match an Activity object where:
    // - It has a non-null, positive gross value
    // - It does not already have a copayment assigned
    // - Order status is either "cm" or "completed"
    $act: Activity(
        gross != null, 
        gross > 0, $gross:gross,
        !gross.isNaN(), 
        copayment == null, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross)  
then
    // Retrieve the rule name for logging
    String sRuleName = drools.getRule().getName();

    // Check if a valid copayment ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment based on gross and deductible
        double value = $coPayment.getValue($act.getGross(), $act.getDeductible());
        
        // Calculate the future total copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // Ensure copayment does not exceed ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }
        
        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the calculated copayment in the activity
        $act.setCopayment(appliedCopay);
        
        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify rule engine that objects have changed
        update($act);
        update($coPayment);
    } else {
        // No ceiling, apply copayment directly
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGross(), $act.getDeductible()));

        // Set the copayment
        $act.setCopayment(appliedCopay);

        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Notify rule engine that the activity object has changed
        update($act);
    }
end

rule 'CUS_SET_MULTI_PROC'
dialect 'mvel'
salience -101

when
    // Fetch the Claim object where CUS_ID is not null and multipleProcedure is null, 
    // and primary, secondary, third, and forth procedures are also null
    $c: Claim($CUS_ID: CUS_ID, CUS_ID != null, multipleProcedures == null, 
        primaryProc == null, secondaryProc == null, thirdProc == null, forthProc == null)
    
    // Fetch the Encounter object with start date
    Encounter($encStart: start) from $c.encounter
    
    // Fetch the CusContract object where ID matches CUS_ID and multipleProcedure is set to 1,
    // and at least one procedure (primary, secondary, third, or forth) is not null or greater than 0
    CusContract(ID.intValue() == $CUS_ID.intValue(), multipleProcedure == 1,
        (primaryProcedure != null && primaryProcedure > 0) ||
        (secondaryProcedure != null && secondaryProcedure > 0) ||
        (thirdProcedure != null && thirdProcedure > 0) ||
        (forthProcedure != null && forthProcedure > 0),
        $primaryProcedure: primaryProcedure,
        $secondaryProcedure: secondaryProcedure,
        $thirdProcedure: thirdProcedure,
        $forthProcedure: forthProcedure)
    
then
    // If logging is enabled, log the information that multiple procedures are enabled in the claim
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), "enable multiple procedures in claim");
    }

    // Set the multipleProcedures flag to 1, indicating that multiple procedures are allowed in this claim
    $c.setMultipleProcedures(1);

    // Set the procedure values only if they are not null or greater than 0
    // Set primary procedure if it is valid
    $c.setPrimaryProc($primaryProcedure != null && $primaryProcedure > 0 ? $primaryProcedure : null);
    
    // Set secondary procedure if it is valid
    $c.setSecondaryProc($secondaryProcedure != null && $secondaryProcedure > 0 ? $secondaryProcedure : null);
    
    // Set third procedure if it is valid
    $c.setThirdProc($thirdProcedure != null && $thirdProcedure > 0 ? $thirdProcedure : null);
    
    // Set forth procedure if it is valid
    $c.setForthProc($forthProcedure != null && $forthProcedure > 0 ? $forthProcedure : null);
    
    // Add outcome message indicating that multiple procedures have been enabled in the claim
    $c.addOutcome(Severity.INFO, drools.getRule().getName(),
        "enable multiple procedures in claim", "");
    
    // Update the Claim object with the new procedure values
    update($c);
end

rule 'DEDUCTIBLE_CPT_CONSULTATION'
dialect 'mvel'
salience -1250

when
    // Match Claim without any specific conditions
    $c: Claim()
    
    // Match Deductible of type "Consultation" or "Consultant" with value greater than 0
    $deductible: Deductible(type in ("Consultation", "Consultant"), value > 0, $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match Activity of type CPT with gross value and no deductible applied
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, $groups: activityGroup, 
                   clinician not matches "GN.*",
                   clinician not matches "GP.*",
                   clinician not matches "T.*",
                   clinician not matches "GT.*", 
                   $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match ActivityGroup related to "Evaluation And Management"
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Evaluation And Management") from $groups;
    
    // Calculate maximum gross value
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    )
    
    // Count the number of applied Deductibles of the same type
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), $countOfActs: count($code))
    
    // Ensure the rule only fires if this activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Rule logic starts here
    String sRuleName = drools.getRule().getName();
    
    // If ceiling is defined and valid
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        
        // Set the deductible for the activity
        $act.setDeductible(appliedDeductible);
        
        // Add an outcome to the activity
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        // Log the deductible change if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the deductible's claim total
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // No ceiling: use default deductible value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure deductible does not exceed the gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Add to claim total if applicable
        $claimTotal = $claimTotal + appliedDeductible;
        
        // If the claim total exceeds the value, set deductible to 0
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        // Set the deductible for the activity
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        
        // Add an outcome to the activity
        $act.addOutcome(Severity.INFO, sRuleName, 
                        " Set deductible to " + appliedDeductible + 
                        ". max gross=" + $maxGross + ". gross :" + $gross + " countOfActs: " + $countOfActs + " claimTotal: " + $claimTotal, "");
        
        // Log the deductible change if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the new deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_CPT_DAMAN_BASIC_GP_J170'
dialect 'mvel'
salience -800

when
    // Match a Claim with provider ID
    $c: Claim($providerID: providerID)
    
    // Match Contract with package name containing "daman basic" (case-insensitive)
    Contract(packageName != null, packageName.toLowerCase() matches ".*daman basic.*") from $c.contract
    
    // Match Activity of type CPT with valid gross value and no existing deductible
    $act: Activity(type == CodeType.CPT, gross != null, gross > 0, !gross.isNaN(), deductible == null, 
                   $groups: activityGroup, $clinician: clinician, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match Activity Group with name "Evaluation And Management" for CPT activities
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Evaluation And Management") from $groups;
    
    // Match Clinician with specified provider license and profession
    Clinician(facility_license == $providerID, license == $clinician,  
              profession.toLowerCase() matches ".*medical practitioner.*" || 
              profession.toLowerCase() matches ".*general practitioner.*");

then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If log info is enabled, log the action
    if ($c.logInfo) {
        logInfo(sRuleName, " Set deductible to 20 For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
    }
    
    // Set the deductible for the activity to 20
    $act.setDeductible(20.0d);
    
    // Add an outcome indicating the deductible was set
    $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to 20.", "");
    
    // Update the activity
    update($act);
end

rule 'CUS_DISCOUNT_OP'
// Define the dialect as MVEL for rule execution  
dialect "mvel"

// Rule priority: -250 (executes after higher-priority rules)
salience -250  

when  
    // Match a Claim where:
    // - CUS_ID is not null  
    $c: Claim($CUS_ID: CUS_ID, CUS_ID != null)  

    // Match an Encounter where:
    // - The **type is NOT inpatient DRG-based (5 or 6)**
    // - The **type is NOT below 3** (valid outpatient case)  
    Encounter($encType: type, type < 3 || type > 6) from $c.encounter  

    // Match a CusContract associated with the claims CUS_ID  
    CusContract(ID.intValue() == $CUS_ID.intValue(), $OP_DISCOUNT: OP_DISCOUNT)  

    // Match an eligible **Activity** where:
    // - The **type is NOT** TRADE_DRUG, HCPCS, or DENTAL  
    // - The **code is extracted**  
    // - The **list price is not null or NaN**  
    // - The **discount is currently null** (indicating it needs discounting)  
    // - The **quantity is extracted**  
    $act: Activity(
        type != CodeType.TRADE_DRUG,  
        type != CodeType.HCPCS,  
        type != CodeType.DENTAL,  
        $code: code,  
        list != null,  
        !list.isNaN(),  
        discount == null,  
        $list: list,  
        $quantity: quantity  
    )  

then  
    //================ Discount Calculation ================  

    // Ensure OP_DISCOUNT is non-negative  
    Double opDiscount = ($OP_DISCOUNT == null || $OP_DISCOUNT < 0) ? 0.0d : $OP_DISCOUNT;  

    // Logging  
    if ($c.logInfo) {  
        logInfo(drools.getRule().getName(),  
            "Apply discount=" + opDiscount +  
            " to Activity ID=" + $act.getIdCaller() +  
            " code=" + $act.getCode());  
    }  

    // Set Discount Percentage  
    $act.setDiscountPercentage(opDiscount);  

    // Calculate the discount amount  
    Double discountAmount = roundDouble(
        (($list / 100) * $act.getDiscountPercentage()) *  
        ($quantity == null || $quantity.isNaN() || $quantity < 0 ? 1 : $quantity)
    );  

    // Apply the calculated discount  
    $act.setDiscount(discountAmount.isNaN() ? 0 : discountAmount);  

    // Add an informational outcome  
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),  
        "Apply discount=" + opDiscount, "");  

    // Update the activity in working memory  
    update($act); 
end

rule 'DEDUCTIBLE_CPT_DIAGNOSTIC'
dialect 'mvel'
salience -1400

when
    // Match a Claim (no additional conditions)
    $c: Claim()
    
    // Match Encounter type not in the range [3, 6]
    Encounter(type < 3 || type > 6) from $c.encounter
    
    // Match Deductible for "Diagnostic" type with value greater than 0
    $deductible: Deductible(type == "Diagnostic", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match Activity with a gross value, no existing deductible, and valid order status
    $act: Activity(type == CodeType.CPT, deductible == null, $groups: activityGroup, 
                   hasDoubleValue(gross), $gross: gross, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match Activity Group of type "CPT" and name "DGTest_CPT_9_Series"
    ActivityGroup(type == CodeType.CPT.getValue(), name == "DGTest_CPT_9_Series") from $groups;
    
    // Calculate maximum gross value from all activities with no deductible
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    )
    
    // Count the number of activities with the same deductible value
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), $countOfActs: count($code))
    
    // Ensure the rule only fires if this activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Get the rule name
    String sRuleName = drools.getRule().getName();

    // If ceiling value is available, apply deductible considering the ceiling
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        
        // Set the deductible for the activity and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the deductible and claim totals
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling value is available, apply deductible based on the gross value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure deductible doesn't exceed the gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Update the claim total and check if the deductible should be applied
        $claimTotal = $claimTotal + appliedDeductible;
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        // Set the deductible for the activity and log the action
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, 
                        " Set deductible to " + appliedDeductible +  
                        ". max gross=" + $maxGross + ". gross: " + $gross + 
                        " countOfActs: " + $countOfActs + " claimTotal: " + $claimTotal, "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the new deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_CPT_RADIOLOGY'
dialect 'mvel' // Specifies the dialect being used by Drools (MVEL in this case)

salience -1150 // Defines the priority of the rule, where negative values mean lower priority

when
    // Match a Claim object
    $c: Claim()

    // Match a Deductible of type "Radiology" with a value greater than 0
    $deductible: Deductible(type == "Radiology", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)

    // Match an Activity of type CPT with a valid gross value and no existing deductible
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))

    // Ensure that the Activity is part of the "Radiology" group
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Radiology") from $groups;

    // Calculate the maximum gross value from all Activities with no deductible in the "Radiology" group
    $maxGross: Double() from accumulate(
       $a: Activity(hasDoubleValue(gross), deductible == null), 
       max($a.gross)
    )

    // Count the number of Activities that have the same deductible value applied
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
               $countOfActs: count($code))

    // Ensure that the rule only fires if this Activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Get the name of the rule for logging purposes
    String sRuleName = drools.getRule().getName();

    // If a ceiling value exists, apply a ceiling-based deduction
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        // Process the deductible using the ceiling value
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);

        // Set the deductible on the activity and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log the action if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claim total with the applied deductible
        $deductible.setClaimTotal($claimTotal + appliedDeductible);

        // Update the activity and deductible objects
        update($act);
        update($deductible);
    } else {
        // If no ceiling value exists, apply the deductible based on the value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value); // Round the deductible value

        // Ensure the applied deductible does not exceed the gross value of the activity
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Update the claim total by adding the applied deductible
        $claimTotal = $claimTotal + appliedDeductible;

        // If the claim total exceeds the deductible value, reset the deductible to 0
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }

        // Update the deductible on the activity and the claim total
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);

        // Log the action with detailed information
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ". max gross=" + $maxGross + ". gross: " + $gross + " countOfActs: " + $countOfActs + " claimTotal:" + $claimTotal, "");

        // Log the action if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity with the applied deductible
        update($act);
    }

end

rule 'DEDUCTIBLE_CPT_SPECIALIST'
dialect 'mvel' // Specifies that the rule uses the MVEL dialect.

salience -1350 // Sets the rule priority to -1350, which determines when it will be fired (lower values mean higher priority).

when
    // Match a Claim object and capture the provider ID.
    $c: Claim($providerID: providerID)

    // Match a Deductible with type "Specialist" and value greater than 0. Capture ceiling, claim total, and deductible value.
    $deductible: Deductible(type in ("Specialist"), value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)

    // Match an Activity with type "CPT", a gross value, no deductible, and other conditions.
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, $clinician: clinician,
                   clinician not matches "GN.*",  // Exclude clinicians whose names start with "GN"
                   clinician not matches "GP.*",  // Exclude clinicians whose names start with "GP"
                   clinician not matches "T.*",   // Exclude clinicians whose names start with "T"
                   clinician not matches "GT.*",  // Exclude clinicians whose names start with "GT"
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))

    // Ensure the Activity belongs to the "Evaluation And Management" group.
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Evaluation And Management") from $groups;

    // Match a Clinician associated with the provider ID, with conditions on category and license.
    Clinician(facility_license == $providerID, license == $clinician, 
              category.toLowerCase() not matches ".*consultant.*" && 
              category.toLowerCase() not matches '.*medical practitioner.*' && 
              category.toLowerCase() not matches '.*general practitioner.*' && 
              category.replace('.', '').toLowerCase() not matches ".*gp.*");

    // Calculate the maximum gross value from all Activities with no deductible.
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    );

    // Count the number of Activities with the same deductible value applied.
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
               $countOfActs: count($code));

    // Ensure the rule only fires if the Activity group hasn't been processed yet and the gross value matches.
    eval($countOfActs < 1 && $maxGross == $gross);

then
    // Get the name of the rule for logging.
    String sRuleName = drools.getRule().getName();

    // If a ceiling value exists, process it with the ceiling.
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);  // Apply the ceiling rule logic.

        // Set the deductible on the activity and log the action.
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log the action if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the deductible and claim total with the applied deductible.
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act); // Update the activity with the new deductible.
        update($deductible); // Update the deductible with the new claim total.
    } else {
        // If no ceiling value exists, apply the deductible based on the provided value.
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);  // Round the deductible value.

        // Ensure that the deductible doesn't exceed the gross value of the activity.
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Update the claim total with the applied deductible.
        $claimTotal = $claimTotal + appliedDeductible;

        // If the claim total exceeds the deductible value, reset the deductible to 0.
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }

        // Set the deductible on the activity and log the action with details.
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible +  
                        ". max gross=" + $maxGross + ". gross: " + $gross + " countOfActs: " + $countOfActs + 
                        " claimTotal: " + $claimTotal, "");

        // Log the action if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity with the applied deductible.
        update($act);
    }
end

rule 'DEDUCTIBLE_CPT_OUT_PATIENT_PHYSIOTHERAPY_JBILL1292'
dialect 'mvel' // Specifies that the rule uses the MVEL dialect.

salience -900 // Sets the rule priority to -900, determining when it will be fired (lower values mean higher priority).

when
    // Match a Claim object that has a non-null patient.
    $c: Claim(patient != null)

    // Match an Encounter from the Claim where the type is less than 3 or greater than 6.
    Encounter(type < 3 || type > 6) from $c.encounter

    // Match a Deductible of type "Physiotherapy" with a value greater than 0. Capture ceiling, claim total, and deductible value.
    $deductible: Deductible(type == "Physiotherapy", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)

    // Match an Activity with type "CPT", a gross value, no deductible, and specific conditions for order status.
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))

    // Ensure the Activity belongs to the "Physical Medicine & Rehabilitation" group.
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Physical Medicine & Rehabilitation") from $groups;

    // Calculate the maximum gross value among all Activities without a deductible.
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    );

    // Count how many Activities have the same deductible applied.
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
               $countOfActs: count($code));

    // Ensure the rule only fires if the Activity group hasn't been processed yet and the gross value matches.
    eval($countOfActs < 1 && $maxGross == $gross);

then
    // Get the name of the rule for logging.
    String sRuleName = drools.getRule().getName();

    // If a ceiling value exists, apply it using the processWithCeiling function.
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);  // Apply the ceiling rule logic.

        // Set the deductible on the Activity and log the action.
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log the action if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Deductible and ClaimTotal with the applied deductible.
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act); // Update the Activity with the new deductible.
        update($deductible); // Update the Deductible with the new claim total.
    } else {
        // If no ceiling value exists, apply the deductible based on the value.
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);  // Round the deductible value.

        // Ensure that the deductible does not exceed the gross value of the activity.
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Update the claim total with the applied deductible.
        $claimTotal = $claimTotal + appliedDeductible;

        // If the claim total exceeds the deductible value, reset the deductible to 0.
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }

        // Set the deductible on the Activity and log the action with details.
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible +  
                        ". max gross=" + $maxGross + ". gross: " + $gross + " countOfActs: " + $countOfActs + 
                        " claimTotal: " + $claimTotal, "");

        // Log the action if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity with the applied deductible.
        update($act);
    }
end

rule 'DEDUCTIBLE_CPT_OUTPATIENT_EXCLUDING_PHARMACY_JBILL1292'
dialect 'mvel'
salience -1500

when
    // Match a Claim
    $c: Claim()
    
    // Match an Encounter with type 1 or 2
    Encounter(type in (1, 2)) from $c.encounter
    
    // Match a Deductible of type "Outpatient excluding Pharmacy" with value greater than 0
    $deductible: Deductible(type == "Outpatient excluding Pharmacy", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match an Activity that is not of type TRADE_DRUG, has valid gross value, and no existing deductible
    $act: Activity(type != CodeType.TRADE_DRUG, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Calculate the maximum gross value across all activities with no deductible applied
    $maxGross: Double() from accumulate(
       $a: Activity(hasDoubleValue(gross), deductible == null),
       max($a.gross)
    )
    
    // Count the number of activities with the same deductible value
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
               $countOfActs: count($code))

    // Ensure this rule only fires if the activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If ceiling exists and is valid, apply ceiling-based deduction
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        // If logging is enabled, log the action
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling, apply a simple deductible based on the value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure the deductible does not exceed the gross value of the activity
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Adjust claim total and set the deductible if it exceeds the claim value
        $claimTotal = $claimTotal + appliedDeductible;
        
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, 
            " Set deductible to " + appliedDeductible + ". max gross=" + $maxGross + 
            ". gross: " + $gross + " countOfActs: " + $countOfActs + " claimTotal:" + $claimTotal, "");
        
        // If logging is enabled, log the action
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible +
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the applied deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_CPT_MRI'
dialect 'mvel'
salience -1100
when
    // The Claim object is available with any patient information
    $c: Claim()

    // Extract deductible details related to "MRI" from Deductible object
    $deductible: Deductible(type == "MRI", value > 0, 
        $ceiling: ceiling, $claimTotal: claimTotal, $value: value) 

    // Activity condition with type CodeType.CPT and checks for gross value
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, 
        $groups: activityGroup, 
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    // Match the activity group of type "CPT" and name "Radiology"
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Radiology") from $groups;

    // Corrected accumulate statement:
    // This accumulates the maximum gross value across all Activities
    $maxGross: Double() from accumulate(
        // Accumulate all activities with deductible null and gross value present
        $a: Activity(hasDoubleValue(gross), deductible == null), 
        // Get the maximum gross value from all matched activities
        max($a.gross)
    )
    
    // Accumulate count of Activities that have the same deductible value applied
    accumulate(
        // Count the activities with the same deductible value
        Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
        // Store count of such activities in $countOfActs
        $countOfActs: count($code)
    )

    // Ensure we only fire if this activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross) 

then
    // Rule name for logging purposes
    String sRuleName = drools.getRule().getName();
    
    // Case 1: If there is a ceiling value for the deductible
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate future deductible total and decide if it exceeds the ceiling
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible; // Ensure deductible is positive
        } else {
            appliedDeductible = $value;
        }

        // Round and set the deductible value
        appliedDeductible = roundDouble(appliedDeductible);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log detailed info if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the deductible total
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // Case 2: Standard Deductible Calculation (No Ceiling)
        double appliedDeductible = 0.0d;
        // Round the deductible value and ensure it's not greater than the gross
        appliedDeductible = roundDouble($value);
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Set the calculated deductible
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log the applied deductible if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity with the new deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_CPT_OUT_PATIENT_EXCLUDING_DME_JBILL1292'
dialect 'mvel'
salience -1450

when
    // Match a Claim
    $c: Claim()
    
    // Match an Encounter with type 1 or 2
    Encounter(type in (1, 2)) from $c.encounter
    
    // Match a Deductible of type "Outpatient excluding DME" with value greater than 0
    $deductible: Deductible(type == "Outpatient excluding DME", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match an Activity with valid gross value and no existing deductible
    $act: Activity(hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Calculate the maximum gross value across all activities with no deductible applied
    $maxGross: Double() from accumulate(
       $a: Activity(hasDoubleValue(gross), deductible == null),
       max($a.gross)
    )
    
    // Count the number of activities with the same deductible value
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
               $countOfActs: count($code))

    // Ensure this rule only fires if the activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If ceiling exists and is valid, apply ceiling-based deduction
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        // If logging is enabled, log the action
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling, apply a simple deductible based on the value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure the deductible does not exceed the gross value of the activity
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Adjust claim total and set the deductible if it exceeds the claim value
        $claimTotal = $claimTotal + appliedDeductible;
        
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, 
            " Set deductible to " + appliedDeductible + ". max gross=" + $maxGross + 
            ". gross: " + $gross + " countOfActs: " + $countOfActs + " claimTotal:" + $claimTotal, "");
        
        // If logging is enabled, log the action
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible +
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the applied deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_CPT_LABORATORY'
dialect 'mvel'
salience -1200

when
    // Match a Claim
    $c: Claim()

    // Match a Deductible of type "Laboratory" or "Labarotary" with value greater than 0
    $deductible: Deductible(type in ("Laboratory", "Labarotary"), value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)

    // Match an Activity of type CPT with valid gross value, no deductible, and the correct order status
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))

    // Ensure the Activity is part of the "Pathology & Laboratory" group
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Pathology & Laboratory") from $groups;

    // Calculate the maximum gross value across all activities in the "Pathology & Laboratory" group
    $maxGross: Double() from accumulate(
       $a: Activity(hasDoubleValue(gross), deductible == null),
       max($a.gross)
    )

    // Count the number of activities with the same deductible value applied
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
               $countOfActs: count($code))

    // Ensure the rule only fires if this activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Get the rule name
    String sRuleName = drools.getRule().getName();

    // If a ceiling value is present, apply a ceiling-based deduction
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);

        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // If logging is enabled, log the action
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling value, apply a simple deductible based on the value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);

        // Ensure the deductible does not exceed the gross value of the activity
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Adjust the claim total and set the deductible
        $claimTotal = $claimTotal + appliedDeductible;

        // If the claim total exceeds the deductible value, reset the deductible to 0
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }

        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, 
            " Set deductible to " + appliedDeductible + ". max gross=" + $maxGross + 
            ". gross: " + $gross + " countOfActs: " + $countOfActs + " claimTotal:" + $claimTotal, "");

        // If logging is enabled, log the action
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity with the applied deductible
        update($act);
    }

end

rule 'DEDUCTIBLE_CPT_DAMAN_BASIC_SPECIALIST_J170'
dialect 'mvel'
salience -850

when
    // Match a Claim with a provider ID
    $c: Claim($providerID: providerID)
    
    // Match Contract for a package name containing "daman basic"
    Contract(packageName != null, packageName.toLowerCase() matches ".*daman basic.*") from $c.contract
    
    // Match Activity with CPT type, gross value, no existing deductible, and certain conditions on clinician and order status
    $act: Activity(type == CodeType.CPT, gross != null, gross > 0, !gross.isNaN(), deductible == null, 
                   $groups: activityGroup, $clinician: clinician, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match Activity Group with CPT type and name "Evaluation And Management"
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Evaluation And Management") from $groups;
    
    // Match Clinician with facility license matching provider ID and not being a "Medical Practitioner" or "General Practitioner"
    Clinician(facility_license == $providerID, license == $clinician, 
              profession.toLowerCase() not matches ".*medical practitioner.*", 
              profession.toLowerCase() not matches ".*general practitioner.*");
    
then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If log info is enabled, log the action
    if ($c.logInfo) {
        logInfo(sRuleName, " Set deductible to 10 For Activity=" + $act.getIdCaller() + 
                " code=" + $act.getCode());
    }
    
    // Set a fixed deductible of 10
    $act.setDeductible(10.0d);
    
    // Add an outcome indicating the deductible was set
    $act.addOutcome(Severity.INFO, drools.getRule().getName(), " Set deductible to 10.", "");
    
    // Update the activity with the new deductible
    update($act);
end

rule 'CUS_DISCOUNT_PHARMACY'
// Define the dialect as MVEL for rule execution  
dialect "mvel"

// Rule priority: -210 (executes after higher-priority rules)
salience -210

when
    // Match a Claim object where CUS_ID is not null  
    $c: Claim($CUS_ID: CUS_ID, CUS_ID != null)  

    // Match a CusContract linked to the Claims CUS_ID  
    CusContract(ID.intValue() == $CUS_ID.intValue(), $PHARM_DISCOUNT: PHARM_DISCOUNT)  

    // Match an Activity that:  
    // - Is of type TRADE_DRUG  
    // - Has a valid `list` price (not null or NaN)  
    // - Does not already have a discount applied  
    $act: Activity(
        type == CodeType.TRADE_DRUG, 
        $code: code, 
        list != null,  
        !list.isNaN(), 
        discount == null,  
        $list: list, 
        $quantity: quantity
    )  
then
    // Ensure PHARM_DISCOUNT is a valid number; default to 0.0 if null or negative  
    Double pharmDiscount = ($PHARM_DISCOUNT == null || $PHARM_DISCOUNT < 0) ? 0.0d : $PHARM_DISCOUNT;  

    // Logging for debugging  
    if ($c.logInfo) {  
        logInfo(drools.getRule().getName(),  
            " Apply discount=" + pharmDiscount +  
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());  
    }  

    // Set discount percentage  
    $act.setDiscountPercentage(pharmDiscount);  

    // Calculate the discount amount using:  
    // - `(list / 100) * discountPercentage * quantity`  
    // - Default quantity to `1` if it's null, NaN, or negative  
    $act.setDiscount(
        $act.getDiscountPercentage().isNaN() ?  
            0 :  
            roundDouble((($list / 100) * $act.getDiscountPercentage()) *  
                ($quantity == null || $quantity.isNaN() || $quantity < 0 ? 1 : $quantity))
    );  

    // Add an outcome message to the activity  
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),  
        " Apply discount=" + pharmDiscount, "");  

    // Update the modified activity in working memory  
    update($act); 
end

rule 'DEDUCTIBLE_CPT_GENERAL_PRACTITIONER'
dialect 'mvel'
salience -1300

when
    // Match a Claim with provider ID
    $c: Claim($providerID: providerID)
    
    // Match Deductible for "General Practitioner" or "GP" type with value > 0
    $deductible: Deductible(type in ("General Practitioner", "GP"), value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match Activity of type CodeType.CPT with gross value, no existing deductible, and valid clinician
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, $clinician: clinician, 
                   $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match ActivityGroup for CodeType.CPT with name "Evaluation And Management"
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Evaluation And Management") from $groups;
    
    // Match Clinician based on provider ID and category, excluding consultants
    Clinician(facility_license == $providerID, license == $clinician, 
              category.toLowerCase() not matches ".*consultant.*" && (
              category.toLowerCase() matches '.*medical practitioner.*' ||
              category.toLowerCase() matches '.*general practitioner.*' ||
              category.replace('.','').toLowerCase() matches ".*gp.*"));
    
    // Calculate the maximum gross value from activities with no existing deductible
    $maxGross: Double() from accumulate(
       $a: Activity(hasDoubleValue(gross), deductible == null),
       max($a.gross)
    )
    
    // Count the number of activities with the same deductible value
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), $countOfActs: count($code))
    
    // Ensure we only fire if this activity group hasn't been processed yet and max gross matches current gross
    eval($countOfActs < 1 && $maxGross == $gross);
    
then
    // Get the rule name
    String sRuleName = drools.getRule().getName();

    // If ceiling exists, apply the deductible considering the ceiling value
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        
        // Set the deductible for the activity and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the deductible and claim totals
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling exists, apply deductible based on the gross value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure the deductible doesn't exceed the gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Update the claim total and check if the deductible should be applied
        $claimTotal = $claimTotal + appliedDeductible;
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        // Set the deductible for the activity and log the action
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, 
                        " Set deductible to " + appliedDeductible + ". max gross=" + $maxGross + 
                        ". gross: " + $gross + " countOfActs: " + $countOfActs + " claimTotal: " + $claimTotal, "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the new deductible
        update($act);
    }
end

rule 'CUS_DISCOUNT_IP'
// Define the dialect as MVEL for rule execution  
dialect "mvel"

// Rule priority: -230 (executes after higher-priority rules)
salience -230

when
    // Match a Claim object where CUS_ID is not null  
    $c: Claim($CUS_ID: CUS_ID, CUS_ID != null)  

    // Match an Encounter with type between 3 and 6  
    Encounter($encType: type, type >= 3 && type <= 6) from $c.encounter  

    // Match a CusContract linked to the Claims CUS_ID  
    CusContract(ID.intValue() == $CUS_ID.intValue(), $IP_DISCOUNT: IP_DISCOUNT)  

    // Match an Activity that:  
    // - Is NOT of type TRADE_DRUG or HCPCS  
    // - Has a valid `list` price (not null or NaN)  
    // - Does not already have a discount applied  
    $act: Activity(
        type != CodeType.TRADE_DRUG, 
        type != CodeType.HCPCS, 
        $code: code, 
        list != null,  
        !list.isNaN(), 
        discount == null, 
        $quantity: quantity, 
        $list: list
    )  
then
    // Ensure IP_DISCOUNT is a valid number; default to 0.0 if null or negative  
    Double ipDiscount = ($IP_DISCOUNT == null || $IP_DISCOUNT < 0) ? 0.0d : $IP_DISCOUNT;  

    // Logging for debugging  
    if ($c.logInfo) {  
        logInfo(drools.getRule().getName(),  
            " Apply discount=" + ipDiscount +  
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());  
    }  

    // Set discount percentage  
    $act.setDiscountPercentage(ipDiscount);  

    // Calculate the discount amount using:  
    // - `(list / 100) * discountPercentage * quantity`  
    // - Default quantity to `1` if it's null, NaN, or negative  
    $act.setDiscount(
        $act.getDiscountPercentage().isNaN() ?  
            0 :  
            roundDouble((($list / 100) * $act.getDiscountPercentage()) *  
                ($quantity == null || $quantity.isNaN() || $quantity < 0 ? 1 : $quantity))
    );  

    // Add an outcome message to the activity  
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),  
        " Apply discount=" + ipDiscount, "");  

    // Update the modified activity in working memory  
    update($act);
end

rule 'DEDUCTIBLE_OP_DAMAN_BASIC_RAD'
dialect 'mvel'
salience -561
when
//JIRA PRICE-195
	$c:Claim(patient != null, providerID !="MF1992", $patient:patient)
	Encounter($encType:type, type<3 || type>6) from $c.encounter
	Contract(packageName!=null,packageName.toLowerCase() matches ".*daman basic.*") from $c.contract
	$act:Activity(type==CodeType.CPT, gross != null, gross>0, !gross.isNaN(), deductible == null, 
	$gross:gross, $groups:activityGroup, 
$act.getOrderStatus()!=null && ($act.getOrderStatus().toLowerCase()=="cm" || $act.getOrderStatus().toLowerCase()=="completed"))
	ActivityGroup( type==CodeType.CPT.getValue(), name=="Radiology") from $groups ;
	$RADtotalDed: Number() from accumulate ( 
	    $act_act: Activity( type==CodeType.CPT, deductible != null, $act_groups:activityGroup, 			$deductible:deductible) 
    	and
	    ActivityGroup( type==CodeType.CPT.getValue(), name=="Radiology") from $act_groups ;
	    sum($deductible)
	)
		
	
then
	String sRuleName = drools.getRule().getName();
	double appliedDeductible = 10d-$RADtotalDed;
	if(appliedDeductible>=$gross){
		appliedDeductible = $gross;
	}
	$act.setDeductible(appliedDeductible);
	$act.addOutcome(Severity.INFO, sRuleName ,
        	" Set deductible to " + appliedDeductible + " totalDeductibles for LABS "+$RADtotalDed+".", "");
	
	if($c.logInfo){logInfo(sRuleName," Set deductible to " + appliedDeductible 
		+ " totalDeductibles for LABS "+$RADtotalDed+"." +
		" For Activity="+$act.getIdCaller()+" code="+$act.getCode());
	}
update($act);

end

rule 'DEDUCTIBLE_PHARMACY'
dialect 'mvel'                         // Use the MVEL dialect for expressions.
salience -630                          // Set the rule's priority (lower number = lower priority).

when
    // Match a Claim that has a non-null patient.
	$c:Claim(patient != null)
	
    // Match a Deductible of type "Pharmacy" where:
    // - The deductible value is greater than 0.
    // - Bind its ceiling to $ceiling, current claim total to $claimTotal, and deductible value to $value.
	$deductible:Deductible(type=="Pharmacy", value>0, 
		$ceiling:ceiling, $claimTotal:claimTotal, $value:value)
		
    // Match an Activity where:
    // - The type is TRADE_DRUG.
    // - It has a valid (double) gross value, which is bound to $gross.
    // - The deductible is not already applied (deductible == null).
    // - The activity order status is not null and equals "cm" or "completed" (case-insensitive).
	$act : Activity(type==CodeType.TRADE_DRUG, hasDoubleValue(gross), deductible == null, 
		$gross:gross, 
		$act.getOrderStatus()!=null && 
            ($act.getOrderStatus().toLowerCase()=="cm" || $act.getOrderStatus().toLowerCase()=="completed")
	)

then
    // Get the name of the current rule for logging purposes.
	String sRuleName = drools.getRule().getName();

    // Check if a valid ceiling exists:
    // - Ceiling must not be null, must be a number (not NaN), and must be greater than 0.
    if($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the future total deductible if the current deductible value is added.
		double futureDeductibleTotal = $claimTotal + $value;
		double appliedDeductible = 0.0d;
		
        // If adding the new deductible would exceed the ceiling:
		if (futureDeductibleTotal > $ceiling) {
            // Calculate the maximum deductible that can be applied without breaching the ceiling.
			appliedDeductible = $ceiling - $claimTotal;
            // If the result is negative (should not happen), convert it to a positive value.
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
		} else {
            // Otherwise, the full deductible value can be applied.
			appliedDeductible = $value;
		}
		
        // Round the applied deductible to ensure correct precision.
		appliedDeductible = roundDouble(appliedDeductible);
		
        // Set the calculated deductible on the Activity.
		$act.setDeductible(appliedDeductible);
		
        // Add an outcome record to the Activity with details of the applied deductible.
		$act.addOutcome(Severity.INFO, sRuleName,
        	" Set deductible to " + appliedDeductible + ".", "");
		
        // Log the action if logging is enabled on the Claim.
		if($c.logInfo){
		    logInfo(sRuleName, " Set deductible to " + appliedDeductible +
			    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
		}
		
        // Update the Deductible's claim total by adding the applied deductible.
		$deductible.setClaimTotal($claimTotal + appliedDeductible);
		
        // Update the Activity and Deductible objects in the working memory.
		update($act);
		update($deductible);
	} else {
        // If no valid ceiling exists:
		double appliedDeductible = 0.0d;
		
        // Round the base deductible value.
		appliedDeductible = roundDouble($value);
		
        // Ensure the applied deductible does not exceed the activity's gross value.
		if (appliedDeductible > $gross) {
			appliedDeductible = $gross;
		}
		
        // Set the calculated deductible on the Activity.
		$act.setDeductible(appliedDeductible);
		
        // Add an outcome record indicating the applied deductible.
		$act.addOutcome(Severity.INFO, sRuleName,
        	" Set deductible to " + appliedDeductible + ".", "");
		
        // Log the action if logging is enabled.
		if($c.logInfo){
		    logInfo(sRuleName, " Set deductible to " + appliedDeductible +
			    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
		}
		
        // Update the Activity object in the working memory.
		update($act);
	}
end

rule 'DEDUCTIBLE_OUT_PATIENT'
dialect 'mvel' // Specifies that the rule uses the MVEL dialect.

salience -610 // Sets the priority of the rule to -610 for ordering.

when
    // Match a Claim where the patient is not null.
    $c: Claim(patient != null, $patient: patient)
    
    // Match an Encounter with type less than 3 or greater than 6.
    Encounter($encType: type, type < 3 || type > 6) from $c.encounter
    
    // Match a Deductible of type "Out Patient" where the deductible value is greater than 0.
    $deductible: Deductible(type == "Out Patient", value > 0, $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match an Activity where a valid gross value is present, deductible is null, and the order status is either "cm" or "completed".
    $act: Activity(hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Calculate the maximum gross value from all matching activities.
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    )
    
    // Count the number of activities where the deductible is equal to the specified value.
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), $countOfActs: count($code))
    
    // Ensure the rule only fires if the activity group has not been processed yet and the maximum gross is equal to the gross value of the activity.
    eval($countOfActs < 1 && $maxGross == $gross)
    
then
    // Get the rule name for logging and outcome messages.
    String sRuleName = drools.getRule().getName();

    // If the ceiling value is valid (not null or NaN), process the deductible with the ceiling.
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        
        // Call processWithCeiling function to calculate the deductible considering the ceiling.
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        
        // Set the deductible on the activity.
        $act.setDeductible(appliedDeductible);
        
        // Add an outcome to the activity.
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        // Log the deductible being set if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the claim total with the applied deductible.
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        
        // Update the activity and deductible objects.
        update($act);
        update($deductible);
    } else {
        // If the ceiling is not available, apply the deductible based on the given value.
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure the applied deductible does not exceed the gross value.
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Update the claim total with the applied deductible.
        $claimTotal = $claimTotal + appliedDeductible;
        
        // If the claim total exceeds the deductible value, reset the deductible to 0.
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        // Set the deductible and log the outcome.
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        
        // Add outcome and log information.
        $act.addOutcome(Severity.INFO, sRuleName, 
            " Set deductible to " + appliedDeductible + ". max gross=" + $maxGross + ". gross: " + $gross + 
            " countOfActs: " + $countOfActs + " claimTotal: " + $claimTotal, "");
        
        // Log the deductible applied if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the new deductible.
        update($act);
    }
end

rule 'DEDUCTIBLE_SERVICES_Consultant'
dialect 'mvel'  
// Specifies that the rule uses the MVEL dialect for expressions.
salience -660   
// Sets the rule's priority (salience); a lower number means lower priority.

when
    // Check for a valid Claim with a non-null patient.
	$c:Claim(patient != null)	
	
	// Retrieve a Deductible object where:
	// - type is "Consultant"
	// - the deductible value is greater than 0.
	// Also, bind its ceiling, current claim total, and deductible value.
	$deductible:Deductible(type =="Consultant", value>0, 
		$ceiling:ceiling, $claimTotal:claimTotal, $value:value) 
	
	// Retrieve an Activity object where:
	// - type is SERVICE,
	// - code equals "11",
	// - it has a double value for gross,
	// - the deductible has not yet been applied (deductible == null),
	// - and the order status is not null and equals (case-insensitively) "cm" or "completed".
	$act : Activity(type==CodeType.SERVICE, code=="11", hasDoubleValue(gross), deductible == null, 
		$gross:gross, 
		$act.getOrderStatus()!=null && ($act.getOrderStatus().toLowerCase()=="cm" || $act.getOrderStatus().toLowerCase()=="completed"))
	
	// Calculate the maximum gross value among all Activities with a gross value and no deductible applied.
	$maxGross: Double() from accumulate(
	   $a:Activity(hasDoubleValue(gross), deductible == null),
	   max($a.gross)  // Finds the highest gross value.
	)
	
	// Count the number of Activities that have already had the same deductible value applied.
    accumulate(
        Activity(hasDoubleValue(deductible), deductible==$value, $code:code),
        $countOfActs:count($code)
    )
    
	// Ensure that the rule fires only if:
	// - No activities with the same deductible have been processed yet ($countOfActs < 1)
	// - The current activity's gross equals the maximum gross from the group ($maxGross == $gross)
	eval($countOfActs < 1 && $maxGross == $gross) 
	
then
	// Get the current rule's name for logging purposes.
	String sRuleName = drools.getRule().getName();
	
	// Check if there is a ceiling value specified.
	if(hasDoubleValue($ceiling)){
	    double appliedDeductible = 0.0d;
	    
	    // Calculate the applied deductible using the provided ceiling, claim total, and deductible value.
	    appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
	    
	    // Set the calculated deductible on the Activity.
	    $act.setDeductible(appliedDeductible);
	    
	    // Record the outcome with a message including the applied deductible.
	    $act.addOutcome(Severity.INFO, sRuleName,
	        " Set deductible to " + appliedDeductible + ".", "");
	    
	    // Log detailed information if logging is enabled on the Claim.
	    if($c.logInfo){
	        logInfo(sRuleName, " Set deductible to " + appliedDeductible +
		        " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
	    }
	    
	    // Update the Deductible object with the new claim total (original claim total plus applied deductible).
	    $deductible.setClaimTotal($claimTotal + appliedDeductible);
	    
	    // Update the Activity and Deductible objects in the working memory.
	    update($act);
	    update($deductible);
	    
	} else {
	    double appliedDeductible = 0.0d;
	    
	    // If no ceiling is provided, round the deductible value.
	    appliedDeductible = roundDouble($value);
	    
	    // Ensure that the applied deductible does not exceed the gross value.
	    if (appliedDeductible > $gross){
	        appliedDeductible = $gross;
	    }
	    
	    // Update the claim total with the applied deductible.
	    $claimTotal = $claimTotal + appliedDeductible;
	    
	    // If the updated claim total exceeds the deductible value, reset the applied deductible to zero.
	    if ($claimTotal > $value){
	        appliedDeductible = 0.0d;
	    }
	    
	    // Update the Deductible object with the new claim total.
	    $deductible.setClaimTotal($claimTotal);
	    
	    // Set the applied deductible on the Activity.
	    $act.setDeductible(appliedDeductible);
	    
	    // Record the outcome including detailed debug information.
	    $act.addOutcome(Severity.INFO, sRuleName,
	        " Set deductible to " + appliedDeductible +
	        ". max gross=" + $maxGross + ". gross :" + $gross +
	        " countOfActs: " + $countOfActs + " claimTotal:" + $claimTotal, "");
	    
	    // Log detailed information if logging is enabled.
	    if($c.logInfo){
	        logInfo(sRuleName, " Set deductible to " + appliedDeductible +
		        " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
	    }
	    
	    // Update the Activity object in the working memory.
	    update($act);
}
end

rule 'DEDUCTIBLE_OP_DAMAN_BASIC_LAB'
dialect 'mvel' // Specifies that the rule uses the MVEL dialect.

salience -560 // Sets the rule priority to -560, determining the rule firing order.

when
    // Match a Claim where the patient is not null and the provider is not "MF1992".
    $c: Claim(patient != null, providerID != "MF1992", $patient: patient)
    
    // Match an Encounter where the type is less than 3 or greater than 6.
    Encounter($encType: type, type < 3 || type > 6) from $c.encounter
    
    // Match a Contract where the packageName contains "daman basic" (case-insensitive).
    Contract(packageName != null, packageName.toLowerCase() matches ".*daman basic.*") from $c.contract
    
    // Match an Activity with type "CPT", where the gross amount is non-null, greater than 0, 
    // not NaN, and deductible is null. The order status must be either "cm" or "completed".
    $act: Activity(type == CodeType.CPT, gross != null, gross > 0, !gross.isNaN(), deductible == null, 
                   $gross: gross, $groups: activityGroup, 
                   $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match an ActivityGroup with type "CPT" and name "Pathology & Laboratory".
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Pathology & Laboratory") from $groups;
    
    // Calculate the sum of deductibles for all Activities in the "Pathology & Laboratory" group.
    $LABtotalDed: Number() from accumulate(
        $act_act: Activity(type == CodeType.CPT, deductible != null, $act_groups: activityGroup, $deductible: deductible) 
        and
        ActivityGroup(type == CodeType.CPT.getValue(), name == "Pathology & Laboratory") from $act_groups;
        sum($deductible)
    )

then
    // Get the rule name to use in the logging and outcome messages.
    String sRuleName = drools.getRule().getName();

    // Calculate the applied deductible by subtracting the total LAB deductible from 10.
    double appliedDeductible = 10.0d - $LABtotalDed;

    // Ensure the applied deductible does not exceed the gross amount.
    if (appliedDeductible >= $gross) {
        appliedDeductible = $gross;
    }

    // Set the calculated deductible on the Activity.
    $act.setDeductible(appliedDeductible);

    // Add an outcome to record the deductible that was set.
    $act.addOutcome(Severity.INFO, sRuleName, 
        " Set deductible to " + appliedDeductible + " totalDeductibles for LABS " + $LABtotalDed + ".", "");

    // If logging is enabled, log the information about the deductible being set.
    if ($c.logInfo) {
        logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                " totalDeductibles for LABS " + $LABtotalDed + 
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Update the Activity to persist the changes made to the deductible.
    update($act);
end

rule 'DEDUCTIBLE_OPTICAL'
dialect 'mvel' // Specifies that the rule uses the MVEL dialect.

salience -1000 // Sets the rule priority to -1000, determining the rule firing order.

when
    // Match a Claim object.
    $c: Claim()

    // Ensure the Claim has an "Optical" claim type.
    ClaimType(type == ClaimType.Optical) from $c.claimType

    // Match a Deductible of type "Optical" with value greater than 0.
    // Capture ceiling, claim total, and deductible value.
    $deductible: Deductible(type == "Optical", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)

    // Match an Activity with type either "CPT" or "HCPCS" having a gross value and no existing deductible,
    // and ensure the order status is either "cm" or "completed".
    $act: Activity(type == CodeType.CPT || type == CodeType.HCPCS, hasDoubleValue(gross), 
                   $gross: gross, deductible == null, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))

    // Calculate the maximum gross value from all activities with no deductible.
    $maxGross: Double() from accumulate(
       $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    )

    // Count the number of activities that have the same deductible value.
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
               $countOfActs: count($code))

    // Ensure we only fire if this activity group hasn't been processed yet (i.e., count of activities is less than 1).
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Get the rule name for logging purposes.
    String sRuleName = drools.getRule().getName();

    // If a ceiling exists and is valid, apply ceiling logic.
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the future deductible total by adding the current deductible value to the claim total.
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;

        // If the future total exceeds the ceiling, adjust the deductible to fit within the ceiling.
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            // Otherwise, apply the full deductible value.
            appliedDeductible = $value;
        }

        // Round the deductible to the appropriate precision.
        appliedDeductible = roundDouble(appliedDeductible);

        // Set the calculated deductible on the activity and log the outcome.
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // If logging is enabled, log the applied deductible.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the deductible claim total with the applied deductible.
        $deductible.setClaimTotal($claimTotal + appliedDeductible);

        // Apply updates to the activity and deductible.
        update($act);
        update($deductible);

    } else {
        // If no ceiling is provided, apply the deductible based on the value.
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value); // Round the deductible value.

        // Ensure the deductible doesn't exceed the gross value of the Activity.
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Set the calculated deductible on the activity and log the outcome.
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // If logging is enabled, log the applied deductible.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Apply updates to the activity.
        update($act);
    }

end

rule 'DEDUCTIBLE_MATERNITY'
dialect 'mvel'
salience -950

when
    // Match a Claim with a non-null patient and non-empty activity list
    $c: Claim(patient != null, activity != null && !activity.isEmpty())
    
    // Match the ClaimType with "Maternity"
    ClaimType(type == ClaimType.Maternity) from $c.claimType
    
    // Match Deductible for "Maternity" type with value greater than 0
    $deductible: Deductible(type == "Maternity", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match Activity with gross value and no existing deductible
    $act: Activity(hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Calculate maximum gross value from all activities with no deductible
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    )
    
    // Count the number of activities with the same deductible value
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), $countOfActs: count($code))
    
    // Ensure the rule only fires if this activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Get the rule name
    String sRuleName = drools.getRule().getName();

    // If ceiling value is available, apply deductible considering the ceiling
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        
        // Set the deductible for the activity and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the deductible and claim totals
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling value is available, apply deductible based on the gross value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure deductible doesn't exceed the gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Update the claim total and check if the deductible should be applied
        $claimTotal = $claimTotal + appliedDeductible;
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        // Set the deductible for the activity and log the action
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, 
                        " Set deductible to " + appliedDeductible +  
                        ". max gross=" + $maxGross + ". gross: " + $gross + 
                        " countOfActs: " + $countOfActs + " claimTotal: " + $claimTotal, "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the new deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_IN_PATIENT'
dialect 'mvel'
salience -600

when
    // Matching a Claim with an Encounter of type 3 to 6
    $c: Claim()
    Encounter($encType: type, type >= 3 && type <= 6) from $c.encounter
    
    // Matching Deductible for "In Patient" type with a positive value
    $deductible: Deductible(type == "In Patient", value > 0, $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Matching Activity with valid gross value, deductible is null, and order status is "cm" or "completed"
    $act: Activity(hasDoubleValue(gross), $gross: gross, deductible == null, $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Calculate maximum gross value
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    )
    
    // Count of applied Deductible of the same type
    accumulate(
        Activity(hasDoubleValue(deductible), deductible == $value, $code: code),
        $countOfActs: count($code)
    )
    
    // Ensure the rule fires only if this activity hasn't been processed yet and the max gross matches the gross
    eval($countOfActs < 1 && $maxGross == $gross)
    
then
    // Rule name for logging
    String sRuleName = drools.getRule().getName();
    
    // If the ceiling value exists
    if (hasDoubleValue($ceiling)) {
        // Apply deductible based on ceiling
        double appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        $act.setDeductible(appliedDeductible);
        
        // Log outcome
        $act.addOutcome(Severity.INFO, sRuleName, "Set deductible to " + appliedDeductible + ".", "");
        
        // Log detailed information
        if ($c.logInfo) {
            logInfo(sRuleName, "Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update deductible and claim total
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // Apply deductible without ceiling
        double appliedDeductible = roundDouble($value);
        
        // Ensure deductible is not greater than the gross amount
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Update claim total and check if deductible needs to be reset
        $claimTotal = $claimTotal + appliedDeductible;
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        // Update deductible and log outcome
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        
        // Log outcome
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set deductible to " + appliedDeductible + ". max gross=" + $maxGross + ". gross: " + $gross + " countOfActs: " + $countOfActs + " claimTotal: " + $claimTotal,
            "");
        
        // Log detailed information
        if ($c.logInfo) {
            logInfo(sRuleName, "Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update activity
        update($act);
    }

end

rule 'DEDUCTIBLE_DENTAL'
// Define the dialect as MVEL for rule execution  
dialect "mvel"

// Rule priority: -620 (executes after higher-priority rules)  
salience -620  

when  
    // Match a Claim where:
    // - Patient is not null  
    // - There is at least one activity  
    $c: Claim(patient != null, activity != null && !activity.isEmpty(), $patient: patient)  

    // Ensure the claim type is "Dental"
    ClaimType(type == ClaimType.Dental) from $c.claimType  

    // Ensure the patient has valid insurance  
    Patient(patientInsurance != null, $patientInsurance: patientInsurance) from $patient  

    // Match a Deductible where:
    // - Type is "Dental"
    // - Value is greater than 0  
    // - Extract ceiling, claim total, and deductible value  
    $deductible: Deductible(type == "Dental", value > 0,  
        $ceiling: ceiling, $claimTotal: claimTotal, $value: value)  

    // Match an eligible **Activity** where:
    // - The **gross amount** is valid  
    // - The **deductible is null** (not yet processed)  
    // - The **order status is "CM" (Claimed) or "Completed"**  
    $act: Activity(hasDoubleValue(gross), $gross: gross, deductible == null,  
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm"  
        || $act.getOrderStatus().toLowerCase() == "completed"))  

    // Calculate the maximum gross value among all eligible activities
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    )  

    // Count the number of previously applied deductibles of the same type  
    accumulate(
        Activity(hasDoubleValue(deductible), deductible == $value, $code: code),  
        $countOfActs: count($code)
    )  

    // Ensure we only process the activity if:
    // - No other deductible of this type has been applied
    // - This activity has the highest gross value  
    eval($countOfActs < 1 && $maxGross == $gross)  

then  
    //================ Deductible Calculation ================  
    String sRuleName = drools.getRule().getName();  

    // Case 1: Deductible has a Ceiling  
    if (hasDoubleValue($ceiling)) {  
        double appliedDeductible = 0.0d;  

        // Calculate deductible using a ceiling limit  
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);  

        // Apply the deductible  
        $act.setDeductible(appliedDeductible);  
        $act.addOutcome(Severity.INFO, sRuleName,  
            " Set deductible to " + appliedDeductible + ".", "");  

        // Logging  
        if ($c.logInfo) {  
            logInfo(sRuleName,  
                "Set deductible to " + appliedDeductible +  
                " For Activity=" + $act.getIdCaller() +  
                " code=" + $act.getCode());  
        }  

        // Update claim total with applied deductible  
        $deductible.setClaimTotal($claimTotal + appliedDeductible);  

        // Update working memory  
        update($act);  
        update($deductible);  

    } else {  
        // Case 2: Standard Deductible Calculation (No Ceiling)  
        double appliedDeductible = 0.0d;  

        // Round the deductible value  
        appliedDeductible = roundDouble($value);  

        // Ensure deductible does not exceed gross amount  
        if (appliedDeductible > $gross) {  
            appliedDeductible = $gross;  
        }  

        // Update claim total  
        $claimTotal = $claimTotal + appliedDeductible;  

        // Ensure claim total does not exceed deductible value  
        if ($claimTotal > $value) {  
            appliedDeductible = 0.0d;  
        }  

        // Apply deductible  
        $deductible.setClaimTotal($claimTotal);  
        $act.setDeductible(appliedDeductible);  

        // Add an informational outcome  
        $act.addOutcome(Severity.INFO, sRuleName,  
            " Set deductible to " + appliedDeductible +  
            ". max gross=" + $maxGross +  
            ". gross :" + $gross +  
            " countOfActs: " + $countOfActs +  
            " claimTotal:" + $claimTotal,  
            "");  

        // Logging  
        if ($c.logInfo) {  
            logInfo(sRuleName,  
                "Set deductible to " + appliedDeductible +  
                " For Activity=" + $act.getIdCaller() +  
                " code=" + $act.getCode());  
        }  

        // Update working memory  
        update($act);  
    }  
end

rule 'DEDUCTIBLE_CPT_X_RAY'
dialect 'mvel'
salience -1050

when
    // Match a Claim
    $c: Claim()
    
    // Match a Deductible of type "X-RAY" with a value greater than 0
    $deductible: Deductible(type.toUpperCase() == "X-RAY", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match an Activity of type CPT, with valid gross value and no existing deductible
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match ActivityGroup with name "X-RAY"
    ActivityGroup(type == CodeType.CPT.getValue(), name == "X-RAY") from $groups;

    // Calculate the maximum gross value for all applicable activities
    $maxGross: Double() from accumulate(
       $a: Activity(hasDoubleValue(gross), deductible == null),
       max($a.gross)
    )
    
    // Count the number of activities with the same deductible value
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
               $countOfActs: count($code))

    // Ensure this rule only fires if the activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If ceiling exists and is valid, apply ceiling-based deduction
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        // If logging is enabled, log the action
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible +
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling, apply a simple deductible based on the gross value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Adjust claim total and set the deductible if it exceeds the claim value
        $claimTotal = $claimTotal + appliedDeductible;
        
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, 
            " Set deductible to " + appliedDeductible + ". max gross=" + $maxGross + 
            ". gross: " + $gross + " countOfActs: " + $countOfActs + " claimTotal:" + $claimTotal, "");
        
        // If logging is enabled, log the action
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible +
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the applied deductible
        update($act);
    }
end

rule 'FORCE_NO_PATIENT_SHARE'
dialect 'mvel'  // Using the MVEL dialect for expressions.
salience -510   // Set rule priority; lower number means lower priority.

when
    // Match a Claim with:
    // - providerID exactly "DHA-F-0046260-C"
    // - receiverID exactly "INS026"
    // Also bind the providerID to $providerID (not used later but available if needed)
    $c:Claim(providerID=="DHA-F-0046260-C", receiverID=="INS026", $providerID:providerID)
    
    // From the Claim's contract list, select a Contract where the packageName is "Network 5"
    Contract(packageName=="Network 5") from $c.contract
    
    // Match an Activity where:
    // - Either deductible is null or copayment is null
    $act: Activity(deductible == null || copayment == null)
    
then
    // Retrieve the current rule's name for logging purposes.
    String sRuleName = drools.getRule().getName();
    
    // Define a message to log that this rule is setting both copay and deductible to 0.
    String sMsg = "NEURO SPINAL HOSPITAL - CORPORATE ACCOUNT+ DAMAN Set copay and deductible to 0";
    
    // If logging is enabled on the Claim, log the message with details about the Activity.
    if($c.logInfo){
        logInfo(sRuleName, sMsg + " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }
    
    // Set the deductible and copayment values on the Activity to 0.
    $act.setDeductible(0);
    $act.setCopayment(0);
    
    // Add an outcome on the Activity to record that the values have been set to 0.
    $act.addOutcome(Severity.INFO, sRuleName, sMsg, "");
    
    // Update the Activity in the working memory.
    update($act);
end

rule 'Legend'
dialect 'mvel'
when
	#conditions
then
#	#actions
#	SPC_WITH_PACKAGE 		-10
#	SPC_NO_PACKAGE 			-20
#	CUS_WITH_PACKAGE 		-30
#	CUS_NO_PACKAGE 			-40
#	CUS_DENTAL_WITH_PACKAGE 	-50
#	CUS_DENTAL_NO_PACKAGE 		-60
#	SPC_CODE_FACTOR 		-70
#	SPC_GROUP_FACTOR 		-80
#	SPC_FACTOR 			-90
# 	CUS_DRG_LIST_DayCase 		-91           
# 	CUS_DRG_LIST_IP			-92             
#       CUS_DRG_LIST_PRICE              -93
#       CUS_DRG_LIST_PRICE_NoWeight     -94 
#	SPC_DRG_LIST_PRICE       	-95 
#       SPC_DRG_LIST_PRICE_NoWeight     -96           
#	CUS_SET_MULTI_PROC		-101
#	CUS_PROC_LIST_PRICE 		-102 
#	CUS_LIST_PRICE			-103
#	SPC_ANESTHESIA_LIST_PRICE	-104
#	SPC_LIST_PRICE			-105
#	SPC_LIST_PRICE_MF2504		-106
#       HCPCS_LIST_PRICE                -107
#       CUS_HCPCS_LIST_PRICE            -110
#	CUS_DENTAL_LIST_PRICE		-120
#      DRUG_LIST_PRICE_DoH              -125
#	DRUG_LIST_PRICE			-130

#	SET_CODE_GROUP			-160  moved from /*-550*/
#	DENY_DISCOUNT			-180
#	DENY_DISCOUNT_DHA_IP_Anesthesia -181
#	DENY_DISCOUNT_DHA_IP_OT 	-182
#	SPC_DISCOUNT_PHARMACY		-200
#CUS_DISCOUNT_PHARMACY_DAMAN_MUBDLA-512 -205 
#	CUS_DISCOUNT_OP_DENTAL		-219
#	CUS_DISCOUNT_PHARMACY		-210
#	SPC_DISCOUNT_IP			-220
#	CUS_DISCOUNT_IP			-230
#	SPC_DISCOUNT_OP			-240
#	CUS_DISCOUNT_OP			-250
#       LIST_PRICE_Package_Items        -260 
#       LIST_PRICE_Package_Code         -270 
#       LIST_PRICE_Package_Items_Child  -280
#       LIST_PRICE_Package_Items_Parent -290
#       LIST_PRICE_CUSTOME_CODE         -300
#       CALC_Observation_52             -310
#	CALC_GROSS			 -400 
# 	CUS_DRG_LIST_DayCase_Drug	 -410
# 	CUS_DRG_LIST_IP_Transfer 	 -420
# 	CUS_DRG_LIST_IP_Outlier 	 -425
# 	CUS_DRG_LIST_IP_Drug		 -430
# 	CUS_DRG_LIST_IP_Surgery          -435         
# 	CUS_DRG_LIST_DayCase_HCSPC       -440
# 	CUS_DRG_LIST_IP_HCPCS            -441
# 	CUS_DRG_LIST_DayCase_RESET 	 -445
# 	CUS_DRG_LIST_IP_RESET		 -446
#	ALERT_NO_LIST_PRICE		-501
#	FORCE_NO_PATIENT_SHARE		-510
#	FORCE_NO_PATIENT_SHARE_DCAS	-511
#	SET_CODE_GROUP			/*-550*/ moved to -160
#	DENY_DEDUCTIBLE			-555
#   	DEDUCTIBLE_OP_DAMAN_BASIC_LAB	-560
#   	DEDUCTIBLE_OP_DAMAN_BASIC_RAD	-561
#	DEDUCTIBLE_DHA_DSL_500		-570	-NEW PRICE-230
#	DEDUCTIBLE_IN_PATIENT		-600
#	DEDUCTIBLE_OUT_PATIENT		-610
#	DEDUCTIBLE_DENTAL		-620
#	DEDUCTIBLE_PHARMACY		-630
#	DEDUCTIBLE_SERVICES_GENERAL_PRACTITIONER	-640
#	DEDUCTIBLE_SERVICES_Specialist			-650
#	DEDUCTIBLE_SERVICES_Consultant			-660
#	DEDUCTIBLE_SERVICES_Consultation		-670
#	DEDUCTIBLE_CPT_DAMAN_BASIC_GP_J170		-800
#	DEDUCTIBLE_CPT_DAMAN_BASIC_SPECIALIST_J170	-850
#	DEDUCTIBLE_CPT_OUT_PATIENT_PHYSIOTHERAPY_JBILL1292	-900
#	DEDUCTIBLE_MATERNITY			-950
#	DEDUCTIBLE_OPTICAL				-1000
#	DEDUCTIBLE_CPT_X_RAY				-1050
#	DEDUCTIBLE_CPT_MRI				-1100
#	DEDUCTIBLE_CPT_RADIOLOGY				-1150
#	DEDUCTIBLE_CPT_LABORATORY				-1200
#	DEDUCTIBLE_CPT_CONSULTATION			-1250
#	DEDUCTIBLE_CPT_GENERAL_PRACTITIONER		-1300
#	DEDUCTIBLE_CPT_SPECIALIST				-1350
#	DEDUCTIBLE_CPT_SPECIALIST				-1350
#	DEDUCTIBLE_CPT_DIAGNOSTIC				-1400
#	DEDUCTIBLE_CPT_OUT_PATIENT_EXCLUDING_DME_JBILL1292		-1450
#	DEDUCTIBLE_CPT_OUTPATIENT_EXCLUDING_PHARMACY_JBILL1292 	-1500
#	DEDUCTIBLE_OUTPATIENT_EXCLUDING_MATERNITY			-1505  -NEW
#	DEDUCTIBLE_MATERNITY_EXCLUDING_MCONSULTATION	-1507  -NEW
#	DEDUCTIBLE_MATERNITY_CONSULTATION_NOT_EM	-1509 -NEW
#	DEDUCTIBLE_MATERNITY_CONSULTATION_EM		-1511 -NEW
#	DEDUCTIBLE_CONSULTATION_EXCLUDING_MATERNITY_NOT_EM	-1513 -NEW
#	DEDUCTIBLE_CONSULTATION_EXCLUDING_MATERNITY_EM		-1515 -NEW
#	DEDUCTIBLE_DENTAL_CONSULTATION				-1517 -NEW
#	DEDUCTIBLE_DENTAL_EXCLUDING_DCONSULTATION		-1519 -NEW
#	DEDUCTIBLE_DENTAL_ORTHODONTIC_PROSTHESIS		-1521	-NEW
#	DEDUCTIBLE_DENTAL_EXCLUDING_ORTHODONTIC_PROSTHESIS	-1523	-NEW
#	DEDUCTIBLE_OUTPATIENT_EXCLUDING_PHRAMACY		-1525	-NEW --DELETED
#	DEDUCTIBLE_OUTPATIENT_EXCLUDING_PHYSIOTHERAPY		-1527	-NEW
#	DEDUCTIBLE_CONSULTAION_INCLUDING_DIAGNOSTIC_CPT		-1529	-NEW
#	DEDUCTIBLE_CONSULTAION_INCLUDING_DIAGNOSTIC_SERVICE	-1531	-NEW
#	DENY_COPAY					-2000
#	COPAY_DENTAL					-2100
#	COPAY_PHARMACY					-2150
#	COPAY_SERVICES_GENERAL_PRACTITIONER		-2200
#	COPAY_SERVICES_Specialist				-2250
#	COPAY_SERVICES_Consultant				-2300
#	COPAY_SERVICES_Consultation			-2350
# 	COPAY_CPT_OUT_PATIENT_NOT_EM_JBILL1282		-2400
#	COPAY_IN_PATIENT					-2450
#	COPAY_OUT_PATIENT				-2500
# 	COPAY_CPT_OUT_PATIENT_PHYSIOTHERAPY		-2550
#	COPAY_MATERNITY					-2600
# 	COPAY_OPTICAL					-2650
#	COPAY_CPT_X_RAY					-2700
#	COPAY_CPT_MRI					-2750
#	COPAY_CPT_RADIOLOGY				-2800
#	COPAY_CPT_LABORATORY				-2850
#	COPAY_CPT_CONSULTATION				-2900
#	COPAY_CPT_GENERAL_PRACTITIONER			-2950
#	COPAY_CPT_SPECIALIST				-3000
#	COPAY_CPT_DIAGNOSTIC				-3050
#	COPAY_HCPCS_ENAYA				-3100
#	COPAY_CPT_OUT_PATIENT_EXCLUDING_DME_JBILL1292	-3150
#	COPAY_CPT_OUTPATIENT_EXCLUDING_PHARMACY_JBILL1292	-3200
#	COPAY_OUTPATIENT_EXCLUDING_MATERNITY		-3205 -NEW
#	COPAY_MATERNITY_EXCLUDING_MCONSULTATION		-3207  -NEW
#	COPAY_MATERNITY_CONSULTATION_NOT_EM		-3209 -NEW
#	COPAY_MATERNITY_CONSULTATION_EM			-3211 -NEW
#	COPAY_CONSULTATION_EXCLUDING_MATERNITY_NOT_EM	-3213 -NEW
#	COPAY_CONSULTATION_EXCLUDING_MATERNITY_EM	-3215 -NEW
#	COPAY_DENTAL_CONSULTATION			-3217 -NEW
#	COPAY_DENTAL_EXCLUDING_DCONSULTATION		-3219 -NEW
#	COPAY_DENTAL_ORTHODONTIC_PROSTHESIS		-3221	-NEW
#	COPAY_DENTAL_EXCLUDING_ORTHODONTIC_PROSTHESIS	-3223  -NEW
#	COPAY_OUTPATIENT_EXCLUDING_PHRAMACY		-3225	-NEW --DELETED
#	COPAY_OUTPATIENT_EXCLUDING_PHYSIOTHERAPY	-3227	-NEW
#	COPAY_CONSULTAION_INCLUDING_DIAGNOSTIC_CPT	-3229	-NEW
#	COPAY_CONSULTAION_INCLUDING_DIAGNOSTIC_SERVICE	-3231	-NEW
# 	DENTAL_CONSULTATION_RESET_COPAY			-4000
# 	DENTAL_CONSULTATION_RESET_DEDUCTIBLE		-4010
#	CALC_Cash_ACTIVITY_NET          -4400
#	CALC_ACTIVITY_NET		-5000
#       CALC_ACTIVITY_VAT		-5100
#       CALC_Observation_50             -5450
#	CALC_CLAIM_TOTALS		-10000
#	report_Claim_Deductible		-20000
#	report_Claim_CoPayment		-20000
end

rule 'SPC_ANESTHESIA_LIST_PRICE'
dialect 'mvel'  // The rule uses MVEL for evaluating expressions.

salience -104  // This specifies the rule priority. The rule will execute at this priority level.
when
    // The rule is triggered when a Claim object with a non-null SPC_ID is present.
    $c: Claim($SPC_ID: SPC_ID, SPC_ID != null)

    // Ensures that there is an Encounter related to the Claim, and its start date is before the current date.
    Encounter($encStart: start) from $c.encounter

    // Checks if there is a MasterPriceList where the start and end dates match the Encounter date.
    $spcMasterPriceList: MasterPriceList($masterListId: id, startDate == null || $encStart >= startDate, endDate == null || $encStart <= endDate)

    // Looks for an Activity with a specific code, type, and SPCFactor, and where list is null.
    $act: Activity($code: code, $type: type, $SPCFactor: SPCFactor, list == null)

    // Checks if there is an ActivityGroup named "Anaesthesia" associated with the Activity.
    exists(ActivityGroup(name == "Anaesthesia") from $act.activityGroup)

    // Looks for a matching MasterPriceListItem with a price and anaesthesiaBaseUnits defined.
    MasterPriceListItem(masterListId == $masterListId, type == $type, code == $code, $price: price, anaesthesiaBaseUnits != null, $anaesthesiaBaseUnits: anaesthesiaBaseUnits)
    
then
    // Get the rule name to use in logging and outcome messages.
    String sRuleName = drools.getRule().getName();

    // Calculate the original list price.
    double listPrice = roundQuad($price * $SPCFactor);
    double oldListPrice = listPrice;

    // Calculate the new list price by adjusting it based on the anaesthesia base units and time units (if available).
    double newListPrice = listPrice * ($anaesthesiaBaseUnits + ($act.getTimeUnits() == null ? 0 : $act.getTimeUnits()));

    // Set the new list price on the Activity.
    $act.setList(roundQuad(newListPrice));

    // Set the anaesthesia base units on the Activity.
    $act.setAnaesthesiaBaseUnits($anaesthesiaBaseUnits);

    // Add an outcome with information about the list price change.
    $act.addOutcome(Severity.INFO, sRuleName, "Set list price to " + newListPrice + " was " + oldListPrice + ".", "");

    // Log the change in the list price if logging is enabled for the Claim.
    if ($c.logInfo) {
        logInfo(sRuleName, "Set list price to " + newListPrice + " was " + oldListPrice);
    }

    // Update the Activity with the new list price and anaesthesia base units.
    update($act);
end

rule 'SET_CODE_GROUP'
dialect 'mvel'  // The rule uses the MVEL dialect for rule evaluation.

/*salience -550*/  // The rule priority is commented out, indicating it might be set to a different value later.
when
    // The rule is triggered when there is a Claim object with a non-null SPC_ID.
    $c: Claim($SPC_ID:SPC_ID)

    // The rule checks for an Activity object where certain fields are null (deductible, copayment) and includes other conditions.
    $act: Activity(type != CodeType.TRADE_DRUG, 
                    $gross: gross,
                    deductible == null, copayment == null, 
                    $actType: type, $code: code)

    // The rule checks for a matching CodeGroup for the given activity type and code.
    $codeGroup: CodeGroup($codeGroupID: id, 
        ($actType == CodeType.CPT && type == CodeType.CPT) ||
        ($actType == CodeType.DENTAL && type == CodeType.DENTAL) ||
        ($actType == CodeType.HCPCS && type == CodeType.HCPCS) ||
        ($actType == CodeType.SERVICE && type == CodeType.SERVICE) ||
        ($actType == CodeType.TRADE_DRUG && type == CodeType.TRADE_DRUG),
        eval(containsCode($code) == true))

    // The rule ensures that the activity is not already part of an ActivityGroup with the same codeGroupID.
    not(ActivityGroup(id.equals($codeGroupID)) from $act.activityGroup)

then
    // Logging to indicate the detected code group.
    if($c.logInfo) {
        logInfo(drools.getRule().getName(), " Detect group=" + $codeGroup.getName() + ".");
    }

    // If the activity doesn't already belong to a group, it adds the code group to the activity.
    if($act.addActivityGroup($codeGroup.getId(), $codeGroup.getType().getValue(), $codeGroup.getName())) {
        // Logging when the group is set to the activity.
        if($c.logInfo) {
            logInfo(drools.getRule().getName(), 
                " Set group=" + $codeGroup.getName() + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Adding an outcome indicating that the code group was set for the activity.
        $act.addOutcome(Severity.INFO, drools.getRule().getName(), $codeGroup.getName(), "");
        
        // Update the activity with the new group.
        update($act);
    }

end

rule 'DEDUCTIBLE_SERVICES_Specialist'
dialect 'mvel'
salience -650  // Defines rule priority

when
    // Ensure the claim has a valid patient
    $c: Claim(patient != null)

    // Select deductible of type "Specialist" with a positive value
    $deductible: Deductible(
        type == "Specialist",
        value > 0, $ceiling: ceiling, $claimTotal: claimTotal, $value: value
    )

    // Select activity of type "SERVICE" with code "10"
    $act: Activity(
        type == CodeType.SERVICE,
        code == "10",
        hasDoubleValue(gross),
        deductible == null,
        $gross: gross,
        $act.getOrderStatus() != null && 
        ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Calculate maximum gross value across activities
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    )

    // Count already applied deductibles of the same type
    accumulate(
        Activity(hasDoubleValue(deductible), deductible == $value, $code: code),
        $countOfActs: count($code)
    )

    // Ensure this activity group has not been processed yet and is the highest gross
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Retrieve rule name for logging
    String sRuleName = drools.getRule().getName();

    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);

        // Assign the deductible to the activity
        $act.setDeductible(appliedDeductible);

        // Add an informational outcome
        $act.addOutcome(Severity.INFO, sRuleName,
            " Set deductible to " + appliedDeductible + ".", "");

        // Log the deductible application
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update deductible claim total
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);

    } else {
        // Apply deductible without ceiling constraints
        double appliedDeductible = roundDouble($value);

        // Ensure deductible does not exceed gross amount
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Update claim total and ensure it does not exceed allowed deductible value
        $claimTotal = $claimTotal + appliedDeductible;
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }

        // Update deductible claim total
        $deductible.setClaimTotal($claimTotal);

        // Assign the deductible to the activity
        $act.setDeductible(appliedDeductible);

        // Add an outcome message for tracking
        $act.addOutcome(Severity.INFO, sRuleName,
            " Set deductible to " + appliedDeductible +
            ". max gross=" + $maxGross +
            ". gross: " + $gross +
            " countOfActs: " + $countOfActs +
            " claimTotal: " + $claimTotal, "");

        // Log the deductible application
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity state
        update($act);
    }

end

rule 'DENTAL_CONSULTATION_RESET_COPAY'
dialect 'mvel'   // The rule uses the MVEL dialect for rule evaluation.
salience -4000    // Priority of the rule. A very low salience, meaning it has a very low priority and will be evaluated after other rules with higher salience.

when
    // The rule triggers when a Claim object is present.
    $c: Claim()

    // The rule applies to an Activity that satisfies these conditions:
    // - Copayment is not null or NaN.
    // - Deductible is greater than 0.
    // - Copayment is greater than 0.
    // - The activity code matches the dental consultation code (checked by eval(isDentalConsultationCode(code))).
    $act: Activity(copayment != null, !copayment.isNaN(), deductible > 0.0d, copayment > 0.0d,
                    eval(isDentalConsultationCode(code)))

then
    // Retrieve the name of the rule.
    String sRuleName = drools.getRule().getName();

    // Log the action if logging is enabled for the claim.
    if ($c.logInfo) {
        logInfo(sRuleName, 
                " Set coPayment to 0 For Activity=" + $act.getIdCaller()
                + " code=" + $act.getCode());
    }

    // Set the copayment to 0 for the activity.
    $act.setCopayment(0.0d);

    // Add an outcome to indicate that the copayment was set to 0.
    $act.addOutcome(Severity.INFO, sRuleName, "Set coPayment to 0.", "");

    // Update the activity with the new copayment value.
    update($act);
end

rule 'DENTAL_CONSULTATION_RESET_DEDUCTIBLE'
dialect 'mvel'   // The rule uses the MVEL dialect for rule evaluation.
salience -4010    // Priority of the rule. This rule will be evaluated after those with higher salience.

when
    // The rule triggers when a Claim object is present.
    $c: Claim()

    // The rule applies to activities of type DENTAL, with a non-null deductible greater than 0.
    // Additionally, it ensures that the code is not a dental consultation code.
    $act: Activity(type == CodeType.DENTAL, deductible != null, !deductible.isNaN(), deductible > 0.0d,
                   eval(!isDentalConsultationCode(code)))
 
then
    // Retrieve the rule's name for logging purposes.
    String sRuleName = drools.getRule().getName();

    // Log the action of setting the deductible to 0 if logging is enabled for the claim.
    if($c.logInfo) {
        logInfo(sRuleName, " Set Deductible to 0.");
    }

    // Set the deductible to 0 for the activity.
    $act.setDeductible(0.0d);

    // Add an outcome to indicate that the deductible was set to 0.
    $act.addOutcome(Severity.INFO, sRuleName, "Set Deductible to 0.", "");

    // Update the activity with the new deductible value.
    update($act);
end

rule 'DEDUCTIBLE_SERVICES_GENERAL_PRACTITIONER'
dialect 'mvel'
salience -640  // Medium-low priority

when
    // Ensure the claim has a patient
    $c: Claim(patient != null)

    // Deductible must be for GP or MP, and have a positive value
    $deductible: Deductible(
        type in ("General Practitioner", "Medical Practitioner"),
        value > 0,
        $ceiling: ceiling,
        $claimTotal: claimTotal,
        $value: value
    )

    // Activity must be a service with code "9", no deductible assigned, and completed status
    $act: Activity(
        type == CodeType.SERVICE,
        code == "9",
        hasDoubleValue(gross),
        deductible == null,
        $gross: gross,
        $act.getOrderStatus() != null && 
        ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Find the maximum gross value among all similar activities
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), code == "9", deductible == null),
        max($a.gross)
    )

    // Count how many times this deductible has been applied
    accumulate(
        Activity(hasDoubleValue(deductible), deductible == $value, $code: code),
        $countOfActs: count($code)
    )

    // Ensure we process only the highest gross value and if no deductible has been applied yet
    eval($countOfActs < 1 && $maxGross == $gross)

then
    String sRuleName = drools.getRule().getName();
    double appliedDeductible = 0.0d;

    // Apply deductible based on ceiling
    if (hasDoubleValue($ceiling)) {
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
    } else {
        appliedDeductible = roundDouble($value);
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Prevent exceeding claim limit
        $claimTotal = $claimTotal + appliedDeductible;
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
    }

    // Assign deductible to activity
    $act.setDeductible(appliedDeductible);

    // Update deductible claim total
    $deductible.setClaimTotal($claimTotal + appliedDeductible);

    // Add outcome message
    $act.addOutcome(
        Severity.INFO,
        sRuleName,
        " Set deductible to " + appliedDeductible +
        ". max gross=" + $maxGross + ". gross :" + $gross +
        " countOfActs: " + $countOfActs + " claimTotal:" + $claimTotal,
        ""
    );

    // Log if logging is enabled
    if ($c.logInfo) {
        logInfo(sRuleName, " Set deductible to " + appliedDeductible +
            " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Update working memory
    update($act);
    update($deductible);
end

rule 'DEDUCTIBLE_SERVICES_Consultation'
dialect 'mvel' // Specifies that the rule uses the MVEL dialect for expressions.
salience -670 // Defines the rule's salience (priority), -670 means it's of low priority.

when
	$c:Claim(patient != null) // Checks that the Claim object has a non-null patient.

	// Retrieves the Deductible object where type is "Consultation", value is greater than 0,
	// and assigns values for ceiling, claimTotal, and value.
	$deductible:Deductible(type == "Consultation", value>0, $ceiling:ceiling, $claimTotal:claimTotal, $value:value)

	// Retrieves the Activity object where type is SERVICE, has gross value, deductible is null, 
	// order status is either "cm" or "completed".
	$act : Activity(type==CodeType.SERVICE, hasDoubleValue(gross), deductible == null, 
		$gross:gross, 
		$act.getOrderStatus()!=null && ($act.getOrderStatus().toLowerCase()=="cm" || 
		$act.getOrderStatus().toLowerCase()=="completed"))

	// Ensures that the Activity belongs to a group of type SERVICE and named "Consultations".
	ActivityGroup(type.intValue() == CodeType.SERVICE.getValue(), name=="Consultations") from $act.activityGroup
	
	// Calculate the maximum gross value from activities of type SERVICE under "Consultations" group.
    $maxGross: Double() from accumulate(
       $a:Activity(hasDoubleValue(gross), deductible == null)
       and 
       ActivityGroup(type.intValue() == CodeType.SERVICE.getValue(), name=="Consultations") from $a.activityGroup
        max($a.gross) // Finds the maximum gross value among these activities.
    )

    // Count the number of activities that have the same deductible value.
    accumulate(Activity(hasDoubleValue(deductible), deductible==$value, $code:code), $countOfActs:count($code))

    // Ensures this rule is only triggered if no activities with the same deductible value have been processed yet 
    // and if the gross value matches the maximum gross value.
    eval($countOfActs < 1 && $maxGross == $gross)
    
then
	// Retrieves the name of the current rule.
		String sRuleName = drools.getRule().getName();

	// If a ceiling value exists, process it with the claim total.
	if(hasDoubleValue($ceiling)){
		double appliedDeductible = 0.0d;

		// Calculates applied deductible using a ceiling value.
		appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
		
		// Sets the deductible for the activity.
		$act.setDeductible(appliedDeductible);
		
		// Logs the outcome of applying the deductible.
		$act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

		// Logs detailed information if the logging flag is set.
		if($c.logInfo){
			logInfo(sRuleName," Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
		}
		
		// Updates the deductible with the applied value.
		$deductible.setClaimTotal($claimTotal + appliedDeductible);

		// Updates both the activity and deductible objects.
		update($act);
		update($deductible);

	}else{
		double appliedDeductible = 0.0d;

		// If no ceiling is provided, apply the deductible by rounding the value.
		appliedDeductible = roundDouble($value);

		// If the deductible is greater than the gross value, limit the deductible to the gross value.
		if (appliedDeductible > $gross){
			appliedDeductible = $gross;
		}
		
		// Updates the claim total with the applied deductible.
		$claimTotal = $claimTotal + appliedDeductible;

		// If the claim total exceeds the deductible value, reset the applied deductible to zero.
		if ($claimTotal > $value){
			appliedDeductible = 0.0d;
		}

		// Updates the deductible with the new claim total.
		$deductible.setClaimTotal($claimTotal);
		
		// Sets the deductible on the activity.
		$act.setDeductible(appliedDeductible);
		
		// Logs the outcome of applying the deductible.
		$act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + 
			". max gross=" + $maxGross + ". gross :" + $gross + " countOfActs: " + $countOfActs + " claimTotal:" + $claimTotal, "");
		
		// Logs detailed information if the logging flag is set.
		if($c.logInfo){
			logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
				" For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
		}
		
		// Updates the activity object.
		update($act);
	}
end

rule 'report_Claim_Deductible'
dialect 'mvel'  // Use the MVEL dialect for expressions.
salience -20000 // Set a high negative salience; this rule fires after rules with higher priority.

when
    // Retrieve any Claim object (no specific conditions on the claim).
    $c:Claim()
    
    // Use an accumulate() function to calculate the total deductible from all matching Activity objects.
    // The Activity must satisfy:
    // - 'deductible' is not null,
    // - 'deductible' is greater than 0.0,
    // - 'deductible' is a valid number (not NaN).
    // Bind each deductible value to $deductible, then sum all such values and bind the result to $totalDed.
    $totalDed: Number() from accumulate( 
        Activity(deductible != null, deductible > 0.0d, !deductible.isNaN(), $deductible: deductible),
        sum($deductible)
    )
    
then
    // Add an outcome to the Claim, logging the total deductible amount calculated.
    $c.addOutcome(Severity.INFO, drools.getRule().getName(), " totalDeductible =" + $totalDed, "");

end

rule 'report_Claim_CoPayment'
dialect 'mvel'                          // Use MVEL dialect for expressions.
salience -20000                         // Set a very high negative salience (lower priority).

when
    // Retrieve any Claim object.
	$c:Claim()

    // Use an accumulate() to sum all copayment values from matching Activity objects:
    // - The Activity must have a non-null copayment.
    // - The copayment value must be greater than 0.
    // - The copayment must be a valid number (not NaN).
    // The copayment value is bound to $copayment.
    // The accumulate() then sums all these values and binds the result to $totalCoPay.
	$totalCoPay: Number() from accumulate(
	    Activity(copayment != null, copayment > 0.0d, !copayment.isNaN(), $copayment: copayment),
	    sum($copayment)
	)
	
then
    // Add an outcome to the Claim that logs the total co-payment calculated.
	$c.addOutcome(Severity.INFO, drools.getRule().getName(), " totalCoPayment =" + $totalCoPay, "");

end

rule 'SPC_DISCOUNT_PHARMACY'
dialect 'mvel'   // The rule uses the MVEL dialect for rule evaluation.
salience -200     // Priority of the rule. Lower values imply higher priority.

when
    // The rule applies when the Claim contains a valid SPC_ID.
    $c:Claim($SPC_ID:SPC_ID, SPC_ID != null)

    // The rule checks if the SPCContract exists with the matching SPC_ID and retrieves the PHARM_DISCOUNT.
    SPCContract(ID.intValue() == $SPC_ID.intValue(), $PHARM_DISCOUNT:PHARM_DISCOUNT)

    // The rule applies to TRADE_DRUG activities with a valid non-null and non-NaN list price.
    $act:Activity(type == CodeType.TRADE_DRUG, $code:code, list != null, !list.isNaN(), discount == null, $list:list, $quantity: quantity)
    
then
    // If the PHARM_DISCOUNT is null or less than 0, it is set to 0.0d.
    Double pharmDiscount = ($PHARM_DISCOUNT == null || $PHARM_DISCOUNT < 0) ? 0.0d : $PHARM_DISCOUNT;
    
    // Log the discount application if logging is enabled for the claim.
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), 
                " Apply discount=" + pharmDiscount +
                " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Set the discount percentage on the activity.
    $act.setDiscountPercentage(pharmDiscount);

    // Calculate and set the actual discount value.
    // If quantity is null, NaN, or less than 0, it defaults to 1.
    $act.setDiscount($act.getDiscountPercentage().isNaN() ? 0 : 
                     roundDouble(((($list / 100) * $act.getDiscountPercentage()) *
                     ($quantity == null || $quantity.isNaN() || $quantity < 0 ? 1 : $quantity))));

    // Add an outcome indicating the discount application.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
                    " Apply discount=" + pharmDiscount + "", "");

    // Update the activity with the applied discount.
    update($act);
end

rule 'SPC_FACTOR'
dialect 'mvel'   // The rule uses the MVEL dialect for rule evaluation.
salience -90      // Priority of the rule. The rule will be evaluated after those with higher salience.

when
    // The rule triggers when a Claim object with a non-null SPC_ID and null CUS_ID is present.
    $c: Claim($SPC_ID:SPC_ID, SPC_ID != null, CUS_ID == null)

    // The rule checks for an Encounter object associated with the claim.
    Encounter($start:start) from $c.encounter

    // The rule checks for a SPCContract object with a matching SPC_ID.
    $spcContract: SPCContract(ID.intValue() == $SPC_ID.intValue())

    // The rule applies to an Activity that is not of type TRADE_DRUG or IR_DRG, and where SPCFactor is null.
    $act: Activity(type != CodeType.TRADE_DRUG, type != CodeType.IR_DRG, $type:type, $code:code, SPCFactor == null)

then
    // Retrieve the rule's name for logging purposes.
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            " Apply contract factor=" + $spcContract.getFactor() +
            " to Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Set the SPCFactor for the activity to the value from the SPC contract.
    $act.setSPCFactor($spcContract.getFactor());

    // Add an outcome to indicate that the contract factor was applied to the activity.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Apply Factor=" + $spcContract.getFactor() + "", "");

    // Update the activity with the new SPC factor.
    update($act);
end

rule 'SPC_DISCOUNT_IP'
dialect 'mvel'  // Using MVEL dialect for rule scripting
salience -220  // Rule priority (lower value means lower priority)

when
    // Condition: Match Claim where SPC_ID is not null
    $c: Claim($SPC_ID: SPC_ID, SPC_ID != null)

    // Condition: Match Encounter with type between 3 and 6
    Encounter($encType: type, type >= 3 && type <= 6) from $c.encounter

    // Condition: Match SPCContract with SPC_ID and retrieve IP_DISCOUNT
    SPCContract(ID.intValue() == $SPC_ID.intValue(), $IP_DISCOUNT: IP_DISCOUNT)

    // Condition: Match Activity with a valid list and quantity, and no existing discount
    $act: Activity(type != CodeType.TRADE_DRUG, type != CodeType.HCPCS, 
        $code: code, list != null, !list.isNaN(), discount == null, $list: list, 
        $quantity: quantity)

then
    // Action: Set the IP_DISCOUNT to 0.0 if it's null or negative
    Double ipDiscount = ($IP_DISCOUNT == null || $IP_DISCOUNT < 0) ? 0.0d : $IP_DISCOUNT;

    // Action: If logging is enabled, log the discount applied to the Activity
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            " Apply discount=" + ipDiscount +
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Action: Set the discount percentage in the Activity
    $act.setDiscountPercentage(ipDiscount);

    // Action: Calculate and set the discount amount based on the list price and quantity
    $act.setDiscount(
        $act.getDiscountPercentage().isNaN() ? 0 : 
        roundDouble(
            ((($list / 100) * $act.getDiscountPercentage()) * 
            ($quantity == null || $quantity.isNaN() || $quantity < 0 ? 1 : $quantity))
        )
    );

    // Action: Add an outcome to the Activity, indicating the applied discount
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        " Apply discount=" + ipDiscount, "");

    // Action: Update the Activity to persist the discount changes
    update($act);
end

rule 'SPC_DISCOUNT_OP'
dialect 'mvel'
salience -240
when
	$c:Claim($SPC_ID:SPC_ID, SPC_ID != null)
	Encounter(type<3 || type>6) from $c.encounter
	SPCContract(ID.intValue()==$SPC_ID.intValue(), $OP_DISCOUNT:OP_DISCOUNT)
	$act:Activity(type != CodeType.TRADE_DRUG, type != CodeType.HCPCS, list != null, !list.isNaN(), discount == null, $list:list, 		$quantity: quantity)
// from $c.activity
	
then
Double opDiscount = ($OP_DISCOUNT == null || $OP_DISCOUNT < 0) ? 0.0d : $OP_DISCOUNT;
	if($c.logInfo){logInfo(drools.getRule().getName(), 
		" Apply discount="+opDiscount +
		" to Activity ID="+$act.getIdCaller()+" code="+$act.getCode());	}
	
		
	$act.setDiscountPercentage(opDiscount );
	$act.setDiscount($act.getDiscountPercentage().isNaN() ? 0 : 
	roundDouble(((($list/100)*$act.getDiscountPercentage())*
	($quantity==null || $quantity.isNaN() || $quantity<0?1:$quantity))));
	$act.addOutcome(Severity.INFO, drools.getRule().getName(),
		" Apply discount=" + opDiscount +"", "");
	update($act);
end

rule 'CUS_DENTAL_LIST_PRICE'
// Define the dialect to use MVEL for rule execution
dialect "mvel"

// Rule priority: -120
salience -120

when
    // Match a Claim object with a non-null CUS_DENTAL_ID
    $c: Claim($CUS_DENTAL_ID: CUS_DENTAL_ID, CUS_DENTAL_ID != null)

    // Match an Encounter object with a start date
    Encounter($encStart: start) from $c.encounter

    // Match a CusContract based on CUS_DENTAL_ID
    CusContract(
        ID.intValue() == $CUS_DENTAL_ID.intValue(), 
        $priceListId: priceListId
    )

    // Match an Activity object of type "DENTAL" with a code and quantity
    $act: Activity(
        type == CodeType.DENTAL, 
        $code: code, 
        $type: type, 
        list == null, 
        $quantity: quantity
    )

    // Match a CusPriceListItem with the same price list ID, code, and type
    CusPriceListItem(
        pricListId == $priceListId, 
        code == $code, 
        type == $type,
        startDate == null || $encStart >= startDate,
        endDate == null || $encStart <= endDate,
        $price: price, 
        $discount: discount
    )
then
    // Log the applied price and details if logging is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), 
            "Set list price, price list id=" + $priceListId +
            " price=" + $price + " to Activity ID=" + $act.getIdCaller() + 
            " code=" + $act.getCode());
    }

    // Set the list price in the Activity (NaN if no valid price)
    $act.setList($price == null || $price < 0 ? Double.NaN : roundQuad($price));

    // Apply discount if available and valid
    if ($discount != null && $discount > 0) {
        $act.setDiscountPercentage($discount);

        // Calculate the discount based on quantity and price
        if ($act.getList() != null && !$act.getList().isNaN()) {
            $act.setDiscount(
                $act.getDiscountPercentage().isNaN() ? 0 :
                roundDouble(((($act.getList() / 100) * $act.getDiscountPercentage()) *
                    ($quantity == null || $quantity.isNaN() || $quantity < 0 ? 1 : $quantity))
                )
            );
        }
    }

    // Add outcome for informational purposes
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Set list price, price list id=" + $priceListId + " price=" + $price, 
        "");

    // Update the Activity object
    update($act);
end

rule 'CUS_DENTAL_NO_PACKAGE'
// Define the dialect to use MVEL for rule execution
dialect "mvel"

// Rule priority: -60
salience -60

when
    // Match a Claim object with:
    // - A specific provider ID and receiver ID
    // - A null CUS_DENTAL_ID (indicating no dental contract has been applied yet)
    $c: Claim(
        $providerID: providerID, 
        $receiverID: receiverID, 
        CUS_DENTAL_ID == null
    )

    // Match a Contract object that:
    // - Has a package name not in a list of specific plan names
    Contract(
        $packageName: packageName, 
        packageName not in (
            "Enhanced LOW END Plan TC1 - TC2", 
            "Enhanced MID Range Plan TC1 - TC2",
            "Enhanced HIGH END Plan TC1 - TC2", 
            "ADNIC - TOP UP TC1", 
            "AXA TOP-UP TC1", 
            "AXA TOP-UP TC1 & TC2", 
            "NAS TOP UP TC1", 
            "NAS TOP-UP TC1", 
            "OMAN - TOP UP TC1"
        )
    ) from $c.contract

    // Match an Encounter object with a start date
    Encounter($start: start) from $c.encounter

    // Check if there's an existing Activity of type "DENTAL"
    exists(Activity(type == CodeType.DENTAL))

    // Ensure no matching CusContract with the same provider and receiver IDs, and dental package
    not(
        CusContract(
            insurerLicense == $receiverID, 
            facilityLicense == $providerID, 
            packageName == $packageName, 
            startDate == null || $start >= startDate, 
            isDental() == true, 
            endDate == null || $start <= endDate
        )
    )

    // Match a CusContract with the same provider, receiver, and dental services, but with a null package name
    $cusContract: CusContract(
        insurerLicense == $receiverID, 
        facilityLicense == $providerID, 
        packageName == null, 
        isDental() == true, 
        startDate == null || $start >= startDate, 
        endDate == null || $start <= endDate
    )
then
    // Log information if logging is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            "Apply dental custom contract ID=" + $cusContract.getID() + " Encounter start=" + $start);
    }

    // Set the dental custom contract ID in the claim object
    $c.setCUS_DENTAL_ID($cusContract.getID());

    // Add an outcome for logging purposes
    $c.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Apply dental custom contract ID=" + $cusContract.getID() + " Encounter start=" + $start, "");

    // Update the claim object to reflect the new CUS_DENTAL_ID
    update($c);

end

rule 'CUS_WITH_PACKAGE'
dialect 'mvel'
salience -30

when
    // Match a Claim with provider ID, receiver ID, and no SPC_ID or CUS_ID
    $c: Claim($providerID: providerID, $receiverID: receiverID, SPC_ID == null, CUS_ID == null)
    
    // Match Contract with a non-null package name and specific exclusions
    Contract($packageName: packageName, packageName != null, 
             packageName not in ("Enhanced LOW END Plan TC1 - TC2", "Enhanced MID Range Plan TC1 - TC2", 
                                 "Enhanced HIGH END Plan TC1 - TC2", "ADNIC - TOP UP TC1", 
                                 "AXA TOP-UP TC1", "AXA TOP-UP TC1 & TC2", "NAS TOP UP TC1", 
                                 "NAS TOP-UP TC1", "OMAN - TOP UP TC1")) from $c.contract
    
    // Match Encounter with a valid start date
    Encounter($start: start) from $c.encounter
    
    // Match CusContract with the given conditions
    $cusContract: CusContract(insurerLicense == $receiverID,
                              facilityLicense == $providerID, 
                              packageName != null, 
                              packageName.toLowerCase() == $packageName.toLowerCase(),
                              isDental() == false,
                              startDate == null || $start >= startDate,
                              endDate == null || $start <= endDate)

then
    // Log the rule action if logging is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), 
                "Apply Custom contract ID=" + $cusContract.getID() + " Encounter start=" + $start);
    }

    // Set the CUS_ID for the claim to the custom contract ID
    $c.setCUS_ID($cusContract.getID());

    // Add an outcome to indicate that the custom contract ID was applied
    $c.addOutcome(Severity.INFO, drools.getRule().getName(),
                  "Apply Custom contract ID=" + $cusContract.getID() + " Encounter start=" + $start, "");
    
    // Update the claim with the new CUS_ID
    update($c);
end

rule 'CUS_NO_PACKAGE'
dialect 'mvel'
salience -40

when
    // Fetch a Claim object where providerID and receiverID are available,
    // and ensure that SPC_ID and CUS_ID are null.
    $c: Claim($providerID: providerID, $receiverID: receiverID, SPC_ID == null, CUS_ID == null)
    
    // Fetch a Contract object associated with the claim, ensuring the packageName is not
    // one of the specified exclusion packages.
    Contract($packageName: packageName, packageName not in ("Enhanced LOW END Plan TC1 - TC2",
        "Enhanced MID Range Plan TC1 - TC2",
        "Enhanced HIGH END Plan TC1 - TC2",
        "ADNIC - TOP UP TC1",
        "AXA TOP-UP TC1",
        "AXA TOP-UP TC1 & TC2",
        "NAS TOP UP TC1",
        "NAS TOP-UP TC1",
        "OMAN - TOP UP TC1")) from $c.contract
    
    // Fetch Encounter object from the claim
    Encounter($start: start) from $c.encounter
    
    // Ensure that there is no existing `CusContract` matching specific conditions
    not(CusContract(insurerLicense == $receiverID,
                    facilityLicense == $providerID,
                    packageName == $packageName,
                    isDental() == false,
                    startDate == null || $start >= startDate,
                    endDate == null || $start <= endDate))
    
    // Fetch `CusContract` matching the receiverID and providerID without any packageName,
    // ensuring the contract isn't dental, and the start and end date conditions match
    $cusContract: CusContract(insurerLicense == $receiverID,
                              facilityLicense == $providerID,
                              packageName == null,
                              isDental() == false,
                              startDate == null || $start >= startDate,
                              endDate == null || $start <= endDate)

then
    // Log the contract ID and encounter start date if logging is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            "Apply Custom contract ID=" + $cusContract.getID() + " Encounter start=" + $start);
    }

    // Set the CUS_ID in the claim to the ID of the custom contract
    $c.setCUS_ID($cusContract.getID());
    
    // Add an outcome message indicating that the custom contract has been applied
    $c.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Apply Custom contract ID=" + $cusContract.getID() +
        " Encounter start=" + $start, "");
    
    // Update the claim object to reflect the changes
    update($c);
end

rule 'CUS_DENTAL_WITH_PACKAGE'
// Define the dialect as MVEL for rule execution
dialect "mvel"

// Rule priority: -50 (executes after higher-priority rules)
salience -50

when
    // Match a Claim object where CUS_DENTAL_ID is null
    $c: Claim(
        $providerID: providerID, 
        $receiverID: receiverID, 
        CUS_DENTAL_ID == null
    )

    // Match a Contract linked to the claim that does NOT belong to excluded package names
    Contract(
        $packageName: packageName, 
        packageName not in (
            "Enhanced LOW END Plan TC1 - TC2",
            "Enhanced MID Range Plan TC1 - TC2",
            "Enhanced HIGH END Plan TC1 - TC2",
            "ADNIC - TOP UP TC1",
            "AXA TOP-UP TC1",
            "AXA TOP-UP TC1 & TC2",
            "NAS TOP UP TC1",
            "NAS TOP-UP TC1",
            "OMAN - TOP UP TC1"
        )
    ) from $c.contract

    // Check if there is at least one dental-related activity
    exists(Activity(type == CodeType.DENTAL))

    // Capture the start date of an encounter linked to the claim
    Encounter($start: start) from $c.encounter

    // Match a Customer Contract (CusContract) linked to the provider and receiver
    $cusContract: CusContract(
        insurerLicense == $receiverID, 
        facilityLicense == $providerID, 
        packageName == $packageName, 
        isDental() == true, 
        (startDate == null || $start >= startDate), 
        (endDate == null || $start <= endDate)
    )
then
    // Logging for debugging
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), 
            "Apply Dental Custom contract ID=" + $cusContract.getID() + 
            " Encounter start=" + $start);
    }

    // Assign the custom dental contract ID to the claim
    $c.setCUS_DENTAL_ID($cusContract.getID());

    // Add an outcome message to the claim
    $c.addOutcome(
        Severity.INFO, 
        drools.getRule().getName(), 
        "Apply Dental Custom contract ID=" + $cusContract.getID() + 
        " Encounter start=" + $start, 
        ""
    );

    // Update the claim in the working memory
    update($c);

end

rule 'CUS_LIST_PRICE'
dialect 'mvel'
salience -103

when
    // Matching Claim with non-null CUS_ID
    $c: Claim($CUS_ID: CUS_ID, CUS_ID != null)

    // Matching Encounter associated with the Claim
    Encounter($encStart: start) from $c.encounter

    // Matching CusContract where CUS_ID is used to fetch the price list ID
    CusContract(ID.intValue() == $CUS_ID.intValue(), $priceListId: priceListId)

    // Matching Activity, excluding dental activities, with a code and quantity, where the list is null
    $act: Activity(type != CodeType.DENTAL, $code: code, $type: type, list == null, $quantity: quantity)

    // Matching CusPriceListItem with conditions based on price list, code, type, and date range
    CusPriceListItem(pricListId == $priceListId, code == $code, type == $type,
                     startDate == null || $encStart >= startDate,
                     endDate == null || $encStart <= endDate, 
                     $price: price, $discount: discount)

then
    // If logging is enabled, log the details of the rule execution
    if($c.logInfo) {
        logInfo(drools.getRule().getName(),
            " Set list price, price list id=" + $priceListId + " price=" + $price +
            " discount=" + ($discount == null ? "null" : "" + $discount) +
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Set the price list on the Activity object, ensuring a valid price
    $act.setList($price == null || $price < 0 ? Double.NaN : roundQuad($price));
    $act.setListPricePredifined(1);

    // If a discount exists and is positive, apply the discount
    if($discount != null && $discount > 0) {
        $act.setDiscountPercentage($discount);

        // If the list price is valid (not NaN), calculate the discount amount
        if ($act.getList() != null && !$act.getList().isNaN()) {
            $act.setDiscount($act.getDiscountPercentage().isNaN() ? 0 :
                roundDouble(((($act.getList() / 100) * $act.getDiscountPercentage()) *
                    ($quantity == null || $quantity.isNaN() || $quantity < 0 ? 1 : $quantity))));
        }
    }

    // Add outcome with detailed information
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "price list id=" + $priceListId + " price=" + $price +
        " discount=" + ($discount == null ? "null" : "" + $discount), "");

    // Update the Activity object
    update($act);

end

rule 'DRUG_LIST_PRICE'
dialect 'mvel'  // Using MVEL dialect for rule evaluation.
salience -130   // Rule priority with lower values having lower priority.

when
    // The claim must have a provider ID and its associated contract does not belong to certain plans.
    $c:Claim($providerID:providerID)
    Contract($packageName:packageName, packageName not in ("Enhanced LOW END Plan TC1 - TC2", 
                                                         "Enhanced MID Range Plan TC1 - TC2", 
                                                         "Enhanced HIGH END Plan TC1 - TC2", 
                                                         "ADNIC - TOP UP TC1", 
                                                         "AXA TOP-UP TC1", 
                                                         "AXA TOP-UP TC1 & TC2", 
                                                         "NAS TOP UP TC1", 
                                                         "NAS TOP-UP TC1", 
                                                         "OMAN - TOP UP TC1")) from $c.contract
    
    // Encounter from the claim to get the encounter start date.
    Encounter($encStart:start,start!=null) from $c.encounter
    
    // Facility with matching provider ID and regulator type.
    Facility(license == $providerID, $regulator:regulator)
    
    // The activity must be of type TRADE_DRUG with null list price.
    $act:Activity(type == CodeType.TRADE_DRUG, $code:code, $drugType:drugType, list == null)
    
    // Drug price information for the provider and the encounter date.
    DrugPrice(regulator.intValue() == $regulator.getValue(),
              code == $code,
              startDate == null || $encStart >= startDate,
              endDate == null || $encStart <= endDate,
              $package_Price_to_Public:package_Price_to_Public,
              $unit_Price_to_Public:unit_Price_to_Public)
    
then

    // Determine whether the price should be unit or package-based.
    Boolean unitPrice = false;
    Double price = null;
    
    // If drug type is null or specific values (0 or 1), the unit price is false, otherwise true.
    if ($drugType == null) {
        unitPrice = true;
    } else {
        unitPrice = ($drugType.intValue() == 0 || $drugType.intValue() == 1) ? false : true;
    }

    // Assign price based on unit price or package price.
    price = unitPrice ? roundQuad($unit_Price_to_Public) : roundQuad($package_Price_to_Public);

    // Ensure the price is valid; if invalid, set it to NaN.
    price = price == null || price < 0 ? Double.NaN : roundQuad(price);

    // Log the determined price if logging is enabled.
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
                " Set list price, for drug [" + (unitPrice ? "Unit" : "Package") + "] price=" + price +
                " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Set the activity's list price based on the determined price.
    $act.setList(roundQuad(price));

    // Add outcome indicating the price setting action.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
                    " [" + (unitPrice ? "Unit" : "Package") + "] price=" + price + "", "");

    // Update the activity with the new list price.
    update($act);

end

rule 'SPC_LIST_PRICE_MF2504'
dialect 'mvel'  // Using MVEL dialect for rule evaluation.
salience -106   // Priority of the rule, with lower values having lower priority.

when
    // The claim must have a specific provider ID and a non-null SPC_ID.
    $c:Claim(providerID == "MF2504", $SPC_ID:SPC_ID, SPC_ID != null)
    
    // Activity is of type HCPCS, with specific codes in the list and list price either null or zero.
    $act:Activity($code:code, $type:type, $SPCFactor:SPCFactor, list == null || list == 0.0d,
                  type == CodeType.HCPCS, code in("A0429", "A0398", "A0999", "A0424", "A0422", "A0998"))
    
then
    // Initialize the rule name and list price.
    String sRuleName = drools.getRule().getName();
    double listPrice = 0.0d;
    
    // Set list price based on the activity code.
    if ($code.equalsIgnoreCase("A0398")) {
        listPrice = 1500d;
    } else if ($code.equalsIgnoreCase("A0999")) {
        listPrice = 2000d;
    } else if ($code.equalsIgnoreCase("A0424")) {
        listPrice = 1000d;
    } else if ($code.equalsIgnoreCase("A0422")) {
        listPrice = 280d;
    } else if ($code.equalsIgnoreCase("A0998")) {
        listPrice = 750d;
    }
    
    // Log the information if logging is enabled for the claim.
    if ($c.logInfo) {
        logInfo(sRuleName, " Set list price -EPSD, code=" + $code + " price=" + listPrice + "");
    }
    
    // Set the list price for the activity.
    $act.setList(roundQuad(listPrice));
    $act.setListPricePredifined(1);  // Mark the list price as predefined.
    
    // Add an outcome indicating the list price set for the activity.
    $act.addOutcome(Severity.INFO, sRuleName, "Set list price -EPSD, code=" + $code + " price=" + listPrice + "", "");
    
    // Update the activity with the new list price.
    update($act);
end



rule 'CUS_DRG_LIST_IP_HCPCS'
dialect 'mvel'
salience -441
no-loop

when
    // Fetch the Claim object where CUS_ID is not null and matching provider license
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)
    
    // Fetch the Facility object with a license that matches the provider's license and regulator is DHA
    Facility(license == $providerID, regulator == Regulator.DHA)
    
    // Fetch the CusContract object where ID matches CUS_ID and extract base rate and DRG factor
    $cusContract: CusContract(ID.intValue() == $CUS_ID.intValue(), $BASE_RATE: BASE_RATE, $ipDRGFactor: IP_DRGFactor)
    
    // Fetch the Encounter object where the type is 3 or 4
    Encounter(type in (3, 4)) from $c.encounter
    
    // Fetch the Activity object where type is CodeType.IR_DRG and get code and weight (drg_weight)
    Activity(type == CodeType.IR_DRG, $code: code, $weight: drg_weight)
    
    // Fetch DHA_DRG with matching code and extract HCPCS portion
    DHA_DRG(code == $code, $HCPCS_Portion: hcpcsPortion)
    
    // Fetch the Activity object with code "98" and list is null
    $addOnForHCPCs: Activity(code == "98", list == null)
    
    // Accumulate the total gross amount for high-cost HCPCS items, where gross is greater than 5000 for specific codes
    $Total_High_Cost_HCPCS_Amount: Number(doubleValue > 0.0d) from accumulate(
        Activity(type == CodeType.HCPCS, hasDoubleValue(gross), 
            (code == "A4649" && gross > 5000.0d) || (code != "A4649"), $gross: gross, $hCode: code) 
        and DHA_DRG_HighCost(code == $hCode), sum($gross)
    )

then
    // Inlier Payment calculation: Set default values if any are null
    double weight = ($weight == null || $weight < 0) ? 0.0d : $weight;
    double baseRate = ($BASE_RATE == null || $BASE_RATE < 0) ? 0.0d : $BASE_RATE;
    double ipDRGFactor = ($ipDRGFactor == null || $ipDRGFactor < 0) ? 1.0d : $ipDRGFactor;
    Double inlierPayment = weight * baseRate * ipDRGFactor;

    // Calculate HCPCS portion based on total high-cost HCPCS amount
    Double hPortion = roundQuad($HCPCS_Portion * inlierPayment );

    // Calculate High-Cost Consumable Add-On Payment used for service code 98
    if (hPortion < $Total_High_Cost_HCPCS_Amount) {
        Double high_Cost_Consumable_Addonpayment = roundQuad(75 * ($Total_High_Cost_HCPCS_Amount - hPortion ) / 100);
        
        // If the add-on payment is greater than zero, update the list in Activity 98
        if (high_Cost_Consumable_Addonpayment > 0) {
            $addOnForHCPCs.setList(high_Cost_Consumable_Addonpayment);
         }else{
		$addOnForHCPCs.setList(0);
		}
    }else{
		$addOnForHCPCs.setList(0);
	}
    update($addOnForHCPCs);

    // If logging is enabled, log the information about the Total High Cost HCPCS Amount
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), "Total High Cost HCPCS Amount: " + $Total_High_Cost_HCPCS_Amount);
    }

    // Add an outcome message to indicate the update of HCPCS Addon and other calculations
    $addOnForHCPCs.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Total High Cost HCPCS Amount: " + $Total_High_Cost_HCPCS_Amount + 
        " hPortion: " + hPortion + " inlier: " + inlierPayment + 
        " list: " + $addOnForHCPCs.getList() + " Updated", "");

end

rule 'CUS_DRG_LIST_IP_Surgery'
dialect 'mvel'
salience -435
no-loop

when
    // Matching Claim with a non-null CUS_ID
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)
    
    // Matching Facility with regulator DHA
    Facility(license == $providerID, regulator == Regulator.DHA)
    
    // Matching CusContract for the given CUS_ID with BASE_RATE and IP_DRGFactor
    $cusContract: CusContract(ID.intValue() == $CUS_ID.intValue(), $BASE_RATE: BASE_RATE, $ipDRGFactor: IP_DRGFactor)
    
    // Matching Encounter types 3 and 4
    Encounter(type in (3, 4)) from $c.encounter
    
    // Matching an IR_DRG activity with a valid code and weight
    Activity(type == CodeType.IR_DRG, $code: code, $start: start, $weight: drg_weight)
    
    // Matching DHA_DRG for the given code to get the surgery portion
    DHA_DRG(code == $code, $Surgery_portion: surgeryPortion)
    
    // Matching an activity with code "98.02" and a null list price to add the addon
    $addOnForSurgery: Activity(code == "98.02", list == null)
    
    // Accumulating the total high-cost surgery amount from activities of type CPT
    $Total_High_Cost_Surgery_Amount: Number(doubleValue > 0.0d) from accumulate(
        Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, $hCode: code)
        and DHA_DRG_HighCost(code == $hCode), sum($gross)
    )

then
    // Inlier Payment Calculation: DRG weight, base rate, and DRG factor
    double weight = ($weight == null || $weight < 0) ? 0.0d : $weight;
    double baseRate = ($BASE_RATE == null || $BASE_RATE < 0) ? 0.0d : $BASE_RATE;
    double ipDRGFactor = ($ipDRGFactor == null || $ipDRGFactor < 0) ? 1.0d : $ipDRGFactor;
    Double inlierPayment = weight * baseRate * ipDRGFactor;
    
    // Surgery Portion Calculation: Calculate the surgery portion of the total high-cost surgery amount
    Double sPortion = roundQuad($Surgery_portion * $Total_High_Cost_Surgery_Amount);
    
    // High-Cost Surgery Addon Payment Calculation: If the surgery portion is greater than inlier payment
    if (sPortion > inlierPayment) {
        Double high_Cost_Surgery_Addonpayment = roundQuad(75 * ($Total_High_Cost_Surgery_Amount - inlierPayment) / 100);
        
        // If the addon payment is greater than 0, set it as the list price and gross for the addon activity
        if (high_Cost_Surgery_Addonpayment > 0) {
            $addOnForSurgery.setList(high_Cost_Surgery_Addonpayment);
            $addOnForSurgery.setGross(high_Cost_Surgery_Addonpayment);
            update($addOnForSurgery);
        }
    }

    // Log the details if logInfo flag is set
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            "Set DRG list price, CUS_ID=" + $CUS_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE +
            " total=" + ($weight * $BASE_RATE * $ipDRGFactor) +
            " to Activity ID=" + $addOnForSurgery.getIdCaller() + " code=" + $addOnForSurgery.getCode());
    }

    // Add outcome for the addon activity
    $addOnForSurgery.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Total High Cost DRUG Amount:" + $addOnForSurgery.getList(), "");

end

rule 'CUS_DRG_LIST_IP_Drug'
dialect 'mvel'
salience -430
no-loop

when
    // Fetch the Claim object with provider ID and CUS_ID, and ensure CUS_ID is not null
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)
    
    // Fetch Facility object related to the provider ID and ensure the regulator is DHA
    Facility(license == $providerID, regulator == Regulator.DHA)
    
    // Fetch CusContract object for the customer contract using the CUS_ID and get BASE_RATE and IP_DRGFactor
    $cusContract: CusContract(ID.intValue() == $CUS_ID.intValue(), $BASE_RATE: BASE_RATE, $ipDRGFactor: IP_DRGFactor)
    
    // Fetch Encounter object with type 3 or 4 (likely corresponding to some specific encounter types)
    Encounter(type in (3, 4)) from $c.encounter
    
    // Fetch Activity related to DRG codes
    Activity(type == CodeType.IR_DRG, $code: code, $start: start, $weight: drg_weight)
    
    // Fetch DHA_DRG object with matching code and get the drug portion
    DHA_DRG(code == $code, $Drug_portion: drugPortion)
    
    // Fetch Activity for drug add-on with a code "98.1" and ensure the list is null
    $addOnForDrug: Activity(code == "98.1", list == null)

    // Calculate the total high-cost drug amount by summing the gross values of activities with type TRADE_DRUG
    $Total_High_Cost_DRUG_Amount: Number(doubleValue > 0.0d) from accumulate(
        Activity(type == CodeType.TRADE_DRUG, hasDoubleValue(gross), $gross: gross, $hCode: code)
        and
        DHA_DRG_HighCost(code == $hCode),
        sum($gross)
    )

then
    // Inlier Payment calculation: Ensure the weight, base rate, and DRG factor are valid
    double weight = ($weight == null || $weight < 0) ? 0.0d : $weight;
    double baseRate = ($BASE_RATE == null || $BASE_RATE < 0) ? 0.0d : $BASE_RATE;
    double ipDRGFactor = ($ipDRGFactor == null || $ipDRGFactor < 0) ? 1.0d : $ipDRGFactor;
    
    // Calculate inlier payment based on the formula: weight * baseRate * DRG factor
    Double inlierPayment = weight * baseRate * ipDRGFactor;

    // Calculate the drug portion based on the total high-cost drug amount
    Double dPortion = roundQuad($Drug_portion * $Total_High_Cost_DRUG_Amount);

    // Check if the drug portion exceeds the inlier payment
    if (dPortion > inlierPayment) {
        // If it does, calculate the high-cost drug addon payment
        Double high_Cost_Drug_Addonpayment = roundQuad(75 * ($Total_High_Cost_DRUG_Amount - inlierPayment) / 100);
        
        // Set the list and gross values for the addon activity
        $addOnForDrug.setList(high_Cost_Drug_Addonpayment);
        $addOnForDrug.setGross(high_Cost_Drug_Addonpayment);
        
        // Update the addon activity with the new payment values
        update($addOnForDrug);
    }

    // Log the total high-cost drug amount if logging is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), "Total High Cost DRUG_Amount:" + $Total_High_Cost_DRUG_Amount);
    }

    // Add an outcome message to the addon activity with relevant values for debugging and tracking
    $addOnForDrug.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Total High Cost DRUG_Amount:" + $Total_High_Cost_DRUG_Amount + " dPortion:" + dPortion + 
        " inlier:" + inlierPayment + " list " + $addOnForDrug.getList() + " Updated", "");

end

rule 'CUS_DRG_LIST_DayCase_Drug'
// Define the dialect as MVEL for rule execution  
dialect "mvel"

// Rule priority: -410 (executes before lower-priority rules)
salience -410  

// Prevents infinite loops by avoiding re-triggering on the same fact  
no-loop  

when  
    // Match a Claim object where CUS_ID is not null  
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)  

    // Match a Facility that has a DHA regulator  
    Facility(license == $providerID, regulator == Regulator.DHA)  

    // Match the CusContract linked to the claims CUS_ID  
    $cusContract: CusContract(
        ID.intValue() == $CUS_ID.intValue(),  
        $BASE_RATE: BASE_RATE,  
        $dayCase_DRGFactor: dayCase_DRGFactor  
    )  

    // Match an Encounter with type 5 or 6  
    Encounter(type in (5,6)) from $c.encounter  

    // Match an Activity with code "98.1" (Drug Add-on) where `list` is null  
    $addOnForDrug: Activity(code == "98.1", list == null)  

    // Match an Activity of type IR_DRG  
    Activity(type == CodeType.IR_DRG, $code: code, $start: start, $weight: drg_weight, $DRGlist: list)  

    // Match a DHA_DRG entry with the same code, extracting `drugPortion`  
    DHA_DRG(code == $code, $Drug_portion: drugPortion)  

    // Accumulate total high-cost drug amount  
    $Total_High_Cost_DRUG_Amount: Number(doubleValue > 0.0d) from accumulate(
        Activity(type == CodeType.TRADE_DRUG, hasDoubleValue(gross), $gross: gross, $hCode: code)  
        and DHA_DRG_HighCost(code == $hCode), sum($gross)
    )  

then  
    // Compute the inlier payment  
    double weight = ($weight == null || $weight < 0) ? 0.0d : $weight;  
    double baseRate = ($BASE_RATE == null || $BASE_RATE < 0) ? 0.0d : $BASE_RATE;  
    double dayCase_DRGFactor = ($dayCase_DRGFactor == null || $dayCase_DRGFactor < 0) ? 1.0d : $dayCase_DRGFactor;  
    Double inlierPayment = weight * baseRate * dayCase_DRGFactor;  

    // Calculate Drug Portion  
    Double dPortion = roundQuad($Drug_portion * $Total_High_Cost_DRUG_Amount);  

    // If the drug portion exceeds the inlier payment, calculate an add-on payment  
    if (dPortion > inlierPayment) {  
        Double high_Cost_Drug_Addonpayment = roundQuad(75 * ($Total_High_Cost_DRUG_Amount - inlierPayment) / 100);  

        // Update the drug add-on activity  
        $addOnForDrug.setList(high_Cost_Drug_Addonpayment);  
        $addOnForDrug.setGross(high_Cost_Drug_Addonpayment);  
        update($addOnForDrug);  
    }  

    // Logging for debugging  
    if ($c.logInfo) {  
        logInfo(drools.getRule().getName(), "Total High Cost DRUG _Amount: " + $Total_High_Cost_DRUG_Amount);  
    }  

    // Add an outcome message to the activity  
    $addOnForDrug.addOutcome(Severity.INFO, drools.getRule().getName(),  
        "Total High Cost DRUG _Amount: " + $Total_High_Cost_DRUG_Amount +  
        " dPortion: " + dPortion +  
        " inlier: " + inlierPayment +  
        " list: " + $addOnForDrug.getList() +  
        " Updated", "");  

end

rule 'CUS_DRG_LIST_IP_Transfer'
dialect 'mvel'
salience -420
no-loop

when
    // Match Claim with provider ID and Customer ID (CUS_ID)
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)
    
    // Match Facility with the provider ID and regulator DHA
    Facility(license == $providerID, regulator == Regulator.DHA)
    
    // Match CusContract with the CUS_ID and extract base rate and IP_DRGFactor
    $cusContract: CusContract(ID.intValue() == $CUS_ID, $BASE_RATE: BASE_RATE, $ipDRGFactor: IP_DRGFactor)
    
    // Match Encounter with type 3 or 4, and endType 4, capturing start and end times
    Encounter(type in (3, 4), endType == 4, $end: end.getTime(), $start: start.getTime()) from $c.encounter
    
    // Match Activity of type IR_DRG and extract drg_weight
    Activity(type == CodeType.IR_DRG, $code: code, $weight: drg_weight)
    
    // Match DHA_DRG with the same code and extract aLos value
    DHA_DRG(code == $code, $aLos: aLos)
    
    // Match Add-On Activity for transfer payment calculation (Service code 99.01)
    $addOnForTransferPayment: Activity(type == CodeType.SERVICE, code == "99.01")
  
then
    //================ Inlier Payment Calculation ====================
    double weight = ($weight == null || $weight < 0) ? 0.0d : $weight;
    double baseRate = ($BASE_RATE == null || $BASE_RATE < 0) ? 0.0d : $BASE_RATE;
    double ipDRGFactor = ($ipDRGFactor == null || $ipDRGFactor < 0) ? 1.0d : $ipDRGFactor;
    
    // Calculate Inlier Payment
    Double inlierPayment = weight * baseRate * ipDRGFactor;
    
    //================ Transfer Amount Calculation ====================
    long los = $end - $start;  // Length of stay in milliseconds
    int realLos = Math.round(los / 86400000); // Convert milliseconds to days
    
    // Adjust Length of Stay and calculate Transfer Payment
    realLos = (realLos - 1) * 50 / 100 + 1;
    Double Transfer_Payment = roundQuad((inlierPayment / $aLos) * realLos);
    
    // Set Transfer Payment for Add-On Activity
    $addOnForTransferPayment.setList(Transfer_Payment);
    $addOnForTransferPayment.setGross(Transfer_Payment);
    
    // Log information if logging is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), "");
    }
    
    // Add outcome for Transfer Payment calculation
    $addOnForTransferPayment.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Set Transfer Payment, inlier Payment=" + inlierPayment + 
        " aLOS=" + $aLos + " Los: " + realLos + 
        " total=" + Transfer_Payment, "");
    
    // Update Add-On Activity
    update($addOnForTransferPayment);
end

rule 'CUS_DRG_LIST_DayCase_HCSPC'
// Define the dialect as MVEL for rule execution
dialect "mvel"

// Rule priority: -440 (higher priority than rules with lower absolute values)
salience -440

// Prevent infinite looping by ensuring the rule does not re-trigger on updates
no-loop

when
    // Match any Claim object with a non-null CUS_ID and capture provider ID and CUS_ID
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)

    // Match a Facility with the same provider ID and regulated by DHA
    Facility(license == $providerID, regulator == Regulator.DHA)

    // Match the Customer Contract (CusContract) linked to the Claim's CUS_ID
    $cusContract: CusContract(
        ID.intValue() == $CUS_ID.intValue(), 
        $BASE_RATE: BASE_RATE, 
        $dayCase_DRGFactor: dayCase_DRGFactor
    )

    // Match an Encounter of type 5 or 6 linked to the Claim
    Encounter(type in (5,6)) from $c.encounter

    // Match an Activity with code "98" and no existing list
    $addOnForHCPCs: Activity(code == "98", list == null)

    // Match an IR-DRG Activity, capturing its DRG code and weight
    Activity(type == CodeType.IR_DRG, $code: code, $weight: drg_weight)

    // Match a DHA DRG with the same code as the IR-DRG and get the HCPCS portion
    DHA_DRG(code == $code, $HCPCS_Portion: hcpcsPortion)

    // Calculate total high-cost HCPCS amount by summing gross values for qualifying HCPCS activities
    $Total_High_Cost_HCPCS_Amount: Number(doubleValue > 0.0d) from accumulate(
        Activity(
            type == CodeType.HCPCS,
            hasDoubleValue(gross),
            (code == "A4649" && gross > 5000.0d) || (code != "A4649"),
            $gross: gross,
            $hCode: code
        ) 
        and 
        DHA_DRG_HighCost(code == $hCode), 
        sum($gross)
    )
then
    // Retrieve rule name for logging
    String sRuleName = drools.getRule().getName();

    // Inlier Payment Calculation
    double weight = ($weight == null || $weight < 0) ? 0.0d : $weight;
    double baseRate = ($BASE_RATE == null || $BASE_RATE < 0) ? 0.0d : $BASE_RATE;
    double dayCase_DRGFactor = ($dayCase_DRGFactor == null || $dayCase_DRGFactor < 0) ? 1.0d : $dayCase_DRGFactor;
    Double inlierPayment = weight * baseRate * dayCase_DRGFactor;

    // Calculate HCPCS portion based on total high-cost HCPCS amount
    Double hPortion = roundQuad($HCPCS_Portion * inlierPayment );

    // Calculate High-Cost Consumable Add-On Payment used for service code 98
    if (hPortion < $Total_High_Cost_HCPCS_Amount) {
        Double high_Cost_Consumable_Addonpayment = roundQuad(75 * ($Total_High_Cost_HCPCS_Amount - hPortion ) / 100);
        
        // If the add-on payment is greater than zero, update the list in Activity 98
        if (high_Cost_Consumable_Addonpayment > 0) {
            $addOnForHCPCs.setList(high_Cost_Consumable_Addonpayment);
         }else{
		$addOnForHCPCs.setList(0);
		}
    }else{
		$addOnForHCPCs.setList(0);
	}
    update($addOnForHCPCs);
    // Logging for debugging and audit trail
    if ($c.logInfo) {
        logInfo(sRuleName, "Total High Cost DRUG _Amount: " + $Total_High_Cost_HCPCS_Amount);
    }

    // Add an outcome to Activity 98 with the calculated values
    $addOnForHCPCs.addOutcome(
        Severity.INFO, 
        sRuleName,
        "Total High Cost DRUG _Amount: " + $Total_High_Cost_HCPCS_Amount + 
        " hPortion: " + hPortion + 
        " inlier: " + inlierPayment + 
        " list: " + $addOnForHCPCs.getList() + " Updated",
        ""
    );
end

rule 'CUS_DRG_LIST_DayCase'
// Define the dialect as MVEL for rule execution  
dialect "mvel"

// Rule priority: -91 (executes before lower-priority rules)
salience -91  

when  
    // Match a Claim where:
    // - CUS_ID is not null  
    // - Extracts CUS_ID and providerID  
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)  

    // Match a Facility where:
    // - The provider's **license matches**  
    // - The regulator is **DHA**  
    Facility(license == $providerID, regulator == Regulator.DHA)  

    // Match a CusContract associated with the claims CUS_ID  
    CusContract(ID.intValue() == $CUS_ID.intValue(), $BASE_RATE: BASE_RATE, $dayCase_DRGFactor: dayCase_DRGFactor)  

    // Match an Encounter where:
    // - The **type is 5 or 6** (inpatient DRG-based cases)  
    Encounter(type in (5,6)) from $c.encounter  

    // Match an IR_DRG (Inpatient DRG) Activity where:
    // - The **code is extracted**  
    // - The **start date is extracted**  
    // - The **DRG weight is extracted**  
    // - The **list price is currently null** (indicating it needs pricing)  
    $act: Activity(
        type == CodeType.IR_DRG,  
        $code: code,  
        $start: start,  
        $weight1: drg_weight,  
        list == null  
    )  

    // Match a DHA_DRG rule where:
    // - The **code matches** the activity's code  
    // - Extracts **HCPCS and drug portions**  
    // Extracts DHA_DRG information based on the code of the Activity
    DHA_DRG(code == $code, $HCPCS_Portion: hcpcsPortion, $Drug_portion: drugPortion,$weight:relativeWeight)  

then  
    //================ DRG Pricing Calculation ================  

    // Ensure DRG weight is non-negative  
    double weight = ($weight == null || $weight < 0) ? 0.0d : $weight;  

    // Ensure BASE_RATE is non-negative  
    double baseRate = ($BASE_RATE == null || $BASE_RATE < 0) ? 0.0d : $BASE_RATE;  

    // Ensure DRG Factor is valid; default to 1.0 if missing  
    double dayCase_DRGFactor = ($dayCase_DRGFactor == null || $dayCase_DRGFactor < 0) ? 1.0d : $dayCase_DRGFactor;  

    // Calculate the **inlier payment**  
    Double inlierPayment = roundQuad(weight * baseRate * dayCase_DRGFactor);  

    // Logging  
    if ($c.logInfo) {  
        logInfo(drools.getRule().getName(),  
            "Set DRG list price, CUS_ID=" + $CUS_ID +  
            " DRG weight=" + $weight +  
            " BASE_RATE=" + $BASE_RATE +  
            " dayCase_DRGFactor=" + $dayCase_DRGFactor +  
            " total=" + inlierPayment +  
            " to Activity ID=" + $act.getIdCaller() +  
            " code=" + $act.getCode());  
    }  

    // Add an informational outcome  
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),  
        "Set DRG list price, CUS_ID=" + $CUS_ID +  
        " DRG weight=" + $weight +  
        " BASE_RATE=" + $BASE_RATE +  
        " total=" + inlierPayment, "");  

    // Apply the calculated DRG price  
    $act.setList(inlierPayment);  

    // Update the activity in working memory  
    update($act);  

end

rule 'CUS_DRG_LIST_IP'
dialect 'mvel'
salience -92

when
    // Fetch the Claim object with non-null CUS_ID and providerID
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)

    // Check for the Facility with the given provider license and DHA regulator
    Facility(license == $providerID, regulator == Regulator.DHA)

    // Fetch the CusContract object where ID matches CUS_ID, and fetch the BASE_RATE and IP_DRGFactor
    $cusContract: CusContract(ID.intValue() == $CUS_ID.intValue(), $BASE_RATE: BASE_RATE, $ipDRGFactor: IP_DRGFactor)

    // Fetch the Encounter object where type is in the set (3, 4)
    Encounter(type in (3, 4)) from $c.encounter

    // Fetch the Activity object where type is 'IR_DRG', and the list is null
    $act: Activity(type == CodeType.IR_DRG, $code: code, $start: start, $weight1: drg_weight, list == null)

    // Fetch the DHA_DRG object with matching code and associated drug portion, surgery portion, and HCPCS portion
    DHA_DRG(code == $code, $HCPCS_Portion: hcpcsPortion, $Drug_portion: drugPortion, $Surgery_portion: surgeryPortion,$weight:relativeWeight)

then
    // Inlier Payment calculation: validate and handle null or invalid values for weight, base rate, and IP_DRGFactor
    double weight = ($weight == null || $weight < 0) ? 0.0d : $weight;
    double baseRate = ($BASE_RATE == null || $BASE_RATE < 0) ? 0.0d : $BASE_RATE;
    double ipDRGFactor = ($ipDRGFactor == null || $ipDRGFactor < 0) ? 1.0d : $ipDRGFactor;

    // Calculate the inlier payment based on weight, base rate, and DRG factor
    Double inlierPayment = roundQuad(weight * baseRate * ipDRGFactor);

    // Log the details if logging is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            "Set DRG list price, CUS_ID=" + $CUS_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE +
            " total=" + inlierPayment + " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Set the calculated inlier payment as the list price for the Activity
    $act.setList(inlierPayment);

    // Add outcome with information about the DRG list price update
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Set DRG list price, CUS_ID=" + $CUS_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE +
        " total=" + inlierPayment, "");

    // Update the Activity object to reflect the changes
    update($act);
end

rule 'CUS_DRG_LIST_IP_Outlier'
dialect 'mvel'
salience -425
no-loop

when
    // Matching Claim with a non-null CUS_ID
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)

    // Matching Facility with the provider's license
    Facility(license == $providerID, regulator == Regulator.DHA)

    // Matching CusContract using the CUS_ID to retrieve BASE_RATE and IP_DRGFactor
    $cusContract: CusContract(ID.intValue() == $CUS_ID, $BASE_RATE: BASE_RATE, $ipDRGFactor: IP_DRGFactor)

    // Matching Encounter where the type is 3 or 4 (likely inpatient/outpatient encounters)
    Encounter(type in (3,4)) from $c.encounter

    // Matching Activity of type IR_DRG with a code and weight
    $act: Activity(type == CodeType.IR_DRG, $code: code, $weight: drg_weight)

    // Matching Activity of type SERVICE with code "99" and no list price
    $addOnForOutlier: Activity(type == CodeType.SERVICE, code == "99", list == null)

    // Calculating cost per claim from Activity (excluding IR_DRG type) using DHA_DRG_COST_PER_ACTIVITY for cost calculation
    $costPerClaim: Number(doubleValue > 0.0d) from accumulate(
        Activity(type != CodeType.IR_DRG, hasDoubleValue(list), $quantity: quantity, $hCode: code) and
        DHA_DRG_COST_PER_ACTIVITY(code == $hCode, $BaseUnitsAnesthesia: BaseUnitsAnesthesia, $cost: cost),
        sum($cost * ($BaseUnitsAnesthesia + $quantity))
    )

then
    // Inlier Payment Calculation
    double weight = ($weight == null || $weight < 0) ? 0.0d : $weight;
    double baseRate = ($BASE_RATE == null || $BASE_RATE < 0) ? 0.0d : $BASE_RATE;
    double ipDRGFactor = ($ipDRGFactor == null || $ipDRGFactor < 0) ? 1.0d : $ipDRGFactor;
    Double inlierPayment = weight * baseRate * ipDRGFactor;

    // Outlier Payment Calculation
    Double outlier = 0.0d;
    if ($costPerClaim > inlierPayment) {
        // Apply outlier calculation formula
        outlier = roundQuad($costPerClaim - ((inlierPayment + 36024) * 60 / 100));

        // If outlier is valid (greater than 0 and less than or equal to inlier)
        if (outlier > 0 && outlier <= inlierPayment) {
            $addOnForOutlier.setList(outlier);
            $addOnForOutlier.setGross(outlier);
            update($addOnForOutlier);
        }
    }

    // Logging the rule execution if logInfo is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), " ");
    }

    // Adding outcome for the outlier calculation
    $addOnForOutlier.addOutcome(Severity.INFO, drools.getRule().getName(),
        "outlier: " + outlier + " inlierPayment: " + inlierPayment + " $costPerClaim: " + $costPerClaim, "");

end

rule 'COPAY_CONSULTATION_EXCLUDING_MATERNITY_EM'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -3215

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object where patient is not null
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)

    // Ensure the ClaimType is not Maternity
    ClaimType(type != ClaimType.Maternity) from $c.claimType

    // Ensure the Encounter type is 1 or 2
    Encounter($encType: type, type in (1, 2)) from $c.encounter

    // Find a CoPayment object where:
    // - type is "Consultation Excluding Maternity Consultation"
    // - value is greater than 0
    // - Capture ceiling, claimTotal, and value
    $coPayment: CoPayment(
        type == "Consultation Excluding Maternity Consultation", value > 0,
        $ceiling: ceiling, $claimTotal: claimTotal, $value: value
    )

    // Find an Activity object where:
    // - type is CPT
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - clinician does not match certain patterns (GN.*, GP.*, T.*, GT.*)
    // - OrderStatus is "cm" or "completed"
    // - Capture activityGroup and clinician
    $act: Activity(
        type == CodeType.CPT,
        gross != null, gross > 0, !gross.isNaN(),
        copayment == null,$gross:gross,
        $groups: activityGroup,
        $clinician: clinician,
        clinician not matches "GN.*",
        clinician not matches "GP.*",
        clinician not matches "T.*",
        clinician not matches "GT.*",
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Ensure the ActivityGroup is of type CPT and name is "Evaluation And Management"
    ActivityGroup(
        type == CodeType.CPT.getValue(),
        name == "Evaluation And Management"
    ) from $groups
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 

then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on grossMinusDeductible and deductible
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }
end

rule 'COPAY_CONSULTATION_EXCLUDING_MATERNITY_NOT_EM'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -3213

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object where patient is not null
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)

    // Ensure the ClaimType is not Maternity
    ClaimType(type != ClaimType.Maternity) from $c.claimType

    // Ensure the Encounter type is 1 or 2
    Encounter($encType: type, type in (1, 2)) from $c.encounter

    // Find a CoPayment object where:
    // - type is "Consultation Excluding Maternity Consultation"
    // - value is greater than 0
    // - Capture ceiling, claimTotal, and value
    $coPayment: CoPayment(
        type == "Consultation Excluding Maternity Consultation", value > 0,
        $ceiling: ceiling, $claimTotal: claimTotal, $value: value
    )

    // Find an Activity object where:
    // - type is SERVICE
    // - gross is not null, greater than 0, and not NaN
    // - copayment is null
    // - OrderStatus is "cm" or "completed"
    $act: Activity(
        type == CodeType.SERVICE,
        gross != null, gross > 0, !gross.isNaN(),$gross:gross,
        copayment == null,
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Ensure the ActivityGroup is of type SERVICE and name is "Consultations"
    ActivityGroup(
        type.intValue() == CodeType.SERVICE.getValue(),
        name == "Consultations"
    ) from $act.activityGroup
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Rule actions (RHS - Right Hand Side)

    // Get the rule name for logging and outcomes
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling is defined and valid
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on grossMinusDeductible and deductible
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());

        // Calculate the future copayment total
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment
        double appliedCopay = 0.0d;

        // Check if the future copayment total exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, calculate the applied copayment as the difference between ceiling and claimTotal
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it does not exceed, the applied copayment is the full value
            appliedCopay = value;
        }

        // Round the applied copayment
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claimTotal in the CoPayment object
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the Activity and CoPayment objects in working memory
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is defined, calculate the copayment value directly
        double appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));

        // Set the copayment on the Activity
        $act.setCopayment(appliedCopay);

        // Add an outcome to the Activity with INFO severity
        $act.addOutcome(Severity.INFO, sRuleName,
            "Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, "Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity object in working memory
        update($act);
    }
end

rule 'COPAY_DENTAL_CONSULTATION'
// Use MVEL as the dialect for this rule
dialect "mvel"

// Set the rule's salience (priority) to -3217 (low priority)
salience -3217

when
    // Match a Claim object ensuring the patient is not null.
    // Also, capture the patient and providerID for later use.
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Check that the ClaimType is Dental by matching its type.
    // The ClaimType is extracted from the Claim object.
    ClaimType(type == ClaimType.Dental) from $c.claimType
    
    // Match an Encounter object where the type is either 1 or 2,
    // extracted from the Claim's encounter property.
    Encounter($encType: type, type in (1,2)) from $c.encounter
    
    // Match a CoPayment object specific to Dental Consultation.
    // It must have a value greater than 0 and we capture ceiling, claimTotal, and value.
    $coPayment: CoPayment(
        type == "Dental Consultation", 
        value > 0, 
        $ceiling: ceiling, 
        $claimTotal: claimTotal, 
        $value: value
    )
    
    // Match an Activity object with the following criteria:
    // - The activity type must be DENTAL.
    // - Gross must be provided, greater than 0 and not NaN.
    // - No copayment has been set yet.
    // - Capture the activityGroup for further validation.
    // - The order status must be non-null and either "cm" or "completed" (case insensitive).
    $act: Activity(
        type == CodeType.DENTAL, 
        gross != null, gross > 0, !gross.isNaN(),$gross:gross, 
        copayment == null, 
        $groups: activityGroup, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
    
    // Ensure that among the activity groups captured, there is an ActivityGroup
    // with a type matching CodeType.DENTAL.getValue() and name equal to "Dental Consultation".
    ActivityGroup(
        type == CodeType.DENTAL.getValue(), 
        name == "Dental Consultation"
    ) from $groups;

//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
            
then
    // Retrieve the current rule's name for logging and outcome tracking.
    String sRuleName = drools.getRule().getName();
    
    // Check if a valid ceiling exists (not null, not NaN, and greater than zero).
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the provisional copayment value based on the activity's gross (minus deductible) and its deductible.
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());
        
        // Compute what the claim total would be after adding the calculated copayment.
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // If the future total exceeds the ceiling, cap the copayment to the remaining amount.
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            // Ensure appliedCopay is positive.
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // Otherwise, use the computed value.
            appliedCopay = value;
        }
        
        // Round the applied copay to the desired precision.
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the calculated copayment to the activity.
        $act.setCopayment(appliedCopay);
        
        // Add an outcome to the activity for traceability.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // If logging is enabled, log this information.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the claim's copayment total.
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify the engine that the activity and copayment objects have been modified.
        update($act);
        update($coPayment);
    } else {
        // If no valid ceiling is provided, simply calculate and round the copayment.
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));
        
        // Set the computed copayment on the activity.
        $act.setCopayment(appliedCopay);
        
        // Record the outcome for this activity.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Optionally log the information if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity to reflect the new copayment.
        update($act);
    }
end

rule 'COPAY_DENTAL_EXCLUDING_DCONSULTATION'
// Specify that this rule uses the MVEL dialect.
dialect "mvel"

// Set the rule's priority (salience) to -3219, which is relatively low.
salience -3219

when
    // Match a Claim object where the patient is not null.
    // Capture the patient and provider ID for further use.
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Extract the ClaimType from the claim and ensure it is Dental.
    ClaimType(type == ClaimType.Dental) from $c.claimType
    
    // Extract an Encounter from the claim, ensuring its type is either 1 or 2.
    Encounter($encType: type, type in (1,2)) from $c.encounter
    
    // Match a CoPayment object specific for "Dental Excluding Dental Consultation"
    // Ensure the copayment value is greater than 0 and capture the ceiling,
    // current claimTotal, and value.
    $coPayment: CoPayment(
        type == "Dental Excluding Dental Consultation", 
        value > 0, 
        $ceiling: ceiling, 
        $claimTotal: claimTotal, 
        $value: value
    )
    
    // Match an Activity that:
    // - has a type of DENTAL,
    // - a non-null, positive, and numeric gross value,
    // - no copayment has been set yet,
    // - capture its activityGroup for further filtering,
    // - and its order status is not null and equals either "cm" or "completed" (case insensitive).
    $act: Activity(
        type == CodeType.DENTAL, 
        gross != null, 
        gross > 0, 
        $gross:gross, 
        !gross.isNaN(), 
        copayment == null, 
        $groups: activityGroup,
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
    
    // Ensure that none of the ActivityGroup objects in $groups represent "Dental Consultation"
    // for the DENTAL code type.
    not(
        ActivityGroup(
            type == CodeType.DENTAL.getValue(), 
            name == "Dental Consultation"
        ) from $groups
    )
           //$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
	
then
    // Retrieve the current rule's name for logging and outcome purposes.
    String sRuleName = drools.getRule().getName();
    
    // Check if a valid ceiling exists (non-null, not NaN, and greater than zero).
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the provisional copayment based on the activity's gross (minus deductible) and its deductible.
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());
        
        // Determine the potential new total for copayment.
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // If the new total exceeds the ceiling, cap the copayment at the ceiling limit.
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            // Make sure the applied copayment is positive.
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // Otherwise, use the calculated value.
            appliedCopay = value;
        }
        
        // Round the final copayment value to the desired precision.
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the calculated copayment on the activity.
        $act.setCopayment(appliedCopay);
        
        // Record an outcome on the activity to document the applied copayment.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // If logging is enabled on the claim, log the copayment setting event.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the CoPayment's claimTotal with the new copayment amount.
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify the rule engine that the activity and copayment objects have been modified.
        update($act);
        update($coPayment);
    } else {
        // If no valid ceiling is provided, simply calculate and round the copayment.
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));
        
        // Set the computed copayment on the activity.
        $act.setCopayment(appliedCopay);
        
        // Record the outcome for the activity.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log the event if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity to reflect the new copayment.
        update($act);
    }
end

rule 'COPAY_DENTAL_EXCLUDING_ORTHODONTIC_PROSTHESIS'
// Use MVEL dialect for this rule
dialect "mvel"

// Set rule priority (salience) to -3223 (lower priority)
salience -3223

when
    // Match a Claim object ensuring the patient is not null.
    // Capture the patient and providerID for further use.
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Ensure the claim is of type Dental by matching its ClaimType.
    // 'from $c.claimType' extracts the claimType from the Claim object.
    ClaimType(type == ClaimType.Dental) from $c.claimType
    
    // Check that the encounter type is 1 or 2 from the Claim's encounter.
    Encounter($encType: type, type in (1, 2)) from $c.encounter
    
    // Match a CoPayment object where:
    // - the type equals "Dental Excluding Orthodontic & Prosthesis"
    // - the value is greater than 0
    // Also capture ceiling, claimTotal, and value from the CoPayment.
    $coPayment: CoPayment(type == "Dental Excluding Orthodontic & Prosthesis", value > 0, 
        $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match an Activity object meeting the following criteria:
    // - type must be DENTAL (CodeType.DENTAL)
    // - gross is not null, greater than 0, and is a valid number (not NaN)
    // - no copayment has been set yet (copayment == null)
    // - capture the activity group for later checks ($groups)
    // - order status is not null and equals either "cm" or "completed" (case insensitive)
    $act: Activity(
        type == CodeType.DENTAL, 
        gross != null, gross > 0, !gross.isNaN(), $gross:gross,
        copayment == null, 
        $groups: activityGroup, 
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )
    
    // Ensure that there is no ActivityGroup from $groups that represents:
    // - "Orthodontic Procedures", "Prosthodontics_removable", or "Prosthodontics_fixed"
    // for CodeType.DENTAL activities.
    not (
        ActivityGroup(
            type == CodeType.DENTAL.getValue(), 
            name == "Orthodontic Procedures" || name == "Prosthodontics_removable" || name == "Prosthodontics_fixed"
        ) from $groups
    )

	//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 

then
    // Retrieve the rule's name for logging and outcome tracking.
    String sRuleName = drools.getRule().getName();
    
    // If a valid ceiling is set (not null, not NaN, and > 0), then calculate copayment accordingly.
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the value based on gross minus deductible and deductible.
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());
        
        // Calculate the new claim total after applying this copayment.
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // If the new total exceeds the ceiling, cap the applied copay.
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            // Ensure appliedCopay is positive (in case subtraction returns a negative value).
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // Otherwise, use the calculated value as the applied copayment.
            appliedCopay = value;
        }
        
        // Round the applied copay to the desired precision.
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the copayment on the activity.
        $act.setCopayment(appliedCopay);
        
        // Record an outcome on the activity with information about the copayment set.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Optionally log the action if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the claim's total copayment.
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify the engine that the activity and copayment objects have been modified.
        update($act);
        update($coPayment);
    } else {
        // If no ceiling is provided, directly compute the copayment.
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));
        
        // Set the computed copayment on the activity.
        $act.setCopayment(appliedCopay);
        
        // Record an outcome on the activity with information about the copayment set.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Optionally log the action if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity as it has been modified.
        update($act);
    }
end

rule 'COPAY_DENTAL_ORTHODONTIC_PROSTHESIS'
// Set the dialect to MVEL for this rule
dialect 'mvel'

// Set the salience (priority) of this rule to -3221
salience -3221

// Define the conditions (LHS - Left Hand Side)
when
    // Match a Claim object with the following conditions:
    // - Patient is not null
    // - Extract patient and providerID fields
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)

    // Match a ClaimType object from the Claim's claimType field:
    // - Type is Dental
    ClaimType(type == ClaimType.Dental) from $c.claimType

    // Match an Encounter object from the Claim's encounter field:
    // - Type is either 1 or 2
    Encounter($encType: type, type in (1, 2)) from $c.encounter

    // Match a CoPayment object with the following conditions:
    // - Type is "Dental Orthodontic & Prosthesis"
    // - Value is greater than 0
    // - Extract ceiling, claimTotal, and value fields
    $coPayment: CoPayment(
        type == "Dental Orthodontic & Prosthesis",
        value > 0,
        $ceiling: ceiling,
        $claimTotal: claimTotal,
        $value: value
    )

    // Match an Activity object with the following conditions:
    // - Type is DENTAL
    // - Gross is not null, greater than 0, and not NaN
    // - Copayment is null
    // - ActivityGroup is assigned to $groups
    // - Order status is either "cm" or "completed" (case-insensitive)
    $act: Activity(
        type == CodeType.DENTAL,
        gross != null,
        gross > 0,$gross:gross,
        !gross.isNaN(),
        copayment == null,
        $groups: activityGroup,
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" ||
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )

    // Match an ActivityGroup object from the Activity's groups with the following conditions:
    // - Type is DENTAL (using getValue() method)
    // - Name is one of "Orthodontic Procedures", "Prosthodontics_removable", or "Prosthodontics_fixed"
    ActivityGroup(
        type == CodeType.DENTAL.getValue(),
        name in ("Orthodontic Procedures", "Prosthodontics_removable", "Prosthodontics_fixed")
    ) from $groups


	//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 


// Define the actions (RHS - Right Hand Side)
then
    // Get the name of the current rule for logging purposes
    String sRuleName = drools.getRule().getName();

    // Check if the ceiling is valid (not null, not NaN, and greater than 0)
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the copayment value based on gross minus deductible and deductible
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());

        // Calculate the future total copayment if this value is applied
        double futureCopayTotal = $claimTotal + value;

        // Initialize the applied copayment amount
        double appliedCopay = 0.0d;

        // Check if the future total copayment exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            // If it exceeds, cap the copayment at the remaining ceiling amount
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // If it doesn't exceed, use the full calculated value
            appliedCopay = value;
        }

        // Round the applied copayment value
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment on the activity
        $act.setCopayment(appliedCopay);

        // Add an outcome message to the activity
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the copayment change if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Update the activity and copayment objects in the working memory
        update($act);
        update($coPayment);
    } else {
        // If the ceiling is not valid, calculate the copayment without considering the ceiling
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));

        // Set the copayment on the activity
        $act.setCopayment(appliedCopay);

        // Add an outcome message to the activity
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the copayment change if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity object in the working memory
        update($act);
    }
end

rule 'COPAY_EM_EXCLUDING_DIAGNOSTIC'
// Use the MVEL dialect for this rule
dialect "mvel"

// Set the salience (priority) of this rule to -3231
salience -3231

when
    // Match a Claim object where the patient is not null,
    // and capture the patient and providerID for later use.
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Extract an Encounter from the Claim.
    // Only consider encounters whose type is 1 or 2.
    Encounter($encType: type, type in (1,2)) from $c.encounter
    
    // Match a CoPayment object with:
    // - type equal to "Consultation excluding Diagnostic"
    // - value greater than 0.
    // Also capture the ceiling, current claimTotal, and value fields.
    $coPayment: CoPayment(
        type == "Consultation excluding Diagnostic", 
        value > 0, 
        $ceiling: ceiling, 
        $claimTotal: claimTotal, 
        $value: value
    )
    
    // Accumulate any diagnostic activities that meet certain criteria.
    // We want to ensure that there are no diagnostic activities (size <= 0)
    // that belong to an ActivityGroup named "DGTest_CPT_9_Series".
    $diagnostic_acts: Set(size <= 0) from accumulate (
        // For each diagnostic activity of type CPT, capture its activity groups.
        $diagnostic_act: Activity(
            type == CodeType.CPT, 
            $diagnostic_act_groups: activityGroup
        )
        and
        // Check that one of the activity groups in this activity has:
        // - type equal to CodeType.CPT.getValue()
        // - name equal to "DGTest_CPT_9_Series"
        ActivityGroup(
            type == CodeType.CPT.getValue(),  
            name == "DGTest_CPT_9_Series"
        ) from $diagnostic_act_groups;
        // Collect the matching diagnostic activities into a set.
        collectSet($diagnostic_act)
    )
    
    // Match an Activity object (the one to which the copayment will be applied)
    // Conditions:
    // - Type is CPT.
    // - Gross is not null, greater than 0, and is a valid number (not NaN).
    // - No copayment has yet been set.
    // - Capture its activity groups in $groups.
    // - Order status is not null and is either "cm" or "completed" (case-insensitive).
    $act: Activity(
        type == CodeType.CPT, 
        gross != null, $gross:gross,
        gross > 0, 
        !gross.isNaN(), 
        copayment == null, 
        $groups: activityGroup,
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" ||
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
    
    // Ensure that one of the ActivityGroup objects from $groups has:
    // - type equal to CodeType.CPT.getValue()
    // - name equal to "Evaluation And Management"
    ActivityGroup(
        type == CodeType.CPT.getValue(), 
        name == "Evaluation And Management"
    ) from $groups

//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 


then
    // Retrieve the rule's name for logging and outcome tracking.
    String sRuleName = drools.getRule().getName();
    
    // Check if a valid ceiling exists: it must not be null, not NaN, and > 0.
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the potential copayment value based on the activity's gross (minus deductible) and its deductible.
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());
        
        // Calculate what the future total copayment would be if this value were applied.
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // If the future total exceeds the ceiling, cap the copayment to the remaining ceiling.
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            // Ensure the applied copayment is positive.
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // Otherwise, use the calculated value directly.
            appliedCopay = value;
        }
        
        // Round the applied copayment value to the desired precision.
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the calculated copayment on the Activity.
        $act.setCopayment(appliedCopay);
        
        // Record an outcome on the Activity with the copayment applied.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log the change if logging is enabled on the claim.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the CoPayment's claimTotal to include the new copayment.
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify the rule engine that the Activity and CoPayment objects have been modified.
        update($act);
        update($coPayment);
    } else {
        // If the ceiling is not valid, calculate the copayment without applying a ceiling.
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));
        
        // Set the computed copayment on the Activity.
        $act.setCopayment(appliedCopay);
        
        // Record an outcome on the Activity.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log the change if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the Activity in the working memory.
        update($act);
    }
end

rule 'COPAY_EM_INCLUDING_DIAGNOSTIC'
// The rule uses the MVEL dialect
dialect "mvel"

// Set the rule's priority to -3229
salience -3229

when
    // Match a Claim where the patient exists, capturing patient and providerID.
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Extract an Encounter from the claim, ensuring it has a type of 1 or 2.
    Encounter($encType: type, type in (1,2)) from $c.encounter
    
    // Match a CoPayment with type "Consultation including Diagnostic" and a positive value.
    // Capture the ceiling, claimTotal, and value for further use.
    $coPayment: CoPayment(
        type == "Consultation including Diagnostic", 
        value > 0, 
        $ceiling: ceiling, 
        $claimTotal: claimTotal, 
        $value: value
    ) 
    
    // Identify a set of diagnostic activities under the CPT category.
    // Collect activities that belong to the activity group "DGTest_CPT_9_Series".
    $diagnostic_acts: Set(size > 0) from accumulate ( 
        $diagnostic_act: Activity(
            type == CodeType.CPT, 
            $diagnostic_act_groups: activityGroup
        ) 
        and
        ActivityGroup(
            type == CodeType.CPT.getValue(),  
            name == "DGTest_CPT_9_Series"
        ) from $diagnostic_act_groups;
        collectSet($diagnostic_act)
    ) 
    
    // Match an Activity of type CPT that qualifies for copayment calculation.
    // - It must have a non-null, positive gross value.
    // - It must not have an existing copayment.
    // - The order status must be either "cm" or "completed".
    // - It must belong to the activity group "Evaluation And Management".
    $act: Activity(
        type == CodeType.CPT, 
        gross != null, $gross:gross,
        gross > 0, 
        !gross.isNaN(), 
        copayment == null, 
        $groups: activityGroup, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
    
    // Ensure the activity belongs to "Evaluation And Management" activity group.
    ActivityGroup(
        type == CodeType.CPT.getValue(), 
        name == "Evaluation And Management"
    ) from $groups
    
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Retrieve the name of the rule for logging.
    String sRuleName = drools.getRule().getName();
    
    // Check if a valid ceiling is defined (not null, not NaN, and greater than 0).
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment value based on the Activity's gross amount.
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());
        
        // Compute what the future total copayment would be.
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // If the new total exceeds the ceiling, cap the copayment.
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }
        
        // Round the applied copayment to two decimal places.
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the computed copayment on the Activity.
        $act.setCopayment(appliedCopay);
        
        // Log an outcome in the system.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log information if logging is enabled for the claim.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the CoPayment's claimTotal to reflect the newly applied copayment.
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify the rule engine that the Activity and CoPayment objects have changed.
        update($act);
        update($coPayment);
        
    } else {
        // If there is no ceiling, apply the copayment calculation directly.
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));
        
        // Set the computed copayment on the Activity.
        $act.setCopayment(appliedCopay);
        
        // Log an outcome in the system.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log information if logging is enabled for the claim.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Notify the rule engine that the Activity has changed.
        update($act);
    }
end

rule 'COPAY_MATERNITY_CONSULTATION_EM'
// Use MVEL as the dialect for this rule
dialect "mvel"

// Set rule priority to -3211 (lower priority than other rules)
salience -3211

when
    // Match a Claim object where:
    // - Patient is not null
    // - Store patient and provider ID for reference
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Ensure the claim type is "Maternity"
    ClaimType(type == ClaimType.Maternity) from $c.claimType

    // Match an Encounter object where:
    // - Type is either 1 or 2
    Encounter($encType: type, type in (1,2)) from $c.encounter

    // Match a CoPayment object where:
    // - Type is "Maternity Consultation"
    // - The value is greater than 0
    // - Capture ceiling, claimTotal, and value for calculations
    $coPayment: CoPayment(
        type == "Maternity Consultation", 
        value > 0, 
        $ceiling: ceiling, 
        $claimTotal: claimTotal, 
        $value: value
    )

    // Match an Activity object where:
    // - It is of type CPT
    // - It has a non-null, positive gross value
    // - It does not already have a copayment assigned
    // - The clinician does not match certain excluded categories (GN, GP, T, GT)
    // - Order status is either "cm" or "completed"
    $act: Activity(
        type == CodeType.CPT, 
        gross != null, 
        gross > 0, 
        !gross.isNaN(), $gross:gross,
        copayment == null, 
        $groups: activityGroup,  
        $clinician: clinician,
        clinician not matches "GN.*",
        clinician not matches "GP.*",
        clinician not matches "T.*",
        clinician not matches "GT.*", 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )

    // Match an ActivityGroup object where:
    // - It is of type CPT
    // - Its name is "Evaluation And Management"
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Evaluation And Management") from $groups;
		//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Retrieve the rule name for logging
    String sRuleName = drools.getRule().getName();

    // Check if a valid copayment ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment based on gross minus deductible
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());

        // Calculate the future total copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Ensure copayment does not exceed ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);

        // Set the calculated copayment in the activity
        $act.setCopayment(appliedCopay);

        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Notify rule engine that objects have changed
        update($act);
        update($coPayment);
    } else {
        // No ceiling, apply copayment directly
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));

        // Set the copayment
        $act.setCopayment(appliedCopay);

        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Notify rule engine that the activity object has changed
        update($act);
    }
end

rule 'COPAY_MATERNITY_CONSULTATION_NOT_EM'
// Specify that this rule uses the MVEL dialect.
dialect "mvel"

// Set the rule's salience (priority) to -3209 (low priority).
salience -3209

when
    // Match a Claim where the patient is not null.
    // Capture the patient and providerID for later use.
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Extract the ClaimType from the claim and ensure it is of type Maternity.
    ClaimType(type == ClaimType.Maternity) from $c.claimType
    
    // Extract an Encounter from the claim.
    // Only consider encounters with a type value of 1 or 2.
    Encounter($encType: type, type in (1,2)) from $c.encounter
    
    // Match a CoPayment object specific for "Maternity Consultation" with a positive value.
    // Capture the ceiling, current claimTotal, and value fields for later calculations.
    $coPayment: CoPayment(
        type == "Maternity Consultation", 
        value > 0, 
        $ceiling: ceiling, 
        $claimTotal: claimTotal, 
        $value: value
    )
    
    // Match an Activity object with the following conditions:
    // - The activity type must be SERVICE (using CodeType.SERVICE).
    // - Gross must be non-null, greater than 0, and a valid number (not NaN).
    // - No copayment has been set yet.
    // - Order status must be non-null and equal to "cm" or "completed" (case-insensitive).
    $act: Activity(
        type == CodeType.SERVICE, 
        gross != null, 
        gross > 0, $gross:gross,
        !gross.isNaN(), 
        copayment == null,
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" ||
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )
    
    // Ensure that one of the activity groups associated with the Activity satisfies:
    // - The type (converted to int) equals CodeType.SERVICE.getValue()
    // - The name is exactly "Consultations"
    ActivityGroup(
        type.intValue() == CodeType.SERVICE.getValue(), 
        name == "Consultations"
    ) from $act.activityGroup
            //$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross)  
then
    // Retrieve the current rule's name for logging purposes.
    String sRuleName = drools.getRule().getName();
    
    // Check if a valid ceiling is defined (i.e., not null, not NaN, and greater than 0).
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the potential copayment value based on the Activity's gross (minus deductible) and the deductible.
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());
        
        // Calculate what the future total copayment would be if this new value is applied.
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // If the future total exceeds the ceiling, cap the copayment at the remaining ceiling amount.
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            // Ensure that appliedCopay is positive.
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            // Otherwise, use the calculated value directly.
            appliedCopay = value;
        }
        
        // Round the applied copayment to the desired precision.
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the computed copayment on the Activity.
        $act.setCopayment(appliedCopay);
        
        // Record an outcome on the Activity for auditing, indicating the applied copayment.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Optionally log the change if logging is enabled on the Claim.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the CoPayment's claimTotal with the newly applied copayment.
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify the rule engine that both the Activity and CoPayment objects have been modified.
        update($act);
        update($coPayment);
    } else {
        // If there is no valid ceiling, compute the copayment without applying any ceiling cap.
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));
        
        // Set the computed copayment on the Activity.
        $act.setCopayment(appliedCopay);
        
        // Record an outcome on the Activity.
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log the change if logging is enabled on the Claim.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the Activity in the working memory.
        update($act);
    }

end

rule 'COPAY_MATERNITY_EXCLUDING_MCONSULTATION'
// Use MVEL as the dialect for this rule
dialect "mvel"

// Set rule priority to -3207 (lower priority than other rules)
salience -3207

when
    // Match a Claim object where:
    // - Patient is not null
    // - Store patient and provider ID for reference
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Ensure the claim type is "Maternity"
    ClaimType(type == ClaimType.Maternity) from $c.claimType

    // Match an Encounter object where:
    // - Type is either 1 or 2
    Encounter($encType: type, type in (1,2)) from $c.encounter

    // Match a CoPayment object where:
    // - Type is "Maternity Excluding Maternity Consultation"
    // - The value is greater than 0
    // - Capture ceiling and claimTotal values for calculations
    $coPayment: CoPayment(
        type == "Maternity Excluding Maternity Consultation", 
        value > 0, $value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )

    // Match a Diagnosis object and extract the diagnosis code
    Diagnosis($dcode: code) from $c.diagnosis

    // Match a CodeGroup object where:
    // - It is of type ICD9 or ICD10
    // - It belongs to either "Antenatal-Screening ICD_10" or "Antenatal-Screening ICD_9"
    // - The diagnosis code is present in the group
    $codeGroup: CodeGroup(
        $codeGroupID: id, 
        type == CodeType.ICD9 || type == CodeType.ICD10,
        name == "Antenatal-Screening ICD_10" || name == "Antenatal-Screening ICD_9",
        eval(containsCode($dcode) == true)
    )

    // Match an Activity object where:
    // - It is of type CPT
    // - It has a non-null, positive gross value
    // - It does not already have a copayment assigned
    // - Order status is either "cm" or "completed"
    $act: Activity(
        type == CodeType.CPT, 
        gross != null, 
        gross > 0, 
        !gross.isNaN(), $gross:gross,
        copayment == null, 
        $clinician: clinician, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )

    // Ensure the Clinician:
    // - Has a facility license matching the provider ID
    // - Has a license matching the activitys clinician
    // - Specializes in "Obstetrics & Gynecology"
    Clinician(
        facility_license == $providerID, 
        license == $clinician,  
        profession.toLowerCase() matches ".*obstetrics & gynecology.*"
    );
//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Retrieve the rule name for logging
    String sRuleName = drools.getRule().getName();

    // Check if a valid copayment ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment based on gross minus deductible
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());

        // Calculate the future total copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Ensure copayment does not exceed ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);

        // Set the calculated copayment in the activity
        $act.setCopayment(appliedCopay);

        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Notify rule engine that objects have changed
        update($act);
        update($coPayment);
    } else {
        // No ceiling, apply copayment directly
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));

        // Set the copayment
        $act.setCopayment(appliedCopay);

        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Notify rule engine that the activity object has changed
        update($act);
    }
end

rule 'COPAY_OUTPATIENT_EXCLUDING_MATERNITY'
// Use MVEL as the dialect for this rule
dialect "mvel"

// Set rule priority to -3205
salience -3205

when
    // Match a Claim object with a non-null patient
    $c: Claim(patient != null, $patient: patient)
    
    // Ensure the claim type is NOT "Maternity"
    ClaimType(type != ClaimType.Maternity) from $c.claimType

    // Match an Encounter object where:
    // - Type is either 1 or 2
    Encounter($encType: type, type in (1,2)) from $c.encounter

    // Match a CoPayment object where:
    // - Type is "Outpatient excluding Maternity"
    // - The value is greater than 0
    // - Capture ceiling and claimTotal values for calculations
    $coPayment: CoPayment(
        type == "Outpatient excluding Maternity", 
        value > 0, 
$value:value,
        $ceiling: ceiling, 
        $claimTotal: claimTotal
    )

    // Match an Activity object where:
    // - It has a non-null, positive gross value
    // - It does not already have a copayment assigned
    // - Order status is either "cm" or "completed"
    $act: Activity(
        gross != null, 
        gross > 0, 
        !gross.isNaN(), 
        copayment == null, 
        $gross: gross, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )

 //$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 

then
    // Retrieve the rule name for logging
    String sRuleName = drools.getRule().getName();

    // Check if a valid copayment ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment based on gross minus deductible
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());
        
        // Calculate the future total copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;
        
        // Ensure copayment does not exceed ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }
        
        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);
        
        // Set the calculated copayment in the activity
        $act.setCopayment(appliedCopay);
        
        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");
        
        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        
        // Notify rule engine that objects have changed
        update($act);
        update($coPayment);
    } else {
        // No ceiling, apply copayment directly
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));

        // Set the copayment
        $act.setCopayment(appliedCopay);

        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Notify rule engine that the activity object has changed
        update($act);
    }
end

rule 'COPAY_OUTPATIENT_EXCLUDING_PHYSIOTHERAPY'
// Use MVEL as the dialect for this rule
dialect "mvel"

// Set rule priority to -3227 (lower priority than other rules)
salience -3227

when
    // Match a Claim object where:
    // - Patient is not null
    // - Store patient and provider ID for reference
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Match an Encounter object where:
    // - Type is either 1 or 2
    Encounter($encType: type, type in (1,2)) from $c.encounter

    // Match a CoPayment object where:
    // - Type is "Outpatient Excluding Physiotherapy"
    // - The value is greater than 0
    // - Capture ceiling, claimTotal, and value for calculations
    $coPayment: CoPayment(
        type == "Outpatient Excluding Physiotherapy", 
        value > 0, 
        $ceiling: ceiling, 
        $claimTotal: claimTotal, 
        $value: value
    )

    // Match an Activity object where:
    // - It is **not** a trade drug
    // - It has a non-null, positive gross value
    // - It does not already have a copayment assigned
    // - Order status is either "cm" or "completed"
    $act: Activity(
        type != CodeType.TRADE_DRUG, 
        gross != null, 
        gross > 0, $gross:gross,
        !gross.isNaN(), 
        copayment == null, 
        $groups: activityGroup,  
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )

    // Ensure that the Activity does not belong to the "Physical Medicine & Rehabilitation" group
    not (
        ActivityGroup(
            type == CodeType.CPT.getValue(), 
            name == "Physical Medicine & Rehabilitation"
        ) from $groups
    )

//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
then
    // Retrieve the rule name for logging
    String sRuleName = drools.getRule().getName();

    // Check if a valid copayment ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment based on gross minus deductible
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());

        // Calculate the future total copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Ensure copayment does not exceed ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);

        // Set the calculated copayment in the activity
        $act.setCopayment(appliedCopay);

        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Notify rule engine that objects have changed
        update($act);
        update($coPayment);
    } else {
        // No ceiling, apply copayment directly
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));

        // Set the copayment
        $act.setCopayment(appliedCopay);

        // Add an outcome message
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log information if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Notify rule engine that the activity object has changed
        update($act);
    }
end

rule 'COPAY_SERVICE_EXCLUDING_DIAGNOSTIC'
// Define the dialect to use MVEL for rule execution
dialect "mvel"

// Rule priority: -3235 (low priority)
salience -3235

when
    // Match a Claim object with a non-null patient and a provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)

    // Match an Encounter object with type 1 or 2
    Encounter($encType: type, type in (1, 2)) from $c.encounter

    // Match a CoPayment object where:
    // - Type is "Consultation excluding Diagnostic"
    // - Value is greater than 0
    // - Capture ceiling, claimTotal, and value
    $coPayment: CoPayment(
        type == "Consultation excluding Diagnostic", 
        value > 0, 
        $ceiling: ceiling, 
        $claimTotal: claimTotal, 
        $value: value
    )

    // Match the condition where there are no diagnostic activities in the set
    $diagnostic_acts: Set(size <= 0) from accumulate (
        $diagnostic_act: Activity(
            type == CodeType.CPT, 
            $diagnostic_act_groups: activityGroup
        )
        and
        ActivityGroup(
            type == CodeType.CPT.getValue(), 
            name == "DGTest_CPT_9_Series"
        ) from $diagnostic_act_groups;
        collectSet($diagnostic_act)
    )

    // Match an Activity of type "SERVICE" with a valid order status
    $act: Activity(
        type == CodeType.SERVICE, 
        gross != null, 
        gross > 0, $gross:gross,
        !gross.isNaN(), 
        copayment == null, 
        $groups: activityGroup, 
        $act.getOrderStatus() != null && (
            $act.getOrderStatus().toLowerCase() == "cm" || 
            $act.getOrderStatus().toLowerCase() == "completed"
        )
    )

    // Match an ActivityGroup of type "SERVICE" and name "Consultations"
    ActivityGroup(
        type.intValue() == CodeType.SERVICE.getValue(), 
        name == "Consultations"
    ) from $groups

//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
	
then
    // Get the rule name for logging purposes
    String sRuleName = drools.getRule().getName();

    // Check if a valid ceiling exists
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Compute the copayment value based on gross and deductible
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());

        // Calculate the total future copayment
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Ensure the copayment does not exceed the ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        // Round the applied copayment to two decimal places
        appliedCopay = roundDouble(appliedCopay);

        // Set the copayment for the activity
        $act.setCopayment(appliedCopay);

        // Add outcome for logging purposes
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment details
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the claim total with the applied copayment
        $coPayment.setClaimTotal($claimTotal + appliedCopay);

        // Notify Drools that objects have changed
        update($act);
        update($coPayment);
    } else {
        // If no ceiling exists, apply the full copayment value
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));

        // Set the copayment for the activity
        $act.setCopayment(appliedCopay);

        // Add outcome for logging purposes
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied copayment details
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Notify Drools that the activity has changed
        update($act);
    }
end

rule 'COPAY_SERVICE_INCLUDING_DIAGNOSTIC'
// Define the dialect to use MVEL for rule execution
dialect "mvel"

// Rule priority: -3233
salience -3233

when
    // Match a Claim object with a non-null patient and provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)

    // Match an Encounter object with types 1 or 2
    Encounter($encType: type, type in (1, 2)) from $c.encounter

    // Match a CoPayment object with specified conditions (type is "Consultation including Diagnostic")
    $coPayment: CoPayment(
        type == "Consultation including Diagnostic", 
        value > 0, 
        $ceiling: ceiling, 
        $claimTotal: claimTotal, 
        $value: value
    )

    // Match a set of diagnostic activities (with type CodeType.CPT) related to a specific activity group
    $diagnostic_acts: Set(size > 0) from accumulate ( 
        $diagnostic_act: Activity(type == CodeType.CPT, $diagnostic_act_groups: activityGroup)
        and
        ActivityGroup(type == CodeType.CPT.getValue(), name == "DGTest_CPT_9_Series") from $diagnostic_act_groups;
        collectSet($diagnostic_act)
    )

    // Match an Activity of type "SERVICE" with a specific status
    $act: Activity(
        type == CodeType.SERVICE, 
        gross != null, gross > 0, !gross.isNaN(), copayment == null, $gross:gross,
        $groups: activityGroup, 
        $act.getOrderStatus() != null && 
        ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )
    
    // Match an ActivityGroup with type "SERVICE" and name "Consultations"
    ActivityGroup(
        type.intValue() == CodeType.SERVICE.getValue(), 
        name == "Consultations"
    ) from $groups

//$maxGross: Double() from accumulate(
	 //  $a:Activity(hasDoubleValue(gross), copayment == null),
	//   max($a.gross))
	//    accumulate(
       // Activity(hasDoubleValue(copayment), copayment ==$value, $code:code),
       // $countOfActs:count($code))
	//eval($countOfActs < 1 && $maxGross == $gross) 
	
then
    // Rule name for logging
    String sRuleName = drools.getRule().getName();

    // If a ceiling is defined and valid, apply ceiling logic to the co-payment calculation
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the co-payment value based on gross amount minus deductible
        double value = $coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible());
        double futureCopayTotal = $claimTotal + value;
        double appliedCopay = 0.0d;

        // Apply the ceiling if the future co-payment exceeds the ceiling
        if (futureCopayTotal > $ceiling) {
            appliedCopay = $ceiling - $claimTotal;
            appliedCopay = appliedCopay < 0 ? -1 * appliedCopay : appliedCopay;
        } else {
            appliedCopay = value;
        }

        appliedCopay = roundDouble(appliedCopay);

        // Set the co-payment for the activity and log outcome
        $act.setCopayment(appliedCopay);
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied co-payment for auditing
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the co-payment claim total and activity
        $coPayment.setClaimTotal($claimTotal + appliedCopay);
        update($act);
        update($coPayment);
    } else {
        // If no ceiling, simply apply the co-payment value
        double appliedCopay = 0.0d;
        appliedCopay = roundDouble($coPayment.getValue($act.getGrossMinusDeductible(), $act.getDeductible()));

        // Set the co-payment for the activity and log outcome
        $act.setCopayment(appliedCopay);
        $act.addOutcome(Severity.INFO, sRuleName, " Set coPayment to " + appliedCopay + ".", "");

        // Log the applied co-payment for auditing
        if ($c.logInfo) {
            logInfo(sRuleName, " Set coPayment to " + appliedCopay + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity
        update($act);
    }
end

rule 'CUS_PROC_LIST_PRICE'
dialect 'mvel'
salience -102

when
    // Matching Claim with non-null CUS_ID and no primary/secondary/tertiary/fourth procedures set
    $c: Claim($CUS_ID: CUS_ID, CUS_ID != null, primaryProc == null,
        secondaryProc == null, thirdProc == null, forthProc == null)

    // Matching CusContract based on CUS_ID and procedure conditions
    CusContract(ID.intValue() == $CUS_ID.intValue(),
        multipleProcedure != null, multipleProcedure == 1,
        (primaryProcedure != null && primaryProcedure > 0) ||
        (secondaryProcedure != null && secondaryProcedure > 0) ||
        (thirdProcedure != null && thirdProcedure > 0) ||
        (forthProcedure != null && forthProcedure > 0),
        $priceListId: priceListId, $primaryProcedure: primaryProcedure,
        $secondaryProcedure: secondaryProcedure,
        $thirdProcedure: thirdProcedure,
        $forthProcedure: forthProcedure)

then
    // Log the rule execution if logging is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            "Set multiple Procedure percentage(s), From Cus_ID=" + $CUS_ID);
    }

    // Set primary, secondary, tertiary, and fourth procedures based on values from CusContract
    $c.setPrimaryProc($primaryProcedure != null && $primaryProcedure > 0 ? $primaryProcedure : null);
    $c.setSecondaryProc($secondaryProcedure != null && $secondaryProcedure > 0 ? $secondaryProcedure : null);
    $c.setThirdProc($thirdProcedure != null && $thirdProcedure > 0 ? $thirdProcedure : null);
    $c.setForthProc($forthProcedure != null && $forthProcedure > 0 ? $forthProcedure : null);

    // Add outcome indicating the procedures were set
    $c.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Set multiple Procedure percentage(s), From Cus_ID=" + $CUS_ID.intValue() + ".", "");

    // Update the Claim object with the new procedures
    update($c);
end

rule 'DEDUCTIBLE_CONSULTATION_EXCLUDING_MATERNITY_EM'
dialect 'mvel'
salience -1515

when
    // Matching Claim with a patient and provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Matching ClaimType that is not Maternity
    ClaimType(type != ClaimType.Maternity) from $c.claimType
    
    // Matching Encounter with type 1 or 2
    Encounter($encType: type, type in (1, 2)) from $c.encounter
    
    // Matching Deductible with type "Consultation Excluding Maternity Consultation", positive value
    $deductible: Deductible(type == "Consultation Excluding Maternity Consultation", value > 0, $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Matching Activity with valid gross value, deductible null, and proper clinician status
    $act: Activity(
        type == CodeType.CPT, 
        deductible == null, 
        hasDoubleValue(gross), 
        $gross: gross,
        $groups: activityGroup, 
        $clinician: clinician,
        clinician not matches "GN.*",
        clinician not matches "GP.*",
        clinician not matches "T.*",
        clinician not matches "GT.*",
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )
    
    // Matching ActivityGroup of type "Evaluation And Management"
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Evaluation And Management") from $groups;
    
    // Calculate maximum gross value from activities with no deductible
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null) and
        ActivityGroup(type == CodeType.CPT.getValue(), name == "Evaluation And Management") from $a.activityGroup,
        max($a.gross)
    )
    
    // Count of applied Deductible from the same type
    accumulate(
        Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
        $countOfActs: count($code)
    )
    
    // Ensure the rule only fires if this activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Rule name for logging
    String sRuleName = drools.getRule().getName();
    
    // If ceiling is defined
    if (hasDoubleValue($ceiling)) {
        // Process with ceiling-based deductible
        double appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        $act.setDeductible(appliedDeductible);
        
        // Add outcome and log details
        $act.addOutcome(Severity.INFO, sRuleName, "Set deductible to " + appliedDeductible + ".", "");
        if ($c.logInfo) {
            logInfo(sRuleName, "Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update claim total and deductible
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // Apply fixed deductible value
        double appliedDeductible = roundDouble($value);
        
        // Ensure deductible doesn't exceed gross amount
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Update claim total and reset deductible if necessary
        $claimTotal = $claimTotal + appliedDeductible;
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        // Set deductible and log details
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, 
            "Set deductible to " + appliedDeductible + 
            ". max gross=" + $maxGross + ". gross: " + $gross + " countOfActs: " + $countOfActs + " claimTotal: " + $claimTotal,
            "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, "Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update activity
        update($act);
    }

end

rule 'DEDUCTIBLE_CONSULTATION_EXCLUDING_MATERNITY_NOT_EM'
dialect 'mvel'
salience -1513

when
    // Match a Claim with non-null patient and provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Match ClaimType excluding "Maternity" type
    ClaimType(type != ClaimType.Maternity) from $c.claimType
    
    // Match Encounter with specific types (1 or 2)
    Encounter($encType: type, type in (1, 2)) from $c.encounter
    
    // Match Deductible with specific type and conditions
    $deductible: Deductible(type == "Consultation Excluding Maternity Consultation", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match Activity with specific conditions and gross value
    $act: Activity(type == CodeType.SERVICE, hasDoubleValue(gross), $gross: gross, deductible == null,
                   $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || 
                                                      $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match ActivityGroup for consultations
    ActivityGroup(type.intValue() == CodeType.SERVICE.getValue(), name == "Consultations") from $act.activityGroup
    
    // Calculate maximum gross value from the activities
    $maxGross: Double() from accumulate(
       $a: Activity(hasDoubleValue(gross), deductible == null),
       max($a.gross)
    )
    
    // Count the applied deductible from activities of the same type
    accumulate(Activity(hasDoubleValue(deductible), deductible == $value, $code: code), $countOfActs: count($code))
    
    // Ensure that this activity group hasn't been processed yet
    eval($countOfActs < 1 && $maxGross == $gross)
    
then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If a ceiling value exists, process with it
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        
        // Apply the deductible based on the ceiling
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);
        
        // Set the deductible and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() +
                     " code=" + $act.getCode());
        }
        
        // Update the deductible and claim totals
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling exists, apply the deductible directly
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure the applied deductible does not exceed the gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Update the claim total and check the condition
        $claimTotal = $claimTotal + appliedDeductible;
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }
        
        // Set and log the deductible value
        $deductible.setClaimTotal($claimTotal);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + 
                        ". max gross=" + $maxGross + ". gross: " + $gross + " countOfActs: " + $countOfActs +
                        " claimTotal: " + $claimTotal, "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() +
                     " code=" + $act.getCode());
        }
        
        // Update the activity and deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_DENTAL_CONSULTATION'
// Define the dialect as MVEL for rule execution  
dialect "mvel"

// Rule priority: -1517 (executes after higher-priority rules)  
salience -1517  

when  
    // Match a Claim where:
    // - Patient is not null  
    // - Provider ID is matched
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)  

    // Ensure the claim type is "Dental"
    ClaimType(type == ClaimType.Dental) from $c.claimType  

    // Match encounters of type 1 or 2
    Encounter($encType: type, type in (1, 2)) from $c.encounter  

    // Match a **Dental Consultation Deductible** where:
    // - Type is "Dental Consultation"
    // - Value is greater than 0
    // - Extract ceiling, claim total, and deductible value  
    $deductible: Deductible(type == "Dental Consultation", value > 0,  
        $ceiling: ceiling, $claimTotal: claimTotal, $value: value)  

    // Match an **Activity** with:
    // - Type "DENTAL"
    // - Valid gross value
    // - No existing deductible
    // - Order status is either "CM" or "Completed"
    // - Belongs to the "Dental Consultation" activity group
    $act: Activity(type == CodeType.DENTAL, hasDoubleValue(gross), deductible == null,  
        $groups: activityGroup, $gross: gross, 
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm"  
        || $act.getOrderStatus().toLowerCase() == "completed"))  
    ActivityGroup(type == CodeType.DENTAL.getValue(), name == "Dental Consultation") from $groups;  

    // Calculate the maximum gross value among all eligible activities
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    )  

    // Count the number of previously applied deductibles of the same type
    accumulate(
        Activity(hasDoubleValue(deductible), deductible == $value, $code: code),  
        $countOfActs: count($code)
    )  

    // Ensure we only process the activity if:
    // - No other deductible of this type has been applied
    // - This activity has the highest gross value  
    eval($countOfActs < 1 && $maxGross == $gross)  

then  
    //================ Deductible Calculation ================  
    String sRuleName = drools.getRule().getName();  

    // Case 1: Deductible has a Ceiling
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {  
        double futureDeductibleTotal = $claimTotal + $value;  
        double appliedDeductible = 0.0d;  

        // If the future deductible exceeds the ceiling, apply the ceiling limit
        if (futureDeductibleTotal > $ceiling) {  
            appliedDeductible = $ceiling - $claimTotal;  
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;  
        } else {  
            appliedDeductible = $value;  
        }  

        // Round the deductible value  
        appliedDeductible = roundDouble(appliedDeductible);  

        // Apply the deductible to the activity
        $act.setDeductible(appliedDeductible);  
        $act.addOutcome(Severity.INFO, sRuleName,  
            " Set deductible to " + appliedDeductible + ".", "");  

        // Logging
        if ($c.logInfo) {  
            logInfo(sRuleName,  
                " Set deductible to " + appliedDeductible +  
                " For Activity=" + $act.getIdCaller() +  
                " code=" + $act.getCode());  
        }  

        // Update claim total with applied deductible
        $deductible.setClaimTotal($claimTotal + appliedDeductible);  

        // Update working memory
        update($act);  
        update($deductible);  

    } else {  
        // Case 2: Standard Deductible Calculation (No Ceiling)  
        double appliedDeductible = 0.0d;  

        // Round the deductible value
        appliedDeductible = roundDouble($value);  

        // Ensure deductible does not exceed gross amount  
        if (appliedDeductible > $gross) {  
            appliedDeductible = $gross;  
        }  

        // Apply the deductible to the activity  
        $act.setDeductible(appliedDeductible);  
        $act.addOutcome(Severity.INFO, sRuleName,  
            " Set deductible to " + appliedDeductible + ".", "");  

        // Logging  
        if ($c.logInfo) {  
            logInfo(sRuleName,  
                " Set deductible to " + appliedDeductible +  
                " For Activity=" + $act.getIdCaller() +  
                " code=" + $act.getCode());  
        }  

        // Update working memory
        update($act);  
    }  

end

rule 'DEDUCTIBLE_DENTAL_EXCLUDING_DCONSULTATION'
dialect 'mvel'
salience -1519
when
    // Fetch the Claim object where the patient and provider details are not null
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Ensure the Claim type is "Dental"
    ClaimType(type == ClaimType.Dental) from $c.claimType

    // Check if the Encounter type is either 1 or 2 (assuming 1 and 2 correspond to certain types like consultation or treatment)
    Encounter($encType: type, type in (1, 2)) from $c.encounter
    
    // Fetch the Deductible object with the type "Dental Excluding Dental Consultation" and value greater than 0
    $deductible: Deductible(type == "Dental Excluding Dental Consultation", value > 0, 
        $ceiling: ceiling, $claimTotal: claimTotal, $value: value)

    // Get the Activity object related to a dental procedure
    $act: Activity(type == CodeType.DENTAL, hasDoubleValue(gross), $gross: gross, deductible == null, 
        $groups: activityGroup,
        // Ensure the order status is either 'cm' or 'completed'
        $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Ensure that the activity does not belong to the "Dental Consultation" group
    not(ActivityGroup(type == CodeType.DENTAL.getValue(), name == "Dental Consultation") from $groups)
    
then
    // Get the rule name for logging purposes
    String sRuleName = drools.getRule().getName();

    // Case 1: If the deductible has a ceiling
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the future deductible total (current total + deductible value)
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;

        // Check if the future deductible exceeds the ceiling
        if (futureDeductibleTotal > $ceiling) {
            // If it exceeds, apply only the ceiling amount minus the current claim total
            appliedDeductible = $ceiling - $claimTotal;
            // Ensure deductible is positive (in case of negative calculation)
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            // Otherwise, apply the deductible value directly
            appliedDeductible = $value;
        }

        // Round the deductible value
        appliedDeductible = roundDouble(appliedDeductible);

        // Set the deductible on the activity
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log the deductible amount if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the deductible total on the deductible object
        $deductible.setClaimTotal($claimTotal + appliedDeductible);

        // Update the activity and deductible objects
        update($act);
        update($deductible);
    } else {
        // Case 2: Standard deductible calculation (no ceiling)
        double appliedDeductible = 0.0d;
        
        // Round the deductible value
        appliedDeductible = roundDouble($value);
        
        // Ensure the deductible is not greater than the gross value of the activity
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Set the calculated deductible on the activity
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log the applied deductible if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity with the applied deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_DENTAL_EXCLUDING_ORTHODONTIC_PROSTHESIS'
dialect 'mvel'
salience -1523

when
    // Match a Claim with a non-null patient and provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Match ClaimType as "Dental"
    ClaimType(type == ClaimType.Dental) from $c.claimType
    
    // Match Encounter with types 1 or 2
    Encounter($encType: type, type in (1, 2)) from $c.encounter
    
    // Match Deductible with type "Dental Excluding Orthodontic & Prosthesis" and value > 0
    $deductible: Deductible(type == "Dental Excluding Orthodontic & Prosthesis", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match Activity of type CodeType.DENTAL with gross value, no existing deductible, and valid order status
    $act: Activity(type == CodeType.DENTAL, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Exclude certain activity groups like orthodontic and prosthodontics
    not(ActivityGroup(type == CodeType.DENTAL.getValue(), 
                      name == "Orthodontic Procedures" || 
                      name == "Prosthodontics_removable" || 
                      name == "Prosthodontics_fixed") from $groups)
    
then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If ceiling exists and is greater than 0
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;
        
        // Apply deductible based on the ceiling value
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            appliedDeductible = $value;
        }
        
        // Round the deductible value
        appliedDeductible = roundDouble(appliedDeductible);
        
        // Set the deductible for the activity and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the deductible and claim totals
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling exists, apply deductible based on gross value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure the deductible doesn't exceed the gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Set the deductible and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the new deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_DENTAL_ORTHODONTIC_PROSTHESIS'
dialect 'mvel'
salience -1521

when
    // Match a Claim with a patient and provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Match ClaimType as Dental
    ClaimType(type == ClaimType.Dental) from $c.claimType
    
    // Match Encounter with type in (1, 2)
    Encounter($encType: type, type in (1, 2)) from $c.encounter
    
    // Match Deductible for "Dental Orthodontic & Prosthesis" with value greater than 0
    $deductible: Deductible(type == "Dental Orthodontic & Prosthesis", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match Activity with type DENTAL, gross value, and no existing deductible
    $act: Activity(type == CodeType.DENTAL, hasDoubleValue(gross), $gross: gross, 
                   deductible == null, $groups: activityGroup, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || 
                    $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match Activity Group of type "DENTAL" and one of the specified procedure names
    ActivityGroup(type == CodeType.DENTAL.getValue(), 
                  name == "Orthodontic Procedures" || 
                  name == "Prosthodontics_removable" || 
                  name == "Prosthodontics_fixed") from $groups;

then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If a ceiling value is provided and is greater than 0, apply deductible considering the ceiling
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;
        
        // If the future deductible exceeds the ceiling, apply the ceiling as the deductible
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            appliedDeductible = $value;
        }
        
        // Round the deductible and apply it to the activity
        appliedDeductible = roundDouble(appliedDeductible);
        $act.setDeductible(appliedDeductible);
        
        // Add outcome and log the deductible application
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the deductible and claim totals
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling value is provided, apply deductible based on the gross value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure the deductible doesn't exceed the gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Set the deductible for the activity and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the new deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_EM_INCLUDING_DIAGNOSTIC'
dialect 'mvel'
salience -1529

when
    // Match a Claim with patient and provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Match Encounter type 1 or 2 for the claim
    Encounter($encType: type, type in (1,2)) from $c.encounter
    
    // Match Deductible for "Consultation including Diagnostic" type with value greater than 0
    $deductible: Deductible(type == "Consultation including Diagnostic", value > 0, 
                             $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Accumulate diagnostic activities of type CPT and belonging to the "DGTest_CPT_9_Series" activity group
    $diagnostic_acts: Set(size > 0) from accumulate( 
        $diagnostic_act: Activity(type == CodeType.CPT, $diagnostic_act_groups: activityGroup)
        and
        ActivityGroup(type == CodeType.CPT.getValue(), name == "DGTest_CPT_9_Series") from $diagnostic_act_groups;
        collectSet($diagnostic_act)
    )
    
    // Match Activity of type CPT with certain conditions (gross, deductible, etc.)
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match Activity Group with name "Evaluation And Management" for CPT activities
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Evaluation And Management") from $groups;
    
then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If the ceiling is not null, not NaN, and greater than 0
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        // Calculate the future deductible total
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;
        
        // Check if the future deductible total exceeds the ceiling
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            appliedDeductible = $value;
        }
        
        appliedDeductible = roundDouble(appliedDeductible);
        
        // Set the deductible for the activity
        $act.setDeductible(appliedDeductible);
        
        // Add an outcome indicating the deductible was set
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        // If log info is enabled, log the action
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() +
                    " code=" + $act.getCode());
        }
        
        // Update the deductible total
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        
        // Update the activity and deductible
        update($act);
        update($deductible);
    } else {
        // If there's no ceiling, calculate the deductible based on the value and gross
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // If the deductible exceeds the gross value, adjust it to match the gross
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Set the deductible for the activity
        $act.setDeductible(appliedDeductible);
        
        // Add an outcome indicating the deductible was set
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        // If log info is enabled, log the action
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() +
                    " code=" + $act.getCode());
        }
        
        // Update the activity with the new deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_EM_EXCLUDING_DIAGNOSTIC'
dialect 'mvel'
salience -1531

when
    // Match a Claim with a patient and provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Match Encounter with type in (1, 2)
    Encounter($encType: type, type in (1, 2)) from $c.encounter
    
    // Match Deductible for "Consultation excluding Diagnostic" with value greater than 0
    $deductible: Deductible(type == "Consultation excluding Diagnostic", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Accumulate set of diagnostic activities under "DGTest_CPT_9_Series" group
    $diagnostic_acts: Set(size <= 0) from accumulate ( 
        $diagnostic_act: Activity(type == CodeType.CPT, $diagnostic_act_groups: activityGroup)
        and
        ActivityGroup(type == CodeType.CPT.getValue(), name == "DGTest_CPT_9_Series") from $diagnostic_act_groups;
        collectSet($diagnostic_act)
    )
    
    // Match Activity with type CPT, gross value, and no existing deductible
    $act: Activity(type == CodeType.CPT, 
                   hasDoubleValue(gross), $gross: gross, deductible == null, $groups: activityGroup, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || 
                    $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match Activity Group "Evaluation And Management"
    ActivityGroup(type == CodeType.CPT.getValue(), 
                  name == "Evaluation And Management") from $groups;
    
then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If a ceiling value is provided and is greater than 0, apply deductible considering the ceiling
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;
        
        // If the future deductible exceeds the ceiling, apply the ceiling as the deductible
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            appliedDeductible = $value;
        }
        
        // Round the deductible and apply it to the activity
        appliedDeductible = roundDouble(appliedDeductible);
        $act.setDeductible(appliedDeductible);
        
        // Add outcome and log the deductible application
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the deductible and claim totals
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling value is provided, apply deductible based on the gross value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure the deductible doesn't exceed the gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Set the deductible for the activity and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                    " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the new deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_MATERNITY_CONSULTATION_EM'
dialect 'mvel'
salience -1511

when
    // Match a Claim with a non-null patient and provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Match ClaimType as "Maternity"
    ClaimType(type == ClaimType.Maternity) from $c.claimType
    
    // Match Encounter with types 1 or 2
    Encounter($encType: type, type in (1, 2)) from $c.encounter
    
    // Match Deductible with type "Maternity Consultation" and value > 0
    $deductible: Deductible(type == "Maternity Consultation", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match Activity of type CodeType.CPT, with gross value, no existing deductible, and valid clinician excluding certain types
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, $clinician: clinician,
                   clinician not matches "GN.*", clinician not matches "GP.*", clinician not matches "T.*", clinician not matches "GT.*", 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match ActivityGroup with name "Evaluation And Management" for CodeType.CPT
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Evaluation And Management") from $groups;
    
then
    // Get the rule name
    String sRuleName = drools.getRule().getName();
    
    // If ceiling exists and is greater than 0
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;
        
        // Apply deductible based on the ceiling value
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            appliedDeductible = $value;
        }
        
        // Round the deductible value
        appliedDeductible = roundDouble(appliedDeductible);
        
        // Set the deductible for the activity and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the deductible and claim totals
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling exists, apply deductible based on gross value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        
        // Ensure the deductible doesn't exceed the gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        // Set the deductible and log the action
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        // Update the activity with the new deductible
        update($act);
    }

end

rule 'DEDUCTIBLE_MATERNITY_CONSULTATION_NOT_EM'
dialect 'mvel'
salience -1509

when
    // Match Claim with non-null patient and provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Ensure the claim is of Maternity type
    ClaimType(type == ClaimType.Maternity) from $c.claimType
    
    // Match Encounter of type 1 or 2
    Encounter($encType: type, type in (1, 2)) from $c.encounter
    
    // Match Deductible of type "Maternity Consultation" and ensure value is greater than 0
    $deductible: Deductible(type == "Maternity Consultation", value > 0, $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Match Activity of type SERVICE, with gross value and no deductible applied
    $act: Activity(type == CodeType.SERVICE, hasDoubleValue(gross), $gross: gross, deductible == null,
                   $act.getOrderStatus() != null && ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Match ActivityGroup related to "Consultations"
    ActivityGroup(type.intValue() == CodeType.SERVICE.getValue(), name == "Consultations") from $act.activityGroup

then
    // Rule logic starts here
    String sRuleName = drools.getRule().getName();
    
    // Check if ceiling is defined and greater than 0
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;

        // If future deductible exceeds the ceiling, adjust deductible accordingly
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            appliedDeductible = $value;
        }

        // Round the calculated deductible and set it for the activity
        appliedDeductible = roundDouble(appliedDeductible);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log the deductible change
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the deductible with the new claim total
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // No ceiling; use default deductible value
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);

        // Ensure deductible does not exceed the gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Set the deductible for the activity
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log the deductible change
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity with the new deductible
        update($act);
    }
end

rule 'DEDUCTIBLE_MATERNITY_EXCLUDING_MCONSULTATION'
dialect 'mvel' // Specifies that the rule uses the MVEL dialect.

salience -1507 // Sets the rule priority to -1507, determining when it will fire.

when
    // Match a Claim object that has a non-null patient and capture the patient and providerID.
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)

    // Ensure the Claim has a "Maternity" type.
    ClaimType(type == ClaimType.Maternity) from $c.claimType

    // Match an Encounter associated with the Claim where the type is either 1 or 2.
    Encounter($encType: type, type in (1, 2)) from $c.encounter

    // Match a Deductible with type "Maternity Excluding Maternity Consultation" and value greater than 0.
    // Capture ceiling, claim total, and deductible value.
    $deductible: Deductible(type == "Maternity Excluding Maternity Consultation", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)

    // Match a Diagnosis code associated with the Claim.
    Diagnosis($dcode: code) from $c.diagnosis

    // Match a CodeGroup related to the diagnosis code, either of type ICD9 or ICD10, and belonging to
    // the "Antenatal-Screening ICD_10" or "Antenatal-Screening ICD_9" groups.
    $codeGroup: CodeGroup($codeGroupID: id, type == CodeType.ICD9 || type == CodeType.ICD10,
                          name == "Antenatal-Screening ICD_10" || name == "Antenatal-Screening ICD_9",
                          eval(containsCode($dcode) == true))

    // Match an Activity with type "CPT", a non-null gross value, no existing deductible, and specific order status.
    $act: Activity(type == CodeType.CPT, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, $clinician: clinician, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))

    // Ensure the Clinician is associated with the specified provider ID, and their profession matches "obstetrics & gynecology".
    Clinician(facility_license == $providerID, license == $clinician, 
              profession.toLowerCase() matches ".*obstetrics & gynecology.*");

then
    // Get the name of the rule for logging purposes.
    String sRuleName = drools.getRule().getName();

    // Check if a ceiling exists and is a valid positive number.
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        double futureDeductibleTotal = $claimTotal + $value; // Calculate the future deductible total.
        double appliedDeductible = 0.0d;

        // If the future deductible total exceeds the ceiling, limit the deductible.
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            // Otherwise, apply the full deductible value.
            appliedDeductible = $value;
        }

        // Round the applied deductible and update the Activity and Deductible.
        appliedDeductible = roundDouble(appliedDeductible);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log the applied deductible if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the ClaimTotal of the Deductible and apply the changes.
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act); // Update the Activity with the new deductible.
        update($deductible); // Update the Deductible with the new claim total.
    } else {
        // If no ceiling exists, apply the deductible based on the value.
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value); // Round the deductible value.

        // Ensure the deductible doesn't exceed the gross value of the Activity.
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Set the deductible on the Activity and log the outcome.
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, " Set deductible to " + appliedDeductible + ".", "");

        // Log the applied deductible if logging is enabled.
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible + 
                     " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the Activity with the applied deductible.
        update($act);
    }
end

rule 'DEDUCTIBLE_OUTPATIENT_EXCLUDING_MATERNITY'
dialect 'mvel'
salience -1505  // Defines rule priority

when
    // Select claims where the patient exists
    $c: Claim(patient != null, $patient: patient)

    // The claim type should not be "Maternity"
    ClaimType(type != ClaimType.Maternity) from $c.claimType

    // Encounter must be of type 1 or 2
    Encounter($encType: type, type in (1,2)) from $c.encounter

    // Retrieves the deductible for "Outpatient excluding Maternity" with a valid value
    $deductible: Deductible(
        type == "Outpatient excluding Maternity",
        value > 0, $ceiling: ceiling, $claimTotal: claimTotal, $value: value
    )

    // Filters activities that:
    // - Have a valid gross value
    // - Do not have a deductible assigned yet
    // - Have an order status of either "cm" or "completed"
    $act: Activity(
        hasDoubleValue(gross),
        $gross: gross,
        deductible == null,
        $act.getOrderStatus() != null && 
        ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Calculate the maximum gross value among activities
    $maxGross: Double() from accumulate(
        $a: Activity(hasDoubleValue(gross), deductible == null),
        max($a.gross)
    )

    // Count how many times this deductible type has already been applied
    accumulate(
        Activity(hasDoubleValue(deductible), deductible == $value, $code: code), 
        $countOfActs: count($code)
    )

    // Ensure the activity with the highest gross value is processed first
    eval($countOfActs < 1 && $maxGross == $gross)

then
    // Retrieve rule name for logging
    String sRuleName = drools.getRule().getName();

    // If the ceiling is valid, process with ceiling limits
    if (hasDoubleValue($ceiling)) {
        double appliedDeductible = 0.0d;
        appliedDeductible = processWithCeiling($ceiling, $claimTotal, $value);

        // Assign the deductible to the activity
        $act.setDeductible(appliedDeductible);

        // Add an informational outcome
        $act.addOutcome(Severity.INFO, sRuleName,
            " Set deductible to " + appliedDeductible + ".", "");

        // Log the deductible application
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update deductible and activity states
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);

    } else {
        // If no ceiling, apply the full deductible but not more than the gross amount
        double appliedDeductible = roundDouble($value);
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Ensure claim total does not exceed deductible value
        $claimTotal = $claimTotal + appliedDeductible;
        if ($claimTotal > $value) {
            appliedDeductible = 0.0d;
        }

        // Update deductible claim total
        $deductible.setClaimTotal($claimTotal);

        // Assign the deductible to the activity
        $act.setDeductible(appliedDeductible);

        // Add an outcome message for tracking
        $act.addOutcome(Severity.INFO, sRuleName,
            " Set deductible to " + appliedDeductible +
            ". max gross=" + $maxGross +
            ". gross :" + $gross + 
            " countOfActs: " + $countOfActs +
            " claimTotal: " + $claimTotal, "");

        // Log the deductible application
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity state
        update($act);
    }

end

rule 'DEDUCTIBLE_OUTPATIENT_EXCLUDING_PHYSIOTHERAPY'
dialect 'mvel'  // Specifies that MVEL is used for expressions
salience -1527  // Defines the rule's priority (higher values execute first)

when
    // Selects claims where the patient is not null
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)

    // Checks if the claim contains an encounter of type 1 or 2
    Encounter($encType: type, type in (1,2)) from $c.encounter

    // Retrieves the deductible for "Outpatient Excluding Physiotherapy" with a positive value
    $deductible: Deductible(
        type == "Outpatient Excluding Physiotherapy",
        value > 0, $ceiling: ceiling, $claimTotal: claimTotal, $value: value
    )

    // Filters activities that:
    // - Are NOT of type TRADE_DRUG
    // - Have a valid gross amount (double value)
    // - Do not have a deductible set yet
    // - Have an order status of either "cm" or "completed"
    $act: Activity(
        type != CodeType.TRADE_DRUG,
        hasDoubleValue(gross), deductible == null, 
        $gross: gross, $groups: activityGroup,
        $act.getOrderStatus() != null && 
        ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")
    )

    // Ensures that the activity is NOT part of the "Physical Medicine & Rehabilitation" group
    not (
        ActivityGroup(type == CodeType.CPT.getValue(), name == "Physical Medicine & Rehabilitation") 
        from $groups
    )

then
    // Retrieve the rule name for logging
    String sRuleName = drools.getRule().getName();

    // Check if the deductible ceiling is valid and greater than zero
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;

        // If adding this deductible exceeds the ceiling, adjust it
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            appliedDeductible = $value;
        }

        // Round the deductible and set it in the activity
        appliedDeductible = roundDouble(appliedDeductible);
        $act.setDeductible(appliedDeductible);

        // Add an informational outcome to the activity
        $act.addOutcome(Severity.INFO, sRuleName, 
            " Set deductible to " + appliedDeductible + ".", "");

        // Log the deductible if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the deductible claim total and save changes
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);

    } else {
        // If no ceiling is defined, apply the full deductible value but not more than the gross amount
        double appliedDeductible = 0.0d;
        appliedDeductible = roundDouble($value);
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }

        // Set the deductible in the activity
        $act.setDeductible(appliedDeductible);

        // Add an informational outcome
        $act.addOutcome(Severity.INFO, sRuleName,
            " Set deductible to " + appliedDeductible + ".", "");

        // Log the deductible if logging is enabled
        if ($c.logInfo) {
            logInfo(sRuleName, " Set deductible to " + appliedDeductible +
                " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }

        // Update the activity to reflect changes
        update($act);
    }
end

rule 'DEDUCTIBLE_SERVICE_EXCLUDING_DIAGNOSTIC'
dialect 'mvel'
// Rule Priority: Lower value means higher priority
salience -1535

when
    // Claim must have a patient and a valid provider ID
    $c:Claim(patient != null, $patient:patient, $providerID:providerID)
    
    // The claim should include an encounter of type 1 or 2
    Encounter($encType:type, type in (1,2)) from $c.encounter
    
    // Deductible for "Consultation excluding Diagnostic" with a positive value
    $deductible:Deductible(type=="Consultation excluding Diagnostic", value>0, 
        $ceiling:ceiling, $claimTotal:claimTotal, $value:value) 
    
    // Collect diagnostic activities with a specific code type, ensuring no diagnostic tests exist
    $diagnostic_acts: Set(size <= 0) from accumulate ( 
        $diagnostic_act: Activity( type==CodeType.CPT, $diagnostic_act_groups:activityGroup)
        and
        ActivityGroup( type==CodeType.CPT.getValue(),  name=="DGTest_CPT_9_Series") from $diagnostic_act_groups;
        collectSet($diagnostic_act)
    ) 
    
    // Activity must be a service, have a valid gross value, and no deductible assigned yet
    $act: Activity( type==CodeType.SERVICE, 
        hasDoubleValue(gross),$gross:gross, deductible == null, $groups:activityGroup,
        $act.getOrderStatus()!=null && ($act.getOrderStatus().toLowerCase()=="cm" || $act.getOrderStatus().toLowerCase()=="completed"))
    
    // Ensure the activity belongs to "Consultations"
    ActivityGroup( type.intValue()==CodeType.SERVICE.getValue(), 
        name=="Consultations") from $groups
then
    // Capture rule name
    String sRuleName = drools.getRule().getName();
    
    if($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d){
        // Calculate the future total deductible amount
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;
        
        // If the future deductible exceeds the ceiling, adjust it accordingly
        if (futureDeductibleTotal > $ceiling){
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            appliedDeductible = $value;
        }
        
        // Round deductible value
        appliedDeductible = roundDouble(appliedDeductible);
        
        // Set deductible and add outcome message
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName ,
            "Set deductible to " + appliedDeductible + ".", "");
        
        // Log the deductible action
        if($c.logInfo){
            logInfo(sRuleName,"Set deductible to " + appliedDeductible +
                " For Activity="+$act.getIdCaller()+" code="+$act.getCode());
        }
        
        // Update claim total deductible
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        
        // Update objects in working memory
        update($act);
        update($deductible);
    } else {
        // Default deductible logic if no ceiling is defined
        double appliedDeductible = roundDouble($value);
        
        // Ensure deductible does not exceed gross amount
        if (appliedDeductible > $gross){
            appliedDeductible = $gross;
        }
        
        // Apply deductible and add outcome
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName ,
            "Set deductible to " + appliedDeductible + ".", "");
        
        // Log action
        if($c.logInfo){
            logInfo(sRuleName,"Set deductible to " + appliedDeductible +
                " For Activity="+$act.getIdCaller()+" code="+$act.getCode());
        }
        
        // Update activity in working memory
        update($act);
    }
end

rule 'DEDUCTIBLE_SERVICE_INCLUDING_DIAGNOSTIC'
dialect 'mvel'

// Lower priority rule execution
salience -1533

when
    // Match a claim with a valid patient and provider ID
    $c: Claim(patient != null, $patient: patient, $providerID: providerID)
    
    // Match an encounter with type 1 or 2
    Encounter($encType: type, type in (1,2)) from $c.encounter
    
    // Match a deductible of type 'Consultation including Diagnostic' with a positive value
    $deductible: Deductible(type == "Consultation including Diagnostic", value > 0, 
                            $ceiling: ceiling, $claimTotal: claimTotal, $value: value)
    
    // Collect all diagnostic activities under 'DGTest_CPT_9_Series'
    $diagnostic_acts: Set(size > 0) from accumulate (
        $diagnostic_act: Activity(type == CodeType.CPT, $diagnostic_act_groups: activityGroup)
        and
        ActivityGroup(type == CodeType.CPT.getValue(), name == "DGTest_CPT_9_Series") from $diagnostic_act_groups;
        collectSet($diagnostic_act)
    )
    
    // Match a service-type activity with gross value and null deductible
    $act: Activity(type == CodeType.SERVICE, hasDoubleValue(gross), $gross: gross, deductible == null, 
                   $groups: activityGroup, 
                   $act.getOrderStatus() != null && 
                   ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed"))
    
    // Ensure the activity belongs to the 'Consultations' group
    ActivityGroup(type.intValue() == CodeType.SERVICE.getValue(), name == "Consultations") from $groups

then
    String sRuleName = drools.getRule().getName();
    
    // If a deductible ceiling is defined, apply limits
    if ($ceiling != null && !$ceiling.isNaN() && $ceiling > 0.0d) {
        double futureDeductibleTotal = $claimTotal + $value;
        double appliedDeductible = 0.0d;
        
        // Ensure deductible does not exceed ceiling
        if (futureDeductibleTotal > $ceiling) {
            appliedDeductible = $ceiling - $claimTotal;
            appliedDeductible = appliedDeductible < 0 ? -1 * appliedDeductible : appliedDeductible;
        } else {
            appliedDeductible = $value;
        }
        
        appliedDeductible = roundDouble(appliedDeductible);
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, "Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, "Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        $deductible.setClaimTotal($claimTotal + appliedDeductible);
        update($act);
        update($deductible);
    } else {
        // If no ceiling, apply full deductible value
        double appliedDeductible = roundDouble($value);
        
        // Ensure deductible does not exceed gross value
        if (appliedDeductible > $gross) {
            appliedDeductible = $gross;
        }
        
        $act.setDeductible(appliedDeductible);
        $act.addOutcome(Severity.INFO, sRuleName, "Set deductible to " + appliedDeductible + ".", "");
        
        if ($c.logInfo) {
            logInfo(sRuleName, "Set deductible to " + appliedDeductible + " For Activity=" + $act.getIdCaller() + " code=" + $act.getCode());
        }
        
        update($act);
    }

end

rule 'DENY_DISCOUNT'
dialect 'mvel'  // Use the MVEL dialect for evaluating expressions.
salience -180   // Set the rule's priority; lower numbers mean lower priority.

when
    // Retrieve a Claim with:
    // - receiverID equal to "INS026"
    // - providerID equal to "DHA-F-0046260-C"
    $c:Claim(receiverID=="INS026", providerID=="DHA-F-0046260-C")
    
    // From the Claim's contracts, select a Contract with:
    // - packageName equal to "Network 5"
    Contract(packageName=="Network 5") from $c.contract
    
    // Retrieve an Activity that has not yet had any discount applied,
    // indicated by its discount field being null.
    $act:Activity(discount == null)
    
then
    // Log the action if logging is enabled on the Claim.
    if($c.logInfo) {
        logInfo(drools.getRule().getName(),
            " Set discount=0" +
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }
    
    // Set the discount percentage and discount amount to 0.
    $act.setDiscountPercentage(0.0d);
    $act.setDiscount(0.0d);
    
    // Add an outcome to the Activity to record that discount was set to 0.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        " Set discount=0", "");
    
    // Update the Activity in working memory so that the changes are persisted.
    update($act);
end

rule 'SPC_DRG_LIST_PRICE'
dialect 'mvel'   // The rule uses the MVEL dialect for rule evaluation.
salience -95     // Priority of the rule. This rule will be evaluated after those with higher salience.

when
    // The rule triggers when a Claim object with a non-null SPC_ID is present.
    $c: Claim($providerID:providerID, $SPC_ID:SPC_ID, SPC_ID != null)
    // Matching Facility with a specific regulator (HAAD)
    Facility(license == $providerID, regulator == Regulator.HAAD)

    // The SPCContract condition ensures that the SPCContract ID matches the SPC_ID from the Claim.
    $spcContract: SPCContract(ID.intValue() == $SPC_ID.intValue(), $BASE_RATE:BASE_RATE)

    // Ensures that the claim's contract is not in the specified excluded package names.
    Contract($packageName:packageName, packageName not in ("Enhanced LOW END Plan TC1 - TC2",
    "Enhanced MID Range Plan TC1 - TC2", 
    "Enhanced HIGH END Plan TC1 - TC2", 
    "ADNIC - TOP UP TC1", 
    "AXA TOP-UP TC1", 
    "AXA TOP-UP TC1 & TC2", 
    "NAS TOP UP TC1", 
    "NAS TOP-UP TC1", 
    "OMAN - TOP UP TC1")) from $c.contract

    // Ensures that the encounter start date is present in the claim.
    Encounter($encStart:start) from $c.encounter

    // The rule applies to activities of type IR_DRG with a null list price.
    $act: Activity(type == CodeType.IR_DRG, $code:code, $start:start, $weight1:drg_weight,drg_weight !=null, list == null)
    $DRG:DRG(code==$code, $weight:weight) 
then
    // Log the DRG list price computation with relevant details if logging is enabled for the claim.
    if($c.logInfo) {
        logInfo(drools.getRule().getName(),
                " Set DRG list price, SPC_ID=" + $SPC_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE +
                " total=" + ($weight * $BASE_RATE) +
                " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Calculate the list price for the DRG. If weight or base rate is null or less than 0, set the list price to 0.
    $act.setList(roundQuad(($weight == null || $weight < 0 ? 0.0d : 
                 ($BASE_RATE == null || $BASE_RATE < 0 ? 0.0d : ($weight * $BASE_RATE)))));
    
    // Set the discount percentage to 0 for the activity.
    $act.setDiscountPercentage(0);

    // Add an outcome to indicate that the DRG list price was set, including details of the calculation.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
                    " Set DRG list price, SPC_ID=" + $SPC_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE +
                    " total=" + ($weight * $BASE_RATE), "");
    
    // Update the activity with the newly calculated list price and discount.
    update($act);
end

rule 'CUS_DRG_LIST_PRICE'
dialect 'mvel'
salience -93

when
    // Matching Claim with non-null CUS_ID
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)
    
    // Matching Facility with a specific regulator (HAAD)
    Facility(license == $providerID, regulator == Regulator.HAAD)
    
    // Matching CusContract for the given CUS_ID and BASE_RATE
    $cusContract: CusContract(ID.intValue() == $CUS_ID.intValue(), $BASE_RATE: BASE_RATE)
    
    // Matching Contract excluding specific package names
    Contract($packageName: packageName, packageName not in ("Enhanced LOW END Plan TC1 - TC2", 
        "Enhanced MID Range Plan TC1 - TC2", "Enhanced HIGH END Plan TC1 - TC2", 
        "ADNIC - TOP UP TC1", "AXA TOP-UP TC1", "AXA TOP-UP TC1 & TC2", 
        "NAS TOP UP TC1", "NAS TOP-UP TC1", "OMAN - TOP UP TC1")) from $c.contract
    
    // Matching Encounter based on the start date
    Encounter($encStart: start) from $c.encounter
    
    // Matching Activity of type IR_DRG (Diagnosis-Related Group)
    $act: Activity(type == CodeType.IR_DRG, $code: code, $start: start, $weight1: drg_weight, drg_weight !=null, list == null)
 $DRG:DRG(code==$code, $weight:weight)

then
    // Logging the information if logInfo is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            "Set DRG list price, CUS_ID=" + $CUS_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE +
            " total=" + ($weight * $BASE_RATE) +
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Setting the list price for the Activity based on DRG weight and base rate
    $act.setList(roundQuad(($weight == null || $weight < 0 ? Double.NaN : 
        ($BASE_RATE == null || $BASE_RATE < 0 ? Double.NaN : ($weight * $BASE_RATE)))));
    
    // Setting the discount percentage to 0 (the discount logic is commented out)
    $act.setDiscountPercentage(0);

    // Adding outcome for logging purposes
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Set DRG list price, CUS_ID=" + $CUS_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE + 
        " total=" + ($weight * $BASE_RATE), "");
    
    // Updating the Activity with the calculated list price
    update($act);

end

rule 'DENY_DISCOUNT_DHA_IP_Anesthesia'
dialect 'mvel'  // Using MVEL dialect for rule evaluation.
salience -181   // Priority level of the rule. Lower values have lower priority.

when
    // Claim with providerID bound to $providerID
    $c:Claim($providerID:providerID)
    
    // Facility where license matches the providerID and regulator is DHA
    Facility(license == $providerID, regulator == Regulator.DHA)
    
    // Encounter associated with the Claim that has a type between 3 and 6 (inclusive).
    // Encounter's type is captured in $encType.
    Encounter($encType:type, type >= 3 && type <= 6) from $c.encounter
    
    // Activity of type CPT with no discount yet applied and having an associated activity group.
    $act:Activity(type == CodeType.CPT, discount == null, $groups:activityGroup)
    
    // Activity group with name "Anesthesia Discount Exclusion" and type of CPT.
    ActivityGroup(type == CodeType.CPT.getValue(), name == "Anesthesia Discount Exclusion") from $groups;
    
then
    // If logging is enabled for the Claim, log that the discount is being set to 0.
    if($c.logInfo) {
        logInfo(drools.getRule().getName(),
            " DHA-IP Anesthesia, Set discount=0" +
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }
    
    // Set the discount to 0 for the Activity.
    $act.setDiscountPercentage(0.0d);
    $act.setDiscount(0.0d);
    
    // Add an outcome indicating the discount was set to 0.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        " DHA-IP Anesthesia, Set discount=0", "");
    
    // Update the Activity in the working memory.
    update($act);

end

rule 'DENY_DISCOUNT_DHA_IP_OT'
dialect 'mvel'  // Using MVEL dialect for rule evaluation.
salience -182   // Priority of the rule, lower value indicates lower priority.

when
    // Claim with a provider ID that matches a specific facility.
    $c:Claim($providerID:providerID)
    
    // Facility with the given provider ID and regulated by DHA (Dubai Health Authority).
    Facility(license == $providerID, regulator == Regulator.DHA)
    
    // Encounter associated with the Claim, where the type is between 3 and 6.
    Encounter($encType:type, type >= 3 && type <= 6) from $c.encounter
    
    // Activity of type SERVICE with no discount and associated with an activity group.
    $act:Activity(type == CodeType.SERVICE, discount == null, $groups:activityGroup) 
    
    // Activity group that has the name "OT Discount Exclusion" and matches the service type.
    ActivityGroup(type == CodeType.SERVICE.getValue(), name == "OT Discount Exclusion") from $groups;
    
then
    // Log information when the rule is triggered, if the claim logging is enabled.
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
                " DHA-IP OT, Set discount=0" +
                " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }
    
    // Set the discount percentage and discount amount to zero for the activity.
    $act.setDiscountPercentage(0.0d);
    $act.setDiscount(0.0d);
    
    // Add an outcome to the activity indicating that the discount was set to 0.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
                    " DHA-IP OT, Set discount=0", "");
    
    // Update the activity with the changes.
    update($act);

end

rule 'FORCE_NO_PATIENT_SHARE_DCAS'
dialect 'mvel'
salience -511  // Medium priority

when
    // Check if claim is from provider "DHA-F-0000687"
    $c: Claim(providerID == "DHA-F-0000687", $providerID: providerID)

    // Check if deductible or copayment is not set
    $act: Activity(deductible == null || copayment == null)

then
    String sRuleName = drools.getRule().getName();
    String sMsg = "DCAS, Set copay and deductible to 0";

    // Log if logging is enabled
    if ($c.logInfo) {
        logInfo(sRuleName, sMsg + " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Set deductible and copayment to 0
    $act.setDeductible(0);
    $act.setCopayment(0);

    // Add outcome message
    $act.addOutcome(Severity.INFO, sRuleName, sMsg, "");

    // Update activity in working memory
    update($act);
end

rule 'CUS_DISCOUNT_OP_DENTAL'
// Define the dialect as MVEL for rule execution  
dialect "mvel"

// Rule priority: -219 (executes before lower-priority rules)
salience -219  

when  
    // Match a Claim where:
    // - CUS_DENTAL_ID is not null  
    // - Extract CUS_DENTAL_ID  
    $c: Claim($CUS_DENTAL_ID: CUS_DENTAL_ID, CUS_DENTAL_ID != null)  

    // Match an Encounter where:
    // - The type is **not between 3 and 6** (valid for this discount)  
    Encounter($encType: type, type < 3 || type > 6) from $c.encounter  

    // Match a CusContract linked to the claims CUS_DENTAL_ID  
    CusContract(ID.intValue() == $CUS_DENTAL_ID.intValue(), $OP_DISCOUNT: OP_DISCOUNT)  

    // Match an Activity that:
    // - Is **not** a **TRADE_DRUG**  
    // - Is **not** a **HCPCS**  
    // - **Must be** a **DENTAL** type  
    // - Has a **non-null price list**  
    // - The price list is **not NaN**  
    // - Has **no pre-existing discount**  
    // - Extracts the **list price and quantity**  
    $act: Activity(
        type != CodeType.TRADE_DRUG,  
        type != CodeType.HCPCS,  
        type == CodeType.DENTAL,  
        $code: code,  
        list != null,  
        !list.isNaN(),  
        discount == null,  
        $list: list,  
        $quantity: quantity  
    )  

then  
    // Calculate the OP discount, ensuring it is non-negative  
    Double opDiscount = ($OP_DISCOUNT == null || $OP_DISCOUNT < 0) ? 0.0d : $OP_DISCOUNT;  

    // Log the discount application if logging is enabled  
    if($c.logInfo) {  
        logInfo(drools.getRule().getName(),  
            "Apply discount=" + opDiscount +  
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());  
    }  

    // Set the discount percentage on the activity  
    $act.setDiscountPercentage(opDiscount);  

    // Calculate the discount value and apply it  
    $act.setDiscount(
        $act.getDiscountPercentage().isNaN() ? 0 :  
        roundDouble((($list / 100) * $act.getDiscountPercentage()) *  
        ($quantity == null || $quantity.isNaN() || $quantity < 0 ? 1 : $quantity))  
    );  

    // Add an informational outcome  
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),  
        "Apply discount=" + opDiscount, "");  

    // Update the activity in working memory  
    update($act); 
end

rule 'SPC_CODE_FACTOR'
dialect 'mvel'  // Using MVEL dialect for rule scripting
salience -70  // Set the priority of this rule (lower value means lower priority)

when
    // Condition: Match a Claim object where SPC_ID is not null and CUS_ID is null
    $c: Claim($SPC_ID: SPC_ID, SPC_ID != null, CUS_ID == null)

    // Condition: Ensure there is an Encounter associated with the Claim, and capture the start date of the encounter
    Encounter($start: start) from $c.encounter

    // Condition: Match an Activity that is not of type 'TRADE_DRUG' and has a null SPCFactor
    $act: Activity(type != CodeType.TRADE_DRUG, $type: type, $code: code, SPCFactor == null)

    // Condition: Match an SPCCodeFactor based on the SPC_ID, Activity type, and code, and check if the Encounter start date is within the date range
    $spcCodeFactor: SPCCodeFactor(priceListId.intValue() == $SPC_ID.intValue(), type == $type, code == $code,
        startDate == null || $start >= startDate,
        endDate == null || $start <= endDate)
        
then
    // Action: If logging is enabled for the Claim, log the application of the code factor
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),  // Log the rule name
            " Apply code factor=" + $spcCodeFactor.getFactor() +  // Log the factor applied
            " to Activity ID=" + $act.getIdCaller() +  // Log the Activity ID
            " code=" + $act.getCode());  // Log the code of the Activity
    }

    // Action: Set the SPCFactor for the Activity using the factor from SPCCodeFactor
    $act.setSPCFactor($spcCodeFactor.getFactor());

    // Action: Add an outcome for the Activity to record that the code factor has been applied
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        " Apply code factor=" + $spcCodeFactor.getFactor() + "", "");

    // Action: Update the Activity to persist the changes made to it
    update($act);
end

rule 'SPC_WITH_PACKAGE'
dialect 'mvel'
salience -10  // Lower priority, executed later

when
    // Ensure claim does not already have SPC_ID or CUS_ID
    $c: Claim($providerID: providerID, $receiverID: receiverID, SPC_ID == null, CUS_ID == null)

    // Check contract, ensuring package name is NOT in the restricted list
    Contract(
        $packageName: packageName,
        packageName not in (
            "Enhanced LOW END Plan TC1 - TC2",
            "Enhanced MID Range Plan TC1 - TC2",
            "Enhanced HIGH END Plan TC1 - TC2",
            "ADNIC - TOP UP TC1",
            "AXA TOP-UP TC1",
            "AXA TOP-UP TC1 & TC2",
            "NAS TOP UP TC1",
            "NAS TOP-UP TC1",
            "OMAN - TOP UP TC1"
        )
    ) from $c.contract

    // Extract encounter start date
    Encounter($start: start) from $c.encounter

    // Find matching SPC contract based on provider, receiver, package, and date
    $spcContract: SPCContract(
        insurerLicense == $receiverID,
        facilityLicense == $providerID,
        packageName != null,
        packageName.toLowerCase() == $packageName.toLowerCase(),
        (startDate == null || $start >= startDate),
        (endDate == null || $start <= endDate)
    )

then
    // Log contract application if logging is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            " Apply SPC contract ID=" + $spcContract.getID() + " Encounter start=" + $start);
    }

    // Assign SPC Contract ID to the claim
    $c.setSPC_ID($spcContract.getID());

    // Add an outcome message for tracking
    $c.addOutcome(
        Severity.INFO,
        drools.getRule().getName(),
        "Apply SPC contract ID=" + $spcContract.getID() + " Encounter start=" + $start,
        ""
    );

    // Update claim state
    update($c);
end

rule 'SPC_GROUP_FACTOR'
dialect 'mvel'  // Use the MVEL dialect for expression evaluation.
salience -80    // Set the rule's priority; lower salience means lower priority.

when
    // Retrieve a Claim that has a non-null SPC_ID.
    // Bind SPC_ID to $SPC_ID for later use.
    $c:Claim($SPC_ID:SPC_ID, SPC_ID != null)
    
    // Retrieve the Encounter from the Claim's encounter list,
    // binding its start date to $start.
    Encounter($start:start) from $c.encounter
    
    // Retrieve an Activity and bind its type and code.
    // The Activity must not already have an SPCFactor assigned.
    $act:Activity($type:type, $code:code, SPCFactor == null)
    
    // Retrieve the ActivityGroup for the Activity, filtering out groups of type TRADE_DRUG.
    // Bind the group's ID to $activityCodeGroupID and name to $activityCodeGroupName.
    ActivityGroup(type.intValue() != CodeType.TRADE_DRUG.getValue(), $activityCodeGroupID:id,
        $activityCodeGroupName:name) from $act.activityGroup
    
    // Retrieve an SPCGroupFactor where:
    // - priceListId matches the SPC_ID from the Claim.
    // - groupID matches the ActivityGroup ID.
    // - The factor's startDate is null or the encounter start date is after or equal to the startDate.
    // - The factor's endDate is null or the encounter start date is before or equal to the endDate.
    $SPCGroupFactor: SPCGroupFactor(
        priceListId.intValue() == $SPC_ID.intValue(),
        groupID.intValue() == $activityCodeGroupID.intValue(),
        startDate == null || $start >= startDate,
        endDate == null || $start <= endDate
    )
    
then
    // If logging is enabled on the Claim, log the application of the group factor.
    if($c.logInfo) {
        logInfo(drools.getRule().getName(),
            " Apply group " + $activityCodeGroupName +
            " factor=" + $SPCGroupFactor.getFactor() +
            " to Activity ID=" + $act.getIdCaller() +
            " code=" + $act.getCode());
    }
    
    // Set the Activity's SPCFactor to the factor from SPCGroupFactor.
    $act.setSPCFactor($SPCGroupFactor.getFactor());
    
    // Record an outcome on the Activity indicating that the group factor was applied.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        " Apply group " + $activityCodeGroupName +
        " factor=" + $SPCGroupFactor.getFactor(), "");
    
    // Update the Activity in the working memory.
    update($act);
end

rule 'SPC_NO_PACKAGE'
dialect 'mvel'  // Using MVEL for rule evaluation.
salience -20    // Rule priority with lower values having lower priority.

when
    // The claim must have providerID and receiverID, but no SPC_ID or CUS_ID.
    $c:Claim($providerID:providerID, $receiverID:receiverID, SPC_ID == null, CUS_ID == null)
    
    // The claim's contract must not belong to certain predefined packages.
    Contract($packageName:packageName, packageName not in ("Enhanced LOW END Plan TC1 - TC2",
                                                          "Enhanced MID Range Plan TC1 - TC2",
                                                          "Enhanced HIGH END Plan TC1 - TC2",
                                                          "ADNIC - TOP UP TC1",
                                                          "AXA TOP-UP TC1",
                                                          "AXA TOP-UP TC1 & TC2",
                                                          "NAS TOP UP TC1",
                                                          "NAS TOP-UP TC1",
                                                          "OMAN - TOP UP TC1")) from $c.contract
    
    // The claim must have an encounter with a valid start date.
    Encounter($start:start) from $c.encounter
    
    // Ensure that no SPCContract exists with matching providerID, receiverID, and valid dates.
    not(SPCContract(insurerLicense == $receiverID,
                    facilityLicense == $providerID, 
                    packageName == $packageName,
                    startDate == null || $start >= startDate,
                    endDate == null || $start <= endDate))
    
    // If no SPCContract exists, then retrieve a generic SPCContract with the specified receiverID and providerID.
    $spcContract: SPCContract(insurerLicense == $receiverID,
                              facilityLicense == $providerID, 
                              packageName == null,
                              startDate == null || $start >= startDate,
                              endDate == null || $start <= endDate)
    
then
    // Log information if enabled for the claim.
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
                " Apply SPC contract ID=" + $spcContract.getID() + " Encounter start=" + $start);
    }
    
    // Set the SPC_ID in the claim to the ID of the retrieved SPC contract.
    $c.setSPC_ID($spcContract.getID());
    
    // Clear the CUS_ID if needed (currently not used).
    //$c.setCUS_ID(null);
    
    // Add outcome indicating the SPC contract was applied.
    $c.addOutcome(Severity.INFO, drools.getRule().getName(),
                  "Apply SPC contract ID=" + $spcContract.getID() + " Encounter start=" + $start, "");
    
    // Update the claim with the new SPC_ID.
    update($c);
end

rule 'SPC_LIST_PRICE'
dialect 'mvel'  // Using MVEL dialect for rule evaluation.
salience -105   // Priority of the rule, lower value indicates lower priority.

when
    // Claim with SPC_ID that is not null.
    $c:Claim($SPC_ID:SPC_ID, SPC_ID != null)
    
    // Encounter associated with the Claim, capturing the start date of the encounter.
    Encounter($encStart:start) from $c.encounter
    
    // MasterPriceList based on the encounter start date, and the master list's ID matching the provided list.
    $spcMasterPriceList: MasterPriceList($masterListId:id, startDate == null || $encStart >= startDate,
                                         endDate == null || $encStart <= endDate)
    
    // Activity of type SERVICE or CPT with a SPCFactor applied and no predefined list price.
    $act:Activity($code:code, $type:type, $SPCFactor:SPCFactor, list == null, 
                  type == CodeType.SERVICE || type == CodeType.CPT)
    
    // MasterPriceListItem associated with the master list, matching the activity code and type.
    MasterPriceListItem(masterListId == $masterListId, type == $type, code == $code, $price:price)
    
then
    // Rule name is captured for logging.
    String sRuleName = drools.getRule().getName();
    
    // Calculating list price by multiplying the price by SPCFactor.
    double listPrice = roundDouble($price * $SPCFactor);
    
    // Log the rule and calculated list price if logging is enabled for the claim.
    if ($c.logInfo) {
        logInfo(sRuleName,
                " Set list price, factor=" + $SPCFactor + " price=" + listPrice + "");
    }
    
    // Set the list price to the calculated price, ensuring it's valid (not null or negative).
    $act.setList($price == null || $price < 0 || listPrice < 0 ? Double.NaN : roundQuad($price * $SPCFactor));
    
    // Mark the activity as having a predefined list price.
    $act.setListPricePredifined(1);
    
    // Add an outcome to the activity indicating the list price has been set.
    $act.addOutcome(Severity.INFO, sRuleName,
                    "Set list price, factor=" + $SPCFactor + " price=" + listPrice + "", "");
    
    // Update the activity with the changes made.
    update($act);

end

rule 'Set_Activity_Cash'
dialect 'mvel'               // Use the MVEL dialect for expressions.
salience -6000               // Set a very high negative salience (low priority).

when
    // Retrieve a Claim (no constraints on properties for this rule).
	$c:Claim( )
    
    // Retrieve an Activity that meets several conditions:
	$act: Activity(
	    list != null,                         // The list property must not be null.
	    !list.isNaN(),                        // Ensure the list is a valid number (not NaN).
	    $list: list,                          // Bind the list value to $list.
	    custom_Price_Types != null,           // custom_Price_Types must not be null.
	    custom_Price_Types.contains("1") ||    // custom_Price_Types must contain "1"...
	    custom_Price_Types.contains("6"),      // ...or contain "6".
	    gross != null,                        // gross must not be null.
	    $gross: gross,                        // Bind the gross value to $gross.
	    net != null,                          // net must not be null.
	    $net: net,                            // Bind the net value to $net.
	    $patientshare: patientShare,          // Bind patientShare to $patientshare.
	    patientShare != null                  // patientShare must not be null.
	)
    // Make sure that the Activity does not have an outcome with the rule name "Set_Activity_Cash"
    not(ActivityOutcome(ruleName=="Set_Activity_Cash") from $act.outcome)

then
    // If Claim logging is enabled, log information including the list price, Activity ID and code.
    if($c.logInfo){
        logInfo(drools.getRule().getName(),
            "   based on list price = " + $list + " to Activity ID=" + $act.getIdCaller()  +" code= [" + $act.getCode() + "]");
    }
    
    // Round the patient share value and store it in appliedPatientShare.
    double appliedPatientShare = roundDouble(new Double($patientshare));
    
    // Round the net value and store it in appliedNet.
    double appliedNet = roundDouble(new Double($net));
    
    // Calculate the total patient share as the sum of the patient share and net,
    // and round the result.
    Double patientShare = roundDouble(appliedPatientShare + appliedNet);
    
    // Initialize an empty message string for potential logging or outcome messages.
    String message = "";
    
    /**************/
    // Calculate special discount percentage if it exists:
    // If specialDiscountPercentage is null, use 0.0.
    // If it exists, ensure it is not NaN, and calculate the discount as (gross / 100) * specialDiscountPercentage.
    Double specialDiscount = ($act.getSpecialDiscountPercentage() == null ? 0.0d : 
        ($act.getSpecialDiscountPercentage().isNaN() ? 0.0d : roundDouble(($gross / 100) * $act.getSpecialDiscountPercentage())));
    
    // If the calculated specialDiscount is 0 or null but there is a positive specialDiscountAmount defined,
    // then use that specialDiscountAmount instead.
    if ((specialDiscount == null || specialDiscount == 0.0d) &&
        (($act.specialDiscountAmount != null) && ($act.specialDiscountAmount > 0.0d))) {
        specialDiscount = $act.getSpecialDiscountAmount();
    }
    
    /* *************** updated MUBDLA-1648 **************** */
    // If a valid special discount exists (greater than 0), apply it:
    if (specialDiscount != null && specialDiscount > 0.0d) {
        // Subtract the special discount from the patient share.
        patientShare = patientShare - specialDiscount;
        
        // Ensure that patient share does not fall below zero.
        if (patientShare < 0) {
            patientShare = 0;
        }
        
        // Update the message string to indicate that a special discount was applied.
        message = " Apply special discount [" + specialDiscount + "] to patient share. ";
    }
    
    // Set the final calculated patient share on the Activity.
    $act.setPatientShare(roundDouble(appliedPatientShare + appliedNet));
    
    // Reset the net value on the Activity to 0.0.
    $act.setNet(0.0d);
    
    // Add an outcome to the Activity indicating the patient share that was set.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        " set Patient share [" + roundDouble(appliedPatientShare + appliedNet) + "] .", "");
    
    // Update the Activity in the working memory.
    update($act);

end

rule 'Apply_Rejected_Amount'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -5010

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object (no specific conditions)
    $c: Claim()

    // Find an Activity object associated with the Claim where:
    // - 'gross' is not null and capture its value in $gross
    // - 'list' is not null and not NaN, and capture its value in $list
    // - 'custom_Price_Types' contains "2"
    // - 'net' is not null and capture its value in $net
    // - 'rejected_Amount' is not null and greater than 0.0, and capture its value in $rejected_Amount
    // - 'patientShare' is captured in $patientshare
    $act: Activity(
        gross != null, $gross: gross,
        list != null, !list.isNaN(), $list: list,
        custom_Price_Types != null, custom_Price_Types.contains("2"),
        net != null, $net: net,
        rejected_Amount != null, rejected_Amount > 0.0d, $rejected_Amount: rejected_Amount,
        $patientshare: patientShare
    )

    // Ensure there is no ActivityOutcome with ruleName "Set_Activity_Cash" in the outcome
    not(ActivityOutcome(ruleName == "Set_Activity_Cash") from $act.outcome)

    // Ensure there is no ActivityOutcome with ruleName "Apply_Rejected_Amount" in the outcome
    not(ActivityOutcome(ruleName == "Apply_Rejected_Amount") from $act.outcome)
then
    // Rule actions (RHS - Right Hand Side)

    // Log information if logging is enabled for the Claim
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), 
                "Based on list price = " + $list + " for Activity ID=" + $act.getIdCaller() + 
                " code=[" + $act.getCode() + "]");
    }

    // Round the patient share, net, and rejected amount values
    double appliedPatientShare = roundDouble($patientshare);
    double appliedNet = roundDouble($net);
    double appliedRejected_Amount = roundDouble($rejected_Amount);

    // Update the Activity's net amount by subtracting the rejected amount
    $act.setNet(appliedNet - appliedRejected_Amount);

    // Update the Activity's patient share by adding the rejected amount
    $act.setPatientShare(appliedPatientShare + appliedRejected_Amount);

    // Add an outcome to the Activity with INFO severity
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
                    "[" + appliedRejected_Amount + "] based on list price " + $list + "", "");

    // Update the Activity object in working memory
    update($act);
end

rule 'CALC_Observation_50'
dialect "mvel"
salience -5450
no-loop
when
	$c:Claim(gross==null )
	$act: Activity( net!= null, !net.isNaN(),type == CodeType.CPT,$net:net,$groups:activityGroup,   $obs:observation ) 
	//ActivityGroup( type==CodeType.CPT.getValue(), name=="Evaluation And Management", id==18) from $groups ; 
	java.util.Set(size>0) from
        collect( Observation(code=="CPT modifier",$value:value,valueType=="Modifiers", value==50) from  $obs)
then
	if($c.logInfo){
	logInfo(drools.getRule().getName(), 
		"Based on Net price= " + $net*150/100 + " to Activity ID=" + $act.getIdCaller()  +" code=" + 		$act.getCode());
	}
	
 	 
 	$act.setNet(roundDouble($net*150/100));
	 
	$act.addOutcome(Severity.INFO, drools.getRule().getName(),
		"Based on Net price= " +$net*150/100 + " to Activity ID=" + $act.getIdCaller()  +" code=" + 		$act.getCode(), "");
	update($act);
end

rule 'CALC_Observation_52'
dialect "mvel"
salience -5450
no-loop
when
	$c:Claim(gross==null )
	$act: Activity( net != null, !net.isNaN(),type == CodeType.CPT,gross != null,list != null, !list.isNaN(),$list:list, $net: net,$groups:activityGroup,   $obs:observation ) 
	//ActivityGroup( type==CodeType.CPT.getValue()) from $groups ;
	 java.util.Set(size>0) from
        collect(Observation(code=="CPT modifier",$value:value,valueType=="Modifiers",value==52) from  $obs)
then
	if($c.logInfo){
	logInfo(drools.getRule().getName(), 
		"Based on Net price = " + $net*50/100 + " to Activity ID=" + $act.getIdCaller()  +" code=" + $act.getCode());
	}
	
 	$act.setNet(roundDouble($net*50/100));
	$act.addOutcome(Severity.INFO, drools.getRule().getName(),
		"Based on Net price = " + $net*50/100 + " to Activity ID=" + $act.getIdCaller()  +" code=" + $act.getCode(), "");
	update($act);

end

rule 'LIST_PRICE_CUSTOME_CODE'
dialect 'mvel'  // Using the MVEL dialect for expressions.
salience -300   // Set rule priority; lower salience indicates lower priority.

when
    // Retrieve any Claim (no specific constraints).
    $c:Claim( )
    
    // Retrieve an Activity with:
    // - Type equal to CustomCode.
    // - Its 'list' property is null (indicating the list price hasn't been set).
    // - Bind the code to $code, type to $type, and quantity to $quantity.
    $act:Activity(type == CodeType.CustomCode, $code:code, $type:type, list == null, $quantity:quantity)
    
    // Retrieve a CustomCode object where:
    // - The code matches the activity's code.
    // - Bind its price to $price.
    CustomCode(code == $code, $price:price)
    
then
    // If logging is enabled on the Claim, log the rule execution details.
    if($c.logInfo){
        logInfo(drools.getRule().getName(),
            " Set list price  price=" + $price +
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }
    
    // Set the Activity's list price:
    // - If the price is null or negative, assign Double.NaN.
    // - Otherwise, assign the price from CustomCode.
    $act.setList($price == null || $price < 0 ? Double.NaN : roundQuad($price));
    
    // Add an outcome to the Activity indicating that the list price was set.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Set list price to Package item price=" + $price +
        " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode(), "");
    
    // Update the Activity in the working memory.
    update($act);

end

rule 'LIST_PRICE_Package_Code'
dialect 'mvel' // Specifies that the rule uses the MVEL dialect.

salience -270 // Sets the rule priority to -270, determining the rule firing order.

when
    // Match a Claim object (no conditions specified for the Claim).
    $c: Claim()

    // Match an Activity with type "Package", having a code, and null or zero package group ID.
    // Also checks that the list is null (indicating the absence of a list price).
    $act: Activity(type == CodeType.Package, $code: code, $type: type, list == null, packageGroupID == null || packageGroupID == 0)

    // Match a PackageCode with the same code as the Activity and capture the price and item level information.
    // The item level should either be null or false (indicating that the item isn't at an item level).
    PackageCode($Pcode: code, code == $code, $packagePrice: price, $itemLevel: isItemLevel, isItemLevel == null || !isItemLevel)

then
    // If logging is enabled, log the rule execution.
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), " Set list price  price=" + $packagePrice +
                " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Set the list price of the Activity to the price from the PackageCode.
    $act.setList(roundQuad($packagePrice));

    // Add an outcome for the rule execution, recording the set list price.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(), 
        "Set list price to Package item price=" + $packagePrice + 
        " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode() + 
        " itemLevel=" + $itemLevel + " Pcode:" + $Pcode, "");

    // Update the Activity object to persist the changes.
    update($act);
end

rule 'LIST_PRICE_Package_Items'
dialect 'mvel'   // The rule uses the MVEL dialect for rule evaluation.
salience -260     // The priority of the rule. Lower values imply higher priority.

when
    // The rule applies when the Claim exists.
    $c:Claim()
    
    // The rule applies to an activity with a null list price.
    $act:Activity($packageGroupID:packageGroupID, $code:code, list == null)
    
    // The rule matches if there is a PackageItemCode with the same package ID and code, and a price is provided.
    PackageItemCode($packageID:packageID, packageID == $packageGroupID, code == $code, $price:price)
    
    // The rule also matches if there is a PackageCode for the same package group ID, which has a price greater than 0.
    PackageCode(packageGroupID == $packageGroupID, $packagePrice:price, !isItemLevel, price > 0)

then
    // Log the action of setting the list price to zero.
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), 
                " Set list price price=" + 0 +  
                " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }
    
    // Set the list price of the activity to 0.
    $act.setList(0.0d);
    
    // Add an outcome indicating the action was performed.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
                    "Set list price to Package item to zero=" + 0 +  
                    " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode() +
                    " because the parent has price > 0", "");
    
    // Update the activity to reflect the changes.
    update($act);

end

rule 'LIST_PRICE_Package_Items_Child'
dialect 'mvel'   // The rule uses the MVEL dialect for rule evaluation.
salience -280     // The priority of the rule. Lower values imply higher priority.

when
    // The rule applies to any Claim.
    $c:Claim()
    
    // The activity associated with the claim must have a null list price and certain package details.
    $act:Activity($packageGroupID:packageGroupID, $code:code, list == null)
    
    // The PackageCode is checked for a matching package group and price.
    PackageCode(packageGroupID == $packageGroupID, $packagePrice:price, isItemLevel)
    
    // The rule looks for a matching PackageItemCode that matches the code and package group, and the price must be greater than 0.
    PackageItemCode($packageID:packageID, packageID == $packageGroupID, code == $code, $price:price, price > 0)

then
    // If logging is enabled, log the rule's action.
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(), " Set list price  price=" + $price +
                " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }
    
    // Set the list price of the activity to the found package price.
    $act.setList(roundQuad($price));
    
    // Add an outcome indicating the price change.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(), "Set list price to Package item to price=" + $price + 
                    " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode() + " Package Id " + $packageID + "$packageGroupID " + $packageGroupID, "");
    
    // Update the activity with the new list price.
    update($act);
end

rule 'LIST_PRICE_Package_Items_Parent'
dialect 'mvel'  // Using MVEL dialect for rule scripting
salience -290  // Set the priority of this rule (lower value means lower priority)

when
    // Condition: Match any Claim object (no conditions specified for Claim)
    $c: Claim()

    // Condition: Match an Activity with a null 'list' and retrieve packageGroupID and code
    $act: Activity($packageGroupID: packageGroupID, $code: code, list == null)

    // Condition: Match a PackageCode with the same packageGroupID, price, and code, and ensure it's an item level
    PackageCode(packageGroupID == $packageGroupID, $packagePrice: price, isItemLevel, $code == code)

then
    // Action: If logging is enabled for the Claim, log the action of setting the list price to 0
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),  // Log the rule name
            " Set list price to 0 to Activity ID=" + $act.getIdCaller() +  // Log the Activity ID
            " code=" + $act.getCode());  // Log the code of the Activity
    }

    // Action: Set the list price of the Activity to 0
    $act.setList(0.0d);

    // Action: Add an outcome to the Activity with the applied list price change
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Set list price to 0 to Activity ID=" + $act.getIdCaller() + 
        " code=" + $act.getCode() + " $packageGroupID " + $packageGroupID, "");

    // Action: Update the Activity to reflect the changes made to it
    update($act);
end







rule 'CALC_Cash_ACTIVITY_NET'
// Rule definition with MVEL dialect
dialect "mvel"

// Set rule priority (lower values execute first)
salience -4400

// Prevent rule from looping (no re-evaluation if the rule modifies working memory)
no-loop

// Rule conditions (LHS - Left Hand Side)
when
    // Find a Claim object and capture providerID and receiverID
    $c: Claim($providerID: providerID, $receiverID: receiverID)

    // Find a Facility object where:
    // - license matches the providerID from the Claim
    // - receiverID is in a specific list and regulator matches HAAD or DHA
    Facility(
        license == $providerID,
        ($receiverID in ("HAAD", "SP001", "CC1471") && regulator == Regulator.HAAD) ||
        ($receiverID in ("SELFPAY-DHA", "CC1471") && regulator == Regulator.DHA)
    )

    // Find an Activity object where:
    // - gross is a valid double value and capture it in $gross
    // - net is null, NaN, or greater than 0.0
    $act: Activity(hasDoubleValue(gross), $gross: gross, net == null || net.isNaN() || net > 0.0d)
then
    // Rule actions (RHS - Right Hand Side)

    // Calculate specialDiscount based on specialDiscountPercentage or specialDiscountAmount
    Double specialDiscount = ($act.getSpecialDiscountPercentage() == null ? 0.0d :
        ($act.getSpecialDiscountPercentage().isNaN() ? 0.0d :
            roundDouble(($gross / 100) * $act.getSpecialDiscountPercentage())
    ));

    // If specialDiscount is 0 and specialDiscountAmount exists, use specialDiscountAmount
    if ((specialDiscount == null || specialDiscount == 0.0d) &&
        ($act.specialDiscountAmount != null && $act.specialDiscountAmount > 0.0d)) {
        specialDiscount = $act.getSpecialDiscountAmount();
    }

    // Initialize a message variable for logging and outcomes
    String message = "";

    // Calculate patientShare as the gross amount
    double patientShare = roundDouble($gross);

    // If specialDiscount is valid, adjust patientShare and prepare a message
    if (specialDiscount != null && specialDiscount > 0.0d) {
        patientShare = patientShare - specialDiscount;
        $act.setSpecialDiscountAmount(roundDouble(specialDiscount));
        message = "Apply special discount amount [" + $act.getSpecialDiscountAmount() + "] to patient share.";
    }

    // Ensure patientShare is not negative
    if (patientShare < 0) {
        patientShare = 0;
    }

    // Handle the Activity based on its OrderStatus
    if ($act.getOrderStatus() != null &&
        ($act.getOrderStatus().toLowerCase() == "cm" || $act.getOrderStatus().toLowerCase() == "completed")) {
        // If OrderStatus is "Completed" or "CM":
        if ($c.logInfo) {
            logInfo(drools.getRule().getName(),
                "Set patientShare=" + patientShare + " net=0 For cash Activity=" + $act.getIdCaller() +
                " code=" + $act.getCode());
        }
        message = "Order Status: Completed, " + message;
        $act.addOutcome(Severity.INFO, drools.getRule().getName(),
            "Self pay: patientShare=" + patientShare + " net=0 " + message, "");
        $act.setCopayment(patientShare);
        $act.setDeductible(0.0d);
        $act.setPatientShare(patientShare);
        $act.setNet(0.0d);
    } else {
        // If OrderStatus is not "Completed" or "CM":
        if ($c.logInfo) {
            logInfo(drools.getRule().getName(),
                "Set patientShare=0 net=0 For cash Activity=" + $act.getIdCaller() +
                " code=" + $act.getCode() + " Order Status: Not Completed");
        }
        message = "Order Status: Not Completed, " + message;
        $act.addOutcome(Severity.INFO, drools.getRule().getName(),
            "Self pay: patientShare=0 net=0 " + message, "");
        $act.setCopayment(0.0d);
        $act.setDeductible(0.0d);
        $act.setPatientShare(0.0d);
        $act.setNet($gross);
    }

    // Update the Activity object in working memory
    update($act);
end

rule 'CUS_DRG_LIST_IP_RESET'
dialect 'mvel'
salience -446
no-loop

when
    // Matching Claim with non-null CUS_ID
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)
    
    // Matching Facility with regulator DHA
    Facility(license == $providerID, regulator == Regulator.DHA)
    
    // Matching CusContract for the given CUS_ID, BASE_RATE and IP_DRGFactor
    $cusContract: CusContract(ID.intValue() == $CUS_ID.intValue(), $BASE_RATE: BASE_RATE, $ipDRGFactor: IP_DRGFactor)
    
    // Matching Encounter types 3 and 4
    Encounter(type in (3, 4)) from $c.encounter
    
    // Ensuring that an Activity with type 'IR_DRG' exists with custom_Price_Types == "8" and a non-null list
    exists(Activity(type == CodeType.IR_DRG, $code: code, list != null))
    
    // Accumulating a list of excluded codes from DRGExcludedCpts for the matching Activities
    accumulate(a: Activity() 
        and DRGExcludedCpts(code == a.code), $ExcludedCodes: collectList(a.code))
    
    // Matching other Activities of non-IR_DRG type with certain conditions
    $act: Activity(type != CodeType.IR_DRG, 
        code not in ("98", "98.1", "99", "98.02", "99.01"),
        notManualCustomPrice(custom_Price_Types), 
        code not memberOf $ExcludedCodes, 
        list == null || list > 0.0d)
      
then
    // Setting the list price, gross, and discount to zero
    $act.setList(0);
    $act.setGross(0);
    $act.setDiscount(0);

    // Adding outcome for logging purposes
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Zero Priced Services", "");
    
    // Updating the Activity with the zero values
    update($act);
end



rule 'CUS_DRG_LIST_DayCase_RESET'
// Define the dialect as MVEL for rule execution  
dialect "mvel"

// Rule priority: -445 (executes before lower-priority rules)
salience -445  

when  
    // Match a Claim where:
    // - CUS_ID is not null  
    // - Extract providerID  
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)  

    // Match a Facility with DHA regulation  
    Facility(license == $providerID, regulator == Regulator.DHA)  

    // Match a CusContract linked to the claims CUS_ID  
    $cusContract: CusContract(ID.intValue() == $CUS_ID.intValue())  

    // Match an Encounter of type 5 or 6  
    Encounter(type in (5,6)) from $c.encounter  

    // Check if an Activity of type **IR_DRG** exists with:
    // - A valid list price  
    // - `custom_Price_Types` set to `"8"`  
    exists (Activity(type == CodeType.IR_DRG, $code: code, list != null))  

    // Collect all excluded CPT codes from DRGExcludedCpts  
    accumulate(
        a: Activity() and  
        DRGExcludedCpts(code == a.code),  
        $ExcludedCodes: collectList(a.code)  
    )  

    // Match an Activity that:
    // - Is **not** an IR_DRG type  
    // - Has `custom_Price_Types` that are **not manually priced**  
    // - Its code is **not in the excluded list** (`$ExcludedCodes`)  
    // - Its code is **not "98" or "98.1"**  
    // - Its list price is either `null` or **greater than zero**  
    $act: Activity(
        type != CodeType.IR_DRG,  
        $custom_Price_Types: custom_Price_Types,  
        notManualCustomPrice(custom_Price_Types),  
        code not memberOf $ExcludedCodes,  
        code not in ("98", "98.1"),  
        list == null || list > 0.0d  
    )  

then  
    // Set all financial fields to zero  
    $act.setList(0);  
    $act.setGross(0);  
    $act.setDiscount(0);  

    // Add an outcome message  
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),  
        "Zero Priced Services custom_Price_Types: " + $custom_Price_Types, "");  

    // Update the activity in working memory  
    update($act); 
end

rule 'HCPCS_LIST_PRICE'
dialect 'mvel'                        // Use the MVEL dialect for expressions.
salience -107                         // Set rule priority; lower salience means lower priority.

when
    // Retrieve a Claim object:
    // - Bind CUS_ID to $CUS_ID.
    // - Only match if CUS_ID is null.
    // - Bind providerID to $providerID.
	$c:Claim($CUS_ID:CUS_ID, CUS_ID == null, $providerID:providerID)
	
    // Retrieve an Activity object:
    // - Bind code to $code, type to $type, and providerCode to $providerCode.
    // - Ensure providerCode is not null.
    // - The activity type must equal CodeType.HCPCS.
    // - The list property must be null (i.e., not already set).
	$act:Activity($code:code, $type:type, $providerCode:providerCode,
	              providerCode != null, type == CodeType.HCPCS, list == null)
	
    // Retrieve a RCMFacilityCodeMapping object:
    // - Enshttp://localhost:5556/LIVEGuvnor/org.drools.guvnor.Guvnor/clear.cache.gifure activityCode equals $code.
    // - Ensure facilityLisence equals $providerID.
    // - Ensure providerActivityCode equals $providerCode.
    // - Bind the price field to $price.
	RCMFacilityCodeMapping(activityCode == $code, facilityLisence == $providerID,
                           providerActivityCode == $providerCode, $price:price)
	
then
    // Retrieve the name of the current rule for logging purposes.
    String sRuleName = drools.getRule().getName();
    
    // Determine the list price:
    // - If $price is null or negative, set listPrice to 0.0.
    // - Otherwise, use $price.
    double listPrice = ($price == null || $price < 0) ? 0.0d : roundQuad($price);
    
    // Log the event if logging is enabled in the Claim.
    if($c.logInfo){
        logInfo(sRuleName,
            " Set list price, price=" + listPrice + ", HCPCS Markup = there is none,");
    }
    
    // Set the computed list price on the Activity.
    $act.setList(listPrice);
    
    // Record an outcome on the Activity to indicate that the list price has been set.
    $act.addOutcome(Severity.INFO, sRuleName,
        "Set list price=" + listPrice, "");
    
    // Update the Activity object in the working memory.
    update($act);
end

rule 'CUS_HCPCS_LIST_PRICE'
dialect 'mvel'
salience -98

when
    // Matching Claim with a non-null CUS_ID and providerID
    $c: Claim($CUS_ID: CUS_ID, CUS_ID != null, $providerID: providerID)

    // Matching Activity with HCPCS type and non-null provider code
    $act: Activity($code: code, $type: type, $providerCode: providerCode, type == CodeType.HCPCS, providerCode != null, list == null)

    // Matching RCMFacilityCodeMapping for pricing info based on provider and activity codes
    RCMFacilityCodeMapping(activityCode == $code, facilityLisence == $providerID, providerActivityCode == $providerCode, $price: price)

    // Matching CusContract to get markup for HCPCS pricing
    CusContract(ID.intValue() == $CUS_ID.intValue(), $markup: hspcsMarkUp)

then
    // Getting the rule name for logging
    String sRuleName = drools.getRule().getName();

    // Calculate the final price based on the price from RCMFacilityCodeMapping
    double listPrice = ($price == null || $price < 0) ? 0.0d : $price;
    double finalPrice = roundQuad(listPrice);

    // Apply markup if available
    if ($markup != null) {
        finalPrice = listPrice + $markup * listPrice / 100;
    }

    // Log the price and markup details if logging is enabled
    if ($c.logInfo) {
        logInfo(sRuleName, "Set list price for code ="+$code+", price=" + roundDouble(finalPrice) + ", HCPCS Markup = " + $markup + "");
    }

    // Set the calculated final price to the Activity's list price
    $act.setList(finalPrice);

    // Add an outcome to track this rule execution
    $act.addOutcome(Severity.INFO, sRuleName, "Set list price=" + roundDouble(finalPrice) + ", HCPCS Markup = " + $markup + "", "");

    // Update the Activity with the new list price
    update($act);
end





rule 'CUS_DISCOUNT_PHARMACY_DAMAN_MUBDLA_512'
// Define the dialect as MVEL for rule execution  
dialect "mvel"

// Rule priority: -205 (executes before lower-priority rules)
salience -205  

when  
    // Match a Claim where:
    // - CUS_ID is not null  
    // - receiverID is "A001" (specific receiver)
    // - Extract providerID  
    $c: Claim($CUS_ID: CUS_ID, CUS_ID != null, receiverID == "A001", $providerID: providerID)  

    // Match a Facility with DHA regulation  
    Facility(license == $providerID, regulator == Regulator.DHA)  

    // Match a CusContract linked to the claims CUS_ID, extracting PHARM_DISCOUNT  
    CusContract(ID.intValue() == $CUS_ID.intValue(), $PHARM_DISCOUNT: PHARM_DISCOUNT)  

    // Match an Encounter and extract its start date  
    Encounter($encStart: start) from $c.encounter  

    // Match a trade drug Activity where:
    // - The list price is not null or NaN
    // - The discount is not yet set  
    $act: Activity(
        type == CodeType.TRADE_DRUG,  
        $code: code,  
        list != null,  
        !list.isNaN(),  
        discount == null,  
        $list: list,  
        $quantity: quantity  
    )  

    // Match a DrugPrice entry for the same code and valid date range, extracting discountTier  
    DrugPrice(
        code == $code,  
        startDate == null || $encStart >= startDate,  
        endDate == null || $encStart <= endDate,  
        $DicountTier: discountTier  
    )  

then  
    // Initialize pharmacy discount  
    Double pharmDiscount = ($PHARM_DISCOUNT == null || $PHARM_DISCOUNT < 0) ? 0.0d : $PHARM_DISCOUNT;  

    // Apply additional discount based on Discount Tier  
    if ($DicountTier == 1) {  
        pharmDiscount += 10.0d;  
    }  
    if ($DicountTier == 2 || $DicountTier == 3) {  
        pharmDiscount += 5.0d;  
    }  

    // Log discount application if logging is enabled  
    if ($c.logInfo) {  
        logInfo(drools.getRule().getName(),  
            " Apply discount = " + pharmDiscount +  
            " to Activity ID = " + $act.getIdCaller() + " code = " + $act.getCode());  
    }  

    // Set the discount percentage on the activity  
    $act.setDiscountPercentage(pharmDiscount);  

    // Calculate and apply the final discount  
    $act.setDiscount($act.getDiscountPercentage().isNaN() ? 0 :  
        roundDouble((($list / 100) * $act.getDiscountPercentage()) *  
        ($quantity == null || $quantity.isNaN() || $quantity < 0 ? 1 : $quantity)));  

    // Add outcome message to the activity  
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),  
        " Apply discount = " + pharmDiscount, "");  

    // Update the activity fact in working memory  
    update($act);  

end



rule 'CUS_DRG_LIST_PRICE_NoWeight'
dialect 'mvel'
salience -94

when
    // Matching Claim with non-null CUS_ID
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)
    
    // Matching Facility with a specific regulator (HAAD)
    Facility(license == $providerID, regulator == Regulator.HAAD)
    
    // Matching CusContract for the given CUS_ID and BASE_RATE
    $cusContract: CusContract(ID.intValue() == $CUS_ID.intValue(), $BASE_RATE: BASE_RATE)
    
    // Matching Contract excluding specific package names
    Contract($packageName: packageName, packageName not in ("Enhanced LOW END Plan TC1 - TC2", 
        "Enhanced MID Range Plan TC1 - TC2", "Enhanced HIGH END Plan TC1 - TC2", 
        "ADNIC - TOP UP TC1", "AXA TOP-UP TC1", "AXA TOP-UP TC1 & TC2", 
        "NAS TOP UP TC1", "NAS TOP-UP TC1", "OMAN - TOP UP TC1")) from $c.contract
    
    // Matching Encounter based on the start date
    Encounter($encStart: start) from $c.encounter
    
    // Matching Activity of type IR_DRG (Diagnosis-Related Group)
    $act: Activity(type == CodeType.IR_DRG, $code: code, $start: start,  drg_weight ==null, custom_Price_Types == "8",
 list == null)
   $DRG:DRG(code==$code, $weight:weight)

then
    // Logging the information if logInfo is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            "Set DRG list price, CUS_ID=" + $CUS_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE +
            " total=" + ($weight * $BASE_RATE) +
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Setting the list price for the Activity based on DRG weight and base rate
    $act.setList(roundQuad(($weight == null || $weight < 0 ? Double.NaN : 
        ($BASE_RATE == null || $BASE_RATE < 0 ? Double.NaN : ($weight * $BASE_RATE)))));
    
    // Setting the discount percentage to 0 (the discount logic is commented out)
    $act.setDiscountPercentage(0);

    // Adding outcome for logging purposes
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Set DRG list price, CUS_ID=" + $CUS_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE + 
        " total=" + ($weight * $BASE_RATE), "");
    
    // Updating the Activity with the calculated list price
    update($act);

end

rule 'SPC_DRG_LIST_PRICE_NoWeight'
dialect 'mvel'   // The rule uses the MVEL dialect for rule evaluation.
salience -96     // Priority of the rule. This rule will be evaluated after those with higher salience.

when
    // The rule triggers when a Claim object with a non-null SPC_ID is present.
    $c: Claim($providerID:providerID, $SPC_ID:SPC_ID, SPC_ID != null)

    // Matching Facility with a specific regulator (HAAD)
    Facility(license == $providerID, regulator == Regulator.HAAD)

    // The SPCContract condition ensures that the SPCContract ID matches the SPC_ID from the Claim.
    $spcContract: SPCContract(ID.intValue() == $SPC_ID.intValue(), $BASE_RATE:BASE_RATE)

    // Ensures that the claim's contract is not in the specified excluded package names.
    Contract($packageName:packageName, packageName not in ("Enhanced LOW END Plan TC1 - TC2",
    "Enhanced MID Range Plan TC1 - TC2", 
    "Enhanced HIGH END Plan TC1 - TC2", 
    "ADNIC - TOP UP TC1", 
    "AXA TOP-UP TC1", 
    "AXA TOP-UP TC1 & TC2", 
    "NAS TOP UP TC1", 
    "NAS TOP-UP TC1", 
    "OMAN - TOP UP TC1")) from $c.contract

    // Ensures that the encounter start date is present in the claim.
    Encounter($encStart:start) from $c.encounter

    // The rule applies to activities of type IR_DRG with a null list price.
    $act: Activity(type == CodeType.IR_DRG, $code:code, $start:start, drg_weight ==null, custom_Price_Types == "8", list == null)
   $DRG:DRG(code==$code, $weight:weight) 

then
    // Log the DRG list price computation with relevant details if logging is enabled for the claim.
    if($c.logInfo) {
        logInfo(drools.getRule().getName(),
                " Set DRG list price, SPC_ID=" + $SPC_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE +
                " total=" + ($weight * $BASE_RATE) +
                " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Calculate the list price for the DRG. If weight or base rate is null or less than 0, set the list price to 0.
    $act.setList(roundQuad(($weight == null || $weight < 0 ? 0.0d : 
                 ($BASE_RATE == null || $BASE_RATE < 0 ? 0.0d : ($weight * $BASE_RATE)))));
    
    // Set the discount percentage to 0 for the activity.
    $act.setDiscountPercentage(0);

    // Add an outcome to indicate that the DRG list price was set, including details of the calculation.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
                    " Set DRG list price, SPC_ID=" + $SPC_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE +
                    " total=" + ($weight * $BASE_RATE), "");
    
    // Update the activity with the newly calculated list price and discount.
    update($act);
end

rule 'DRUG_LIST_PRICE_DoH'
dialect 'mvel'  // Using MVEL dialect for rule evaluation.
salience -125   // Rule priority with lower values having lower priority.

when
    // The claim must have a provider ID and its associated contract does not belong to certain plans.
    $c:Claim($providerID:providerID,receiverID == "D001")
    Contract($packageName:packageName, packageName not in ("Enhanced LOW END Plan TC1 - TC2", 
                                                         "Enhanced MID Range Plan TC1 - TC2", 
                                                         "Enhanced HIGH END Plan TC1 - TC2", 
                                                         "ADNIC - TOP UP TC1", 
                                                         "AXA TOP-UP TC1", 
                                                         "AXA TOP-UP TC1 & TC2", 
                                                         "NAS TOP UP TC1", 
                                                         "NAS TOP-UP TC1", 
                                                         "OMAN - TOP UP TC1")) from $c.contract
    
    // Encounter from the claim to get the encounter start date.
    Encounter($encStart:start,start!=null) from $c.encounter
    
    // Facility with matching provider ID and regulator type.
    Facility(license == $providerID, regulator == Regulator.HAAD)
    
    // The activDrugPrice( )ity must be of type TRADE_DRUG with null list price.
    $act:Activity(type == CodeType.TRADE_DRUG, $code:code, $drugType:drugType, list == null)
    
    // Drug price information for the provider and the encounter date.
    DrugPrice(regulator.intValue() == 1,
              code == $code,
              startDate == null || $encStart >= startDate,
              endDate == null || $encStart <= endDate,
              $package_Price_to_Public:package_Price_to_Public,
              $unit_Price_to_Public:unit_Price_to_Public,$INCLUDED_THIQA:INCLUDED_THIQA,$UPP_SCOPE:UPP_SCOPE,$package_Markup:package_Markup,
$unit_Markup:unit_Markup)
    
then

   // Determine whether the price should be unit or package-based.
    Boolean unitPrice = false;
    Double price = null;
    
       // If drug type is null or specific values (0 or 1), the unit price is false, otherwise true.
    if ($drugType == null) {
        unitPrice = true;
    } else {
        unitPrice = ($drugType.intValue() == 0 || $drugType.intValue() == 1) ? false : true;
    }

    // Assign price based on unit price or package price.
    price = unitPrice ? roundQuad($unit_Markup) : roundQuad($package_Markup);

    // Ensure the price is valid; if invalid, set it to NaN.
    price = price == null || price < 0 ? Double.NaN : roundQuad(price);

    // Log the determined price if logging is enabled.
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
                " Set list price, for drug [" + (unitPrice ? "Unit" : "Package") + "] price=" + price +
                " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Set the activity's list price based on the determined price.
    $act.setList(roundQuad(price));

    // Add outcome indicating the price setting action.
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
                    " [" + (unitPrice ? "Unit" : "Package") + "] price=" + price + "", "");

    // Update the activity with the new list price.
    update($act);

end

rule 'CUS_DRG_LIST_PRICE_NoWeight'
dialect 'mvel'
salience -94

when
    // Matching Claim with non-null CUS_ID
    $c: Claim($providerID: providerID, $CUS_ID: CUS_ID, CUS_ID != null)
    
    // Matching Facility with a specific regulator (HAAD)
    Facility(license == $providerID, regulator == Regulator.HAAD)
    
    // Matching CusContract for the given CUS_ID and BASE_RATE
    $cusContract: CusContract(ID.intValue() == $CUS_ID.intValue(), $BASE_RATE: BASE_RATE)
    
    // Matching Contract excluding specific package names
    Contract($packageName: packageName, packageName not in ("Enhanced LOW END Plan TC1 - TC2", 
        "Enhanced MID Range Plan TC1 - TC2", "Enhanced HIGH END Plan TC1 - TC2", 
        "ADNIC - TOP UP TC1", "AXA TOP-UP TC1", "AXA TOP-UP TC1 & TC2", 
        "NAS TOP UP TC1", "NAS TOP-UP TC1", "OMAN - TOP UP TC1")) from $c.contract
    
    // Matching Encounter based on the start date
    Encounter($encStart: start) from $c.encounter
    
    // Matching Activity of type IR_DRG (Diagnosis-Related Group)
    $act: Activity(type == CodeType.IR_DRG, $code:code, $start:start, drg_weight ==null, custom_Price_Types == "8", list == null)
 $DRG:DRG(code==$code, $weight:weight)

then
    // Logging the information if logInfo is enabled
    if ($c.logInfo) {
        logInfo(drools.getRule().getName(),
            "Set DRG list price, CUS_ID=" + $CUS_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE +
            " total=" + ($weight * $BASE_RATE) +
            " to Activity ID=" + $act.getIdCaller() + " code=" + $act.getCode());
    }

    // Setting the list price for the Activity based on DRG weight and base rate
    $act.setList(roundQuad(($weight == null || $weight < 0 ? Double.NaN : 
        ($BASE_RATE == null || $BASE_RATE < 0 ? Double.NaN : ($weight * $BASE_RATE)))));
    
    // Setting the discount percentage to 0 (the discount logic is commented out)
    $act.setDiscountPercentage(0);

    // Adding outcome for logging purposes
    $act.addOutcome(Severity.INFO, drools.getRule().getName(),
        "Set DRG list price, CUS_ID=" + $CUS_ID + " DRG weight=" + $weight + " BASE_RATE=" + $BASE_RATE + 
        " total=" + ($weight * $BASE_RATE), "");
    
    // Updating the Activity with the calculated list price
    update($act);

end

